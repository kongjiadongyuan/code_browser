<dec f='linux/include/linux/vmstat.h' l='271' type='void __inc_zone_state(struct zone * , enum zone_stat_item )'/>
<use f='linux/mm/migrate.c' l='557' u='c' c='migrate_page_move_mapping'/>
<def f='linux/mm/vmstat.c' l='378' ll='392' type='void __inc_zone_state(struct zone * zone, enum zone_stat_item item)'/>
<use f='linux/mm/vmstat.c' l='412' u='c' c='__inc_zone_page_state'/>
<doc f='linux/mm/vmstat.c' l='355'>/*
 * Optimized increment and decrement functions.
 *
 * These are only for a single page and therefore can take a struct page *
 * argument instead of struct zone *. This allows the inclusion of the code
 * generated for page_zone(page) into the optimized functions.
 *
 * No overflow check is necessary and therefore the differential can be
 * incremented or decremented in place which may allow the compilers to
 * generate better code.
 * The increment or decrement is known and therefore one boundary check can
 * be omitted.
 *
 * NOTE: These functions are very performance sensitive. Change only
 * with care.
 *
 * Some processors have inc/dec instructions that are atomic vs an interrupt.
 * However, the code must first determine the differential location in a zone
 * based on the processor number and then inc/dec the counter. There is no
 * guarantee without disabling preemption that the processor will not change
 * in between and therefore the atomicity vs. interrupt cannot be exploited
 * in a useful way here.
 */</doc>
