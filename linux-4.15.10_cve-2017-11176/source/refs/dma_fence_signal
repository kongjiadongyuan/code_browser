<dec f='linux/include/linux/dma-fence.h' l='278' type='int dma_fence_signal(struct dma_fence * fence)'/>
<use f='linux/include/linux/dma-fence.h' l='336' u='c' c='dma_fence_is_signaled'/>
<use f='linux/drivers/dma-buf/dma-fence-array.c' l='42' u='c' c='dma_fence_array_cb_func'/>
<def f='linux/drivers/dma-buf/dma-fence.c' l='108' ll='133' type='int dma_fence_signal(struct dma_fence * fence)'/>
<dec f='linux/drivers/dma-buf/dma-fence.c' l='134' type='int dma_fence_signal(struct dma_fence * )'/>
<use f='linux/drivers/dma-buf/dma-fence.c' l='134' c='dma_fence_signal'/>
<use f='linux/drivers/dma-buf/dma-fence.c' l='134' u='a'/>
<use f='linux/drivers/dma-buf/dma-fence.c' l='134' u='a'/>
<doc f='linux/drivers/dma-buf/dma-fence.c' l='98'>/**
 * dma_fence_signal - signal completion of a fence
 * @fence: the fence to signal
 *
 * Signal completion for software callbacks on a fence, this will unblock
 * dma_fence_wait() calls and run all the callbacks added with
 * dma_fence_add_callback(). Can be called multiple times, but since a fence
 * can only go from unsignaled to signaled state, it will only be effective
 * the first time.
 */</doc>
<use f='linux/drivers/gpu/drm/drm_file.c' l='710' u='c' c='drm_send_event_locked'/>
<use f='linux/drivers/gpu/drm/drm_syncobj.c' l='221' u='c' c='drm_syncobj_assign_null_handle'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_clflush.c' l='95' u='c' c='i915_clflush_work'/>
<use f='linux/drivers/gpu/drm/i915/i915_irq.c' l='1109' u='c' c='notify_ring'/>
<use f='linux/drivers/gpu/drm/i915/intel_breadcrumbs.c' l='610' u='c' c='intel_breadcrumbs_signaler'/>
