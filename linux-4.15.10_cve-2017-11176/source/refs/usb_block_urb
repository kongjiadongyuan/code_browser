<dec f='linux/include/linux/usb.h' l='1691' type='void usb_block_urb(struct urb * urb)'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='561' u='c' c='__usbhid_submit_report'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='612' u='c' c='__usbhid_submit_report'/>
<use f='linux/drivers/usb/core/message.c' l='309' u='c' c='sg_complete'/>
<use f='linux/drivers/usb/core/message.c' l='594' u='c' c='usb_sg_cancel'/>
<def f='linux/drivers/usb/core/urb.c' l='760' ll='766' type='void usb_block_urb(struct urb * urb)'/>
<dec f='linux/drivers/usb/core/urb.c' l='767' type='void usb_block_urb(struct urb * )'/>
<use f='linux/drivers/usb/core/urb.c' l='767' c='usb_block_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='767' u='a'/>
<use f='linux/drivers/usb/core/urb.c' l='767' u='a'/>
<doc f='linux/drivers/usb/core/urb.c' l='748'>/**
 * usb_block_urb - reliably prevent further use of an URB
 * @urb: pointer to URB to be blocked, may be NULL
 *
 * After the routine has run, attempts to resubmit the URB will fail
 * with error -EPERM.  Thus even if the URB&apos;s completion handler always
 * tries to resubmit, it will not succeed and the URB will become idle.
 *
 * The URB must not be deallocated while this routine is running.  In
 * particular, when a driver calls this routine, it must insure that the
 * completion handler cannot deallocate the URB.
 */</doc>
