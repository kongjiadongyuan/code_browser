<dec f='linux/include/linux/mm.h' l='1335' type='void pagecache_isize_extended(struct inode * inode, loff_t from, loff_t to)'/>
<use f='linux/fs/buffer.c' l='2170' u='c' c='generic_write_end'/>
<use f='linux/fs/ext4/inode.c' l='1414' u='c' c='ext4_write_end'/>
<use f='linux/fs/ext4/inode.c' l='1531' u='c' c='ext4_journalled_write_end'/>
<use f='linux/fs/ext4/inode.c' l='5495' u='c' c='ext4_setattr'/>
<use f='linux/mm/truncate.c' l='834' u='c' c='truncate_setsize'/>
<def f='linux/mm/truncate.c' l='858' ll='887' type='void pagecache_isize_extended(struct inode * inode, loff_t from, loff_t to)'/>
<dec f='linux/mm/truncate.c' l='888' type='void pagecache_isize_extended(struct inode * , loff_t , loff_t )'/>
<use f='linux/mm/truncate.c' l='888' c='pagecache_isize_extended'/>
<use f='linux/mm/truncate.c' l='888' u='a'/>
<use f='linux/mm/truncate.c' l='888' u='a'/>
<doc f='linux/mm/truncate.c' l='839'>/**
 * pagecache_isize_extended - update pagecache after extension of i_size
 * @inode:	inode for which i_size was extended
 * @from:	original inode size
 * @to:		new inode size
 *
 * Handle extension of inode size either caused by extending truncate or by
 * write starting after current i_size. We mark the page straddling current
 * i_size RO so that page_mkwrite() is called on the nearest write access to
 * the page.  This way filesystem can be sure that page_mkwrite() is called on
 * the page before user writes to the page via mmap after the i_size has been
 * changed.
 *
 * The function must be called after i_size is updated so that page fault
 * coming after we unlock the page will already see the new i_size.
 * The function must be called while we still hold i_mutex - this not only
 * makes sure i_size is stable but also that userspace cannot observe new
 * i_size value before we are prepared to store mmap writes at new inode size.
 */</doc>
