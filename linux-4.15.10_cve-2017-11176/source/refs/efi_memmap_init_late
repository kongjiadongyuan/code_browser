<dec f='linux/include/linux/efi.h' l='974' type='int efi_memmap_init_late(phys_addr_t addr, unsigned long size)'/>
<use f='linux/arch/x86/platform/efi/efi.c' l='863' u='c' c='kexec_enter_virtual_mode'/>
<use f='linux/arch/x86/platform/efi/efi.c' l='956' u='c' c='__efi_enter_virtual_mode'/>
<def f='linux/drivers/firmware/efi/memmap.c' l='157' ll='179' type='int efi_memmap_init_late(phys_addr_t addr, unsigned long size)'/>
<doc f='linux/drivers/firmware/efi/memmap.c' l='134'>/**
 * efi_memmap_init_late - Map efi.memmap with memremap()
 * @phys_addr: Physical address of the new EFI memory map
 * @size: Size in bytes of the new EFI memory map
 *
 * Setup a mapping of the EFI memory map using ioremap_cache(). This
 * function should only be called once the vmalloc space has been
 * setup and is therefore not suitable for calling during early EFI
 * initialise, e.g. in efi_init(). Additionally, it expects
 * efi_memmap_init_early() to have already been called.
 *
 * The reason there are two EFI memmap initialisation
 * (efi_memmap_init_early() and this late version) is because the
 * early EFI memmap should be explicitly unmapped once EFI
 * initialisation is complete as the fixmap space used to map the EFI
 * memmap (via early_memremap()) is a scarce resource.
 *
 * This late mapping is intended to persist for the duration of
 * runtime so that things like efi_mem_desc_lookup() and
 * efi_mem_attributes() always work.
 *
 * Returns zero on success, a negative error code on failure.
 */</doc>
