<dec f='linux/include/drm/drm_atomic.h' l='560' type='void drm_atomic_set_fence_for_plane(struct drm_plane_state * plane_state, struct dma_fence * fence)'/>
<def f='linux/drivers/gpu/drm/drm_atomic.c' l='1416' ll='1426' type='void drm_atomic_set_fence_for_plane(struct drm_plane_state * plane_state, struct dma_fence * fence)'/>
<dec f='linux/drivers/gpu/drm/drm_atomic.c' l='1427' type='void drm_atomic_set_fence_for_plane(struct drm_plane_state * , struct dma_fence * )'/>
<use f='linux/drivers/gpu/drm/drm_atomic.c' l='1427' c='drm_atomic_set_fence_for_plane'/>
<use f='linux/drivers/gpu/drm/drm_atomic.c' l='1427' u='a'/>
<use f='linux/drivers/gpu/drm/drm_atomic.c' l='1427' u='a'/>
<doc f='linux/drivers/gpu/drm/drm_atomic.c' l='1400'>/**
 * drm_atomic_set_fence_for_plane - set fence for plane
 * @plane_state: atomic state object for the plane
 * @fence: dma_fence to use for the plane
 *
 * Helper to setup the plane_state fence in case it is not set yet.
 * By using this drivers doesn&apos;t need to worry if the user choose
 * implicit or explicit fencing.
 *
 * This function will not set the fence to the state if it was set
 * via explicit fencing interfaces on the atomic ioctl. In that case it will
 * drop the reference to the fence as we are not storing it anywhere.
 * Otherwise, if &amp;drm_plane_state.fence is not set this function we just set it
 * with the received implicit fence. In both cases this function consumes a
 * reference for @fence.
 */</doc>
<use f='linux/drivers/gpu/drm/drm_gem_framebuffer_helper.c' l='261' u='c' c='drm_gem_fb_prepare_fb'/>
