<dec f='linux/include/linux/sched/signal.h' l='290' type='int force_sig_info(int , struct siginfo * , struct task_struct * )'/>
<use f='linux/include/linux/tracehook.h' l='128' u='c' c='tracehook_report_syscall_exit'/>
<use f='linux/arch/x86/entry/vsyscall/vsyscall_64.c' l='120' u='c' c='write_ok_or_segv'/>
<use f='linux/arch/x86/kernel/ptrace.c' l='1400' u='c' c='send_sigtrap'/>
<use f='linux/arch/x86/kernel/traps.c' l='281' u='c' c='do_trap'/>
<use f='linux/arch/x86/kernel/traps.c' l='576' u='c' c='do_general_protection'/>
<use f='linux/arch/x86/kernel/traps.c' l='866' u='c' c='math_error'/>
<use f='linux/arch/x86/kernel/umip.c' l='285' u='c' c='force_sig_info_umip_fault'/>
<use f='linux/arch/x86/kernel/uprobes.c' l='986' u='c' c='arch_uretprobe_hijack_return_addr'/>
<use f='linux/arch/x86/mm/fault.c' l='224' u='c' c='force_sig_info_fault'/>
<use f='linux/kernel/events/uprobes.c' l='1857' u='c' c='handle_trampoline'/>
<use f='linux/kernel/events/uprobes.c' l='1965' u='c' c='handle_singlestep'/>
<use f='linux/kernel/seccomp.c' l='538' u='c' c='seccomp_send_sigsys'/>
<def f='linux/kernel/signal.c' l='1180' ll='1208' type='int force_sig_info(int sig, struct siginfo * info, struct task_struct * t)'/>
<use f='linux/kernel/signal.c' l='1466' u='c' c='force_sig'/>
<doc f='linux/kernel/signal.c' l='1169'>/*
 * Force a signal that the process can&apos;t ignore: if necessary
 * we unblock the signal and change any SIG_IGN to SIG_DFL.
 *
 * Note: If we unblock the signal, we always reset it to SIG_DFL,
 * since we do not want to have a signal handler that was blocked
 * be invoked when user space had explicitly blocked it.
 *
 * We don&apos;t want to have recursive SIGSEGV&apos;s etc, for example,
 * that is why we also clear SIGNAL_UNKILLABLE.
 */</doc>
