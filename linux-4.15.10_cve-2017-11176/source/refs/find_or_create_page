<def f='linux/include/linux/pagemap.h' l='319' ll='325' type='struct page * find_or_create_page(struct address_space * mapping, unsigned long offset, gfp_t gfp_mask)'/>
<use f='linux/include/linux/pagemap.h' l='388' u='c' c='grab_cache_page'/>
<doc f='linux/include/linux/pagemap.h' l='300'>/**
 * find_or_create_page - locate or add a pagecache page
 * @mapping: the page&apos;s address_space
 * @index: the page&apos;s index into the mapping
 * @gfp_mask: page allocation mode
 *
 * Looks up the page cache slot at @mapping &amp; @offset.  If there is a
 * page cache page, it is returned locked and with an increased
 * refcount.
 *
 * If the page is not present, a new page is allocated using @gfp_mask
 * and added to the page cache and the VM&apos;s LRU list.  The page is
 * returned locked and with an increased refcount.
 *
 * On memory exhaustion, %NULL is returned.
 *
 * find_or_create_page() may sleep, even if @gfp_flags specifies an
 * atomic allocation!
 */</doc>
<use f='linux/fs/aio.c' l='493' u='c' c='aio_setup_ring'/>
<use f='linux/fs/buffer.c' l='969' u='c' c='grow_dev_page'/>
<use f='linux/fs/ext4/inode.c' l='3978' u='c' c='__ext4_block_zero_page_range'/>
<use f='linux/fs/ext4/mballoc.c' l='1003' u='c' c='ext4_mb_get_buddy_page_lock'/>
<use f='linux/fs/ext4/mballoc.c' l='1017' u='c' c='ext4_mb_get_buddy_page_lock'/>
<use f='linux/fs/ext4/mballoc.c' l='1169' u='c' c='ext4_mb_load_buddy_gfp'/>
<use f='linux/fs/ext4/mballoc.c' l='1205' u='c' c='ext4_mb_load_buddy_gfp'/>
<use f='linux/net/sunrpc/cache.c' l='899' u='c' c='cache_downcall'/>
