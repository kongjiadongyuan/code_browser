<dec f='linux/include/linux/perf_event.h' l='831' type='void perf_aux_output_end(struct perf_output_handle * handle, unsigned long size)'/>
<use f='linux/arch/x86/events/intel/bts.c' l='279' u='c' c='bts_event_start'/>
<use f='linux/arch/x86/events/intel/bts.c' l='322' u='c' c='bts_event_stop'/>
<use f='linux/arch/x86/events/intel/bts.c' l='486' u='c' c='intel_bts_interrupt'/>
<use f='linux/arch/x86/events/intel/bts.c' l='501' u='c' c='intel_bts_interrupt'/>
<use f='linux/arch/x86/events/intel/pt.c' l='1269' u='c' c='intel_pt_interrupt'/>
<use f='linux/arch/x86/events/intel/pt.c' l='1284' u='c' c='intel_pt_interrupt'/>
<use f='linux/arch/x86/events/intel/pt.c' l='1360' u='c' c='pt_event_start'/>
<use f='linux/arch/x86/events/intel/pt.c' l='1401' u='c' c='pt_event_stop'/>
<def f='linux/kernel/events/ring_buffer.c' l='439' ll='483' type='void perf_aux_output_end(struct perf_output_handle * handle, unsigned long size)'/>
<dec f='linux/kernel/events/ring_buffer.c' l='484' type='void perf_aux_output_end(struct perf_output_handle * , unsigned long )'/>
<use f='linux/kernel/events/ring_buffer.c' l='484' c='perf_aux_output_end'/>
<use f='linux/kernel/events/ring_buffer.c' l='484' u='a'/>
<use f='linux/kernel/events/ring_buffer.c' l='484' u='a'/>
<doc f='linux/kernel/events/ring_buffer.c' l='429'>/*
 * Commit the data written by hardware into the ring buffer by adjusting
 * aux_head and posting a PERF_RECORD_AUX into the perf buffer. It is the
 * pmu driver&apos;s responsibility to observe ordering rules of the hardware,
 * so that all the data is externally visible before this is called.
 *
 * Note: this has to be called from pmu::stop() callback, as the assumption
 * of the AUX buffer management code is that after pmu::stop(), the AUX
 * transaction must be stopped and therefore drop the AUX reference count.
 */</doc>
