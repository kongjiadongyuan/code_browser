<dec f='linux/include/linux/pci.h' l='1243' type='void * devm_pci_remap_cfg_resource(struct device * dev, struct resource * res)'/>
<def f='linux/drivers/pci/pci.c' l='3581' ll='3611' type='void * devm_pci_remap_cfg_resource(struct device * dev, struct resource * res)'/>
<dec f='linux/drivers/pci/pci.c' l='3612' type='void * devm_pci_remap_cfg_resource(struct device * , struct resource * )'/>
<use f='linux/drivers/pci/pci.c' l='3612' c='devm_pci_remap_cfg_resource'/>
<use f='linux/drivers/pci/pci.c' l='3612' u='a'/>
<use f='linux/drivers/pci/pci.c' l='3612' u='a'/>
<doc f='linux/drivers/pci/pci.c' l='3562'>/**
 * devm_pci_remap_cfg_resource - check, request region and ioremap cfg resource
 * @dev: generic device to handle the resource for
 * @res: configuration space resource to be handled
 *
 * Checks that a resource is a valid memory region, requests the memory
 * region and ioremaps with pci_remap_cfgspace() API that ensures the
 * proper PCI configuration space memory attributes are guaranteed.
 *
 * All operations are managed and will be undone on driver detach.
 *
 * Returns a pointer to the remapped memory or an ERR_PTR() encoded error code
 * on failure. Usage example::
 *
 *	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 *	base = devm_pci_remap_cfg_resource(&amp;pdev-&gt;dev, res);
 *	if (IS_ERR(base))
 *		return PTR_ERR(base);
 */</doc>
