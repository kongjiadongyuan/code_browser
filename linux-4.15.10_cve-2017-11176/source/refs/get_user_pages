<dec f='linux/include/linux/mm.h' l='1376' type='long get_user_pages(unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page ** pages, struct vm_area_struct ** vmas)'/>
<use f='linux/include/linux/mm.h' l='1392' u='c' c='get_user_pages_longterm'/>
<def f='linux/mm/gup.c' l='1088' ll='1095' type='long get_user_pages(unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page ** pages, struct vm_area_struct ** vmas)'/>
<dec f='linux/mm/gup.c' l='1096' type='long get_user_pages(unsigned long , unsigned long , unsigned int , struct page ** , struct vm_area_struct ** )'/>
<use f='linux/mm/gup.c' l='1096' c='get_user_pages'/>
<use f='linux/mm/gup.c' l='1096' u='a'/>
<use f='linux/mm/gup.c' l='1096' u='a'/>
<doc f='linux/mm/gup.c' l='1081'>/*
 * This is the same as get_user_pages_remote(), just with a
 * less-flexible calling convention where we assume that the task
 * and mm being operated on are the current task&apos;s and don&apos;t allow
 * passing of a locked parameter.  We also obviously don&apos;t pass
 * FOLL_REMOTE in here.
 */</doc>
<use f='linux/mm/mempolicy.c' l='830' u='c' c='lookup_node'/>
