<def f='linux/include/linux/fsnotify_backend.h' l='98' ll='111'/>
<use f='linux/include/linux/fsnotify_backend.h' l='142'/>
<use f='linux/include/linux/fsnotify_backend.h' l='315' c='fsnotify_alloc_group'/>
<size>40</size>
<doc f='linux/include/linux/fsnotify_backend.h' l='87'>/*
 * Each group much define these ops.  The fsnotify infrastructure will call
 * these operations for each relevant group.
 *
 * handle_event - main call for a group to handle an fs event
 * free_group_priv - called when a group refcnt hits 0 to clean up the private union
 * freeing_mark - called when a mark is being destroyed for some reason.  The group
 * 		MUST be holding a reference on each mark and that reference must be
 * 		dropped in this function.  inotify uses this function to send
 * 		userspace messages that marks have been removed.
 */</doc>
<mbr r='fsnotify_ops::handle_event' o='0' t='int (*)(struct fsnotify_group *, struct inode *, struct fsnotify_mark *, struct fsnotify_mark *, u32, const void *, int, const unsigned char *, u32, struct fsnotify_iter_info *)'/>
<mbr r='fsnotify_ops::free_group_priv' o='64' t='void (*)(struct fsnotify_group *)'/>
<mbr r='fsnotify_ops::freeing_mark' o='128' t='void (*)(struct fsnotify_mark *, struct fsnotify_group *)'/>
<mbr r='fsnotify_ops::free_event' o='192' t='void (*)(struct fsnotify_event *)'/>
<mbr r='fsnotify_ops::free_mark' o='256' t='void (*)(struct fsnotify_mark *)'/>
<use f='linux/fs/notify/dnotify/dnotify.c' l='136'/>
<size>40</size>
<use f='linux/fs/notify/inotify/inotify.h' l='34'/>
<size>40</size>
<use f='linux/fs/notify/group.c' l='125' c='fsnotify_alloc_group'/>
<size>40</size>
<use f='linux/fs/notify/inotify/inotify_fsnotify.c' l='189'/>
<size>40</size>
<use f='linux/kernel/audit_fsnotify.c' l='203'/>
<size>40</size>
<use f='linux/kernel/audit_tree.c' l='1014'/>
<size>40</size>
<use f='linux/kernel/audit_watch.c' l='511'/>
<size>40</size>
