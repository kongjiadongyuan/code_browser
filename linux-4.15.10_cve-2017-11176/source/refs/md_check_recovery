<dec f='linux/drivers/md/md.h' l='660' type='void md_check_recovery(struct mddev * mddev)'/>
<def f='linux/drivers/md/md.c' l='8691' ll='8863' type='void md_check_recovery(struct mddev * mddev)'/>
<dec f='linux/drivers/md/md.c' l='8864' type='void md_check_recovery(struct mddev * )'/>
<use f='linux/drivers/md/md.c' l='8864' c='md_check_recovery'/>
<use f='linux/drivers/md/md.c' l='8864' u='a'/>
<use f='linux/drivers/md/md.c' l='8864' u='a'/>
<doc f='linux/drivers/md/md.c' l='8669'>/*
 * This routine is regularly called by all per-raid-array threads to
 * deal with generic issues like resync and super-block update.
 * Raid personalities that don&apos;t have a thread (linear/raid0) do not
 * need this as they never do any recovery or update the superblock.
 *
 * It does not do any resync itself, but rather &quot;forks&quot; off other threads
 * to do that as needed.
 * When it is determined that resync is needed, we set MD_RECOVERY_RUNNING in
 * &quot;-&gt;recovery&quot; and create a thread at -&gt;sync_thread.
 * When the thread finishes it sets MD_RECOVERY_DONE
 * and wakeups up this thread which will reap the thread and finish up.
 * This thread also removes any faulty devices (with nr_pending == 0).
 *
 * The overall approach is:
 *  1/ if the superblock needs updating, update it.
 *  2/ If a recovery thread is running, don&apos;t do anything else.
 *  3/ If recovery has finished, clean up, possibly marking spares active.
 *  4/ If there are any faulty devices, remove them.
 *  5/ If array is degraded, try to add spares devices
 *  6/ If array has spares or is not in-sync, start a resync thread.
 */</doc>
