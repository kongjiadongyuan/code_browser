<def f='linux/drivers/gpu/drm/i915/i915_drv.h' l='1923' ll='1927'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.h' l='2562'/>
<size>8</size>
<doc f='linux/drivers/gpu/drm/i915/i915_drv.h' l='1900'>/*
 * This struct helps tracking the state needed for runtime PM, which puts the
 * device in PCI D3 state. Notice that when this happens, nothing on the
 * graphics device works, even register access, so we don&apos;t get interrupts nor
 * anything else.
 *
 * Every piece of our code that needs to actually touch the hardware needs to
 * either call intel_runtime_pm_get or call intel_display_power_get with the
 * appropriate power domain.
 *
 * Our driver uses the autosuspend delay feature, which means we&apos;ll only really
 * suspend if we stay with zero refcount for a certain amount of time. The
 * default value is currently very conservative (see intel_runtime_pm_enable), but
 * it can be changed with the standard runtime PM files from sysfs.
 *
 * The irqs_disabled variable becomes true exactly after we disable the IRQs and
 * goes back to false exactly before we reenable the IRQs. We use this variable
 * to check if someone is trying to enable/disable IRQs while they&apos;re supposed
 * to be disabled. This shouldn&apos;t happen and we&apos;ll print some error messages in
 * case it happens.
 *
 * For more, read the Documentation/power/runtime_pm.txt.
 */</doc>
<mbr r='i915_runtime_pm::wakeref_count' o='0' t='atomic_t'/>
<mbr r='i915_runtime_pm::suspended' o='32' t='bool'/>
<mbr r='i915_runtime_pm::irqs_enabled' o='40' t='bool'/>
