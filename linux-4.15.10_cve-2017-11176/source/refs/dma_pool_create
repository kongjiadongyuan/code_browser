<dec f='linux/include/linux/dmapool.h' l='19' type='struct dma_pool * dma_pool_create(const char * name, struct device * dev, size_t size, size_t align, size_t allocation)'/>
<use f='linux/drivers/net/ethernet/intel/e100.c' l='2963' macro='1' u='c' c='e100_probe'/>
<use f='linux/drivers/usb/core/buffer.c' l='78' u='c' c='hcd_buffer_create'/>
<use f='linux/drivers/usb/host/ehci-mem.c' l='144' u='c' c='ehci_mem_init'/>
<use f='linux/drivers/usb/host/ehci-mem.c' l='154' u='c' c='ehci_mem_init'/>
<use f='linux/drivers/usb/host/ehci-mem.c' l='168' u='c' c='ehci_mem_init'/>
<use f='linux/drivers/usb/host/ehci-mem.c' l='178' u='c' c='ehci_mem_init'/>
<use f='linux/drivers/usb/host/ohci-mem.c' l='39' u='c' c='ohci_mem_init'/>
<use f='linux/drivers/usb/host/ohci-mem.c' l='46' u='c' c='ohci_mem_init'/>
<use f='linux/drivers/usb/host/uhci-hcd.c' l='618' u='c' c='uhci_start'/>
<use f='linux/drivers/usb/host/uhci-hcd.c' l='625' u='c' c='uhci_start'/>
<def f='linux/mm/dmapool.c' l='131' ll='203' type='struct dma_pool * dma_pool_create(const char * name, struct device * dev, size_t size, size_t align, size_t boundary)'/>
<dec f='linux/mm/dmapool.c' l='204' type='struct dma_pool * dma_pool_create(const char * , struct device * , size_t , size_t , size_t )'/>
<use f='linux/mm/dmapool.c' l='204' c='dma_pool_create'/>
<use f='linux/mm/dmapool.c' l='204' u='a'/>
<use f='linux/mm/dmapool.c' l='204' u='a'/>
<use f='linux/mm/dmapool.c' l='511' u='c' c='dmam_pool_create'/>
<doc f='linux/mm/dmapool.c' l='110'>/**
 * dma_pool_create - Creates a pool of consistent memory blocks, for dma.
 * @name: name of pool, for diagnostics
 * @dev: device that will be doing the DMA
 * @size: size of the blocks in this pool.
 * @align: alignment requirement for blocks; must be a power of two
 * @boundary: returned blocks won&apos;t cross this power of two boundary
 * Context: !in_interrupt()
 *
 * Returns a dma allocation pool with the requested characteristics, or
 * null if one can&apos;t be created.  Given one of these pools, dma_pool_alloc()
 * may be used to allocate memory.  Such memory will all have &quot;consistent&quot;
 * DMA mappings, accessible by the device and its driver without using
 * cache flushing primitives.  The actual size of blocks allocated may be
 * larger than requested because of alignment.
 *
 * If @boundary is nonzero, objects returned from dma_pool_alloc() won&apos;t
 * cross that size boundary.  This is useful for devices which have
 * addressing restrictions on individual DMA transfers, such as not crossing
 * boundaries of 4KBytes.
 */</doc>
