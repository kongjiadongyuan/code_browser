<def f='linux/include/linux/hrtimer.h' l='448' ll='452' type='u64 hrtimer_forward_now(struct hrtimer * timer, ktime_t interval)'/>
<doc f='linux/include/linux/hrtimer.h' l='432'>/**
 * hrtimer_forward_now - forward the timer expiry so it expires after now
 * @timer:	hrtimer to forward
 * @interval:	the interval to forward
 *
 * Forward the timer expiry so it will expire after the current time
 * of the hrtimer clock base. Returns the number of overruns.
 *
 * Can be safely called from the callback function of @timer. If
 * called from other contexts @timer must neither be enqueued nor
 * running the callback and the caller needs to take care of
 * serialization.
 *
 * Note: This only updates the timer expiry value and does not requeue
 * the timer.
 */</doc>
<use f='linux/arch/x86/events/intel/rapl.c' l='252' u='c' c='rapl_hrtimer_handle'/>
<use f='linux/arch/x86/events/intel/uncore.c' l='273' u='c' c='uncore_pmu_hrtimer'/>
<use f='linux/drivers/gpu/drm/i915/i915_perf.c' l='2299' u='c' c='oa_poll_check_timer_cb'/>
<use f='linux/drivers/mailbox/mailbox.c' l='137' u='c' c='txdone_hrtimer'/>
<use f='linux/drivers/rtc/interface.c' l='565' u='c' c='rtc_pie_update_irq'/>
<use f='linux/fs/timerfd.c' l='287' u='c' c='timerfd_read'/>
<use f='linux/fs/timerfd.c' l='487' u='c' c='do_timerfd_settime'/>
<use f='linux/fs/timerfd.c' l='523' u='c' c='do_timerfd_gettime'/>
<use f='linux/kernel/events/core.c' l='1053' u='c' c='perf_mux_hrtimer_handler'/>
<use f='linux/kernel/events/core.c' l='1099' u='c' c='perf_mux_hrtimer_restart'/>
<use f='linux/kernel/events/core.c' l='8604' u='c' c='perf_swevent_hrtimer'/>
<use f='linux/kernel/sched/rt.c' l='28' u='c' c='sched_rt_period_timer'/>
<use f='linux/kernel/sched/rt.c' l='71' u='c' c='start_rt_bandwidth'/>
<use f='linux/kernel/time/tick-sched.c' l='1136' u='c' c='tick_nohz_switch_to_nohz'/>
