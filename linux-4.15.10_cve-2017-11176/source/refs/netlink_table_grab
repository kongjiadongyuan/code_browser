<dec f='linux/include/linux/netlink.h' l='37' type='void netlink_table_grab()'/>
<def f='linux/net/netlink/af_netlink.c' l='395' ll='418' type='void netlink_table_grab()'/>
<use f='linux/net/netlink/af_netlink.c' l='584' u='c' c='netlink_remove'/>
<use f='linux/net/netlink/af_netlink.c' l='760' u='c' c='netlink_release'/>
<use f='linux/net/netlink/af_netlink.c' l='913' u='c' c='netlink_realloc_groups'/>
<use f='linux/net/netlink/af_netlink.c' l='1020' u='c' c='netlink_bind'/>
<use f='linux/net/netlink/af_netlink.c' l='1623' u='c' c='netlink_setsockopt'/>
<use f='linux/net/netlink/af_netlink.c' l='2014' u='c' c='__netlink_kernel_create'/>
<use f='linux/net/netlink/af_netlink.c' l='2095' u='c' c='netlink_change_ngroups'/>
<use f='linux/net/netlink/af_netlink.c' l='2682' u='c' c='netlink_add_usersock_entry'/>
<doc f='linux/net/netlink/af_netlink.c' l='389'>/* This lock without WQ_FLAG_EXCLUSIVE is good on UP and it is _very_ bad on
 * SMP. Look, when several writers sleep and reader wakes them up, all but one
 * immediately hit write lock and grab all the cpus. Exclusive sleep solves
 * this, _but_ remember, it adds useless work on UP machines.
 */</doc>
<use f='linux/net/netlink/genetlink.c' l='232' u='c' c='genl_validate_assign_mc_groups'/>
<use f='linux/net/netlink/genetlink.c' l='267' u='c' c='genl_unregister_mc_groups'/>
