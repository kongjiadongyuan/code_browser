<dec f='linux/include/scsi/scsi_device.h' l='392' type='int scsi_mode_sense(struct scsi_device * sdev, int dbd, int modepage, unsigned char * buffer, int len, int timeout, int retries, struct scsi_mode_data * data, struct scsi_sense_hdr * )'/>
<def f='linux/drivers/scsi/scsi_lib.c' l='2492' ll='2587' type='int scsi_mode_sense(struct scsi_device * sdev, int dbd, int modepage, unsigned char * buffer, int len, int timeout, int retries, struct scsi_mode_data * data, struct scsi_sense_hdr * sshdr)'/>
<dec f='linux/drivers/scsi/scsi_lib.c' l='2588' type='int scsi_mode_sense(struct scsi_device * , int , int , unsigned char * , int , int , int , struct scsi_mode_data * , struct scsi_sense_hdr * )'/>
<use f='linux/drivers/scsi/scsi_lib.c' l='2588' c='scsi_mode_sense'/>
<use f='linux/drivers/scsi/scsi_lib.c' l='2588' u='a'/>
<use f='linux/drivers/scsi/scsi_lib.c' l='2588' u='a'/>
<doc f='linux/drivers/scsi/scsi_lib.c' l='2475'>/**
 *	scsi_mode_sense - issue a mode sense, falling back from 10 to six bytes if necessary.
 *	@sdev:	SCSI device to be queried
 *	@dbd:	set if mode sense will allow block descriptors to be returned
 *	@modepage: mode page being requested
 *	@buffer: request buffer (may not be smaller than eight bytes)
 *	@len:	length of request buffer.
 *	@timeout: command timeout
 *	@retries: number of retries before failing
 *	@data: returns a structure abstracting the mode header data
 *	@sshdr: place to put sense data (or NULL if no sense to be collected).
 *		must be SCSI_SENSE_BUFFERSIZE big.
 *
 *	Returns zero if unsuccessful, or the header offset (either 4
 *	or 8 depending on whether a six or ten byte command was
 *	issued) if successful.
 */</doc>
<use f='linux/drivers/scsi/sd.c' l='196' u='c' c='cache_type_store'/>
<use f='linux/drivers/scsi/sd.c' l='2614' u='c' c='sd_do_mode_sense'/>
<use f='linux/drivers/scsi/sd.c' l='2872' u='c' c='sd_read_app_tag_own'/>
<use f='linux/drivers/scsi/sr.c' l='866' u='c' c='get_capabilities'/>
