<dec f='linux/include/linux/dma-fence.h' l='285' type='bool dma_fence_remove_callback(struct dma_fence * fence, struct dma_fence_cb * cb)'/>
<def f='linux/drivers/dma-buf/dma-fence.c' l='322' ll='337' type='bool dma_fence_remove_callback(struct dma_fence * fence, struct dma_fence_cb * cb)'/>
<dec f='linux/drivers/dma-buf/dma-fence.c' l='338' type='bool dma_fence_remove_callback(struct dma_fence * , struct dma_fence_cb * )'/>
<use f='linux/drivers/dma-buf/dma-fence.c' l='338' c='dma_fence_remove_callback'/>
<use f='linux/drivers/dma-buf/dma-fence.c' l='338' u='a'/>
<use f='linux/drivers/dma-buf/dma-fence.c' l='338' u='a'/>
<use f='linux/drivers/dma-buf/dma-fence.c' l='532' u='c' c='dma_fence_wait_any_timeout'/>
<doc f='linux/drivers/dma-buf/dma-fence.c' l='307'>/**
 * dma_fence_remove_callback - remove a callback from the signaling list
 * @fence:	[in]	the fence to wait on
 * @cb:		[in]	the callback to remove
 *
 * Remove a previously queued callback from the fence. This function returns
 * true if the callback is successfully removed, or false if the fence has
 * already been signaled.
 *
 * *WARNING*:
 * Cancelling a callback should only be done if you really know what you&apos;re
 * doing, since deadlocks and race conditions could occur all too easily. For
 * this reason, it should only ever be done on hardware lockup recovery,
 * with a reference held to the fence.
 */</doc>
<use f='linux/drivers/dma-buf/sync_file.c' l='308' u='c' c='sync_file_release'/>
<use f='linux/drivers/gpu/drm/drm_syncobj.c' l='765' u='c' c='drm_syncobj_array_wait_timeout'/>
