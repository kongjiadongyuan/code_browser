<dec f='linux/arch/x86/include/asm/processor.h' l='870'/>
<doc f='linux/arch/x86/include/asm/processor.h' l='852'>/*
 * User space process size.  This is the first address outside the user range.
 * There are a few constraints that determine this:
 *
 * On Intel CPUs, if a SYSCALL instruction is at the highest canonical
 * address, then that syscall will enter the kernel with a
 * non-canonical return address, and SYSRET will explode dangerously.
 * We avoid this particular problem by preventing anything executable
 * from being mapped at the maximum canonical address.
 *
 * On AMD CPUs in the Ryzen family, there&apos;s a nasty bug in which the
 * CPUs malfunction if they execute code from the highest canonical page.
 * They&apos;ll speculate right off the end of the canonical space, and
 * bad things happen.  This is worked around in the same way as the
 * Intel problem.
 *
 * With page table isolation enabled, we map the LDT in ... [stay tuned]
 */</doc>
<use f='linux/arch/x86/entry/vdso/vma.c' l='231' u='c'/>
<use f='linux/arch/x86/entry/vdso/vma.c' l='232' u='c'/>
<use f='linux/arch/x86/kernel/hw_breakpoint.c' l='188' u='c'/>
<use f='linux/arch/x86/kernel/hw_breakpoint.c' l='188' u='c'/>
<use f='linux/arch/x86/kernel/hw_breakpoint.c' l='257' u='c'/>
<use f='linux/arch/x86/kernel/process_64.c' l='611' u='c'/>
<use f='linux/arch/x86/kernel/process_64.c' l='625' u='c'/>
<use f='linux/arch/x86/kernel/ptrace.c' l='396' u='c'/>
<use f='linux/arch/x86/kernel/ptrace.c' l='410' u='c'/>
<use f='linux/arch/x86/kernel/sys_x86_64.c' l='223' u='c'/>
<use f='linux/arch/x86/kernel/traps.c' l='164' u='c'/>
<use f='linux/arch/x86/mm/fault.c' l='138' u='c'/>
<use f='linux/arch/x86/mm/fault.c' l='910' u='c'/>
<use f='linux/arch/x86/mm/fault.c' l='1212' u='c'/>
<use f='linux/arch/x86/mm/hugetlbpage.c' l='120' u='c'/>
<use f='linux/arch/x86/mm/mmap.c' l='49' u='c'/>
