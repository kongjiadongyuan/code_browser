<dec f='linux/kernel/rcu/rcu.h' l='339'/>
<use f='linux/kernel/rcu/srcutree.c' l='833' u='c'/>
<doc f='linux/kernel/rcu/rcu.h' l='325'>/*
 * Wrappers for the rcu_node::lock acquire and release.
 *
 * Because the rcu_nodes form a tree, the tree traversal locking will observe
 * different lock values, this in turn means that an UNLOCK of one level
 * followed by a LOCK of another level does not imply a full memory barrier;
 * and most importantly transitivity is lost.
 *
 * In order to restore full ordering between tree levels, augment the regular
 * lock acquire functions with smp_mb__after_unlock_lock().
 *
 * As -&gt;lock of struct rcu_node is a __private field, therefore one should use
 * these wrappers rather than directly call raw_spin_{lock,unlock}* on -&gt;lock.
 */</doc>
<use f='linux/kernel/rcu/tree.c' l='1284' u='c'/>
<use f='linux/kernel/rcu/tree.c' l='1801' u='c'/>
<use f='linux/kernel/rcu/tree.c' l='2555' u='c'/>
<use f='linux/kernel/rcu/tree.c' l='2688' u='c'/>
<use f='linux/kernel/rcu/tree.c' l='2968' u='c'/>
<use f='linux/kernel/rcu/tree.c' l='3060' u='c'/>
<use f='linux/kernel/rcu/tree.c' l='3706' u='c'/>
<use f='linux/kernel/rcu/tree.c' l='3765' u='c'/>
<use f='linux/kernel/rcu/tree.c' l='3979' u='c'/>
<use f='linux/kernel/rcu/tree_exp.h' l='192' u='c'/>
