<use f='linux/include/linux/usb.h' l='1341'/>
<def f='linux/include/linux/usb.h' l='1526' ll='1563'/>
<use f='linux/include/linux/usb.h' l='1581' c='usb_fill_control_urb'/>
<use f='linux/include/linux/usb.h' l='1612' c='usb_fill_bulk_urb'/>
<use f='linux/include/linux/usb.h' l='1653' c='usb_fill_int_urb'/>
<use f='linux/include/linux/usb.h' l='1681' c='usb_init_urb'/>
<use f='linux/include/linux/usb.h' l='1682' c='usb_alloc_urb'/>
<use f='linux/include/linux/usb.h' l='1683' c='usb_free_urb'/>
<use f='linux/include/linux/usb.h' l='1685' c='usb_get_urb'/>
<use f='linux/include/linux/usb.h' l='1685' c='usb_get_urb'/>
<use f='linux/include/linux/usb.h' l='1686' c='usb_submit_urb'/>
<use f='linux/include/linux/usb.h' l='1687' c='usb_unlink_urb'/>
<use f='linux/include/linux/usb.h' l='1688' c='usb_kill_urb'/>
<use f='linux/include/linux/usb.h' l='1689' c='usb_poison_urb'/>
<use f='linux/include/linux/usb.h' l='1690' c='usb_unpoison_urb'/>
<use f='linux/include/linux/usb.h' l='1691' c='usb_block_urb'/>
<use f='linux/include/linux/usb.h' l='1698' c='usb_anchor_urb'/>
<use f='linux/include/linux/usb.h' l='1699' c='usb_unanchor_urb'/>
<use f='linux/include/linux/usb.h' l='1702' c='usb_get_from_anchor'/>
<use f='linux/include/linux/usb.h' l='1715' c='usb_urb_dir_in'/>
<use f='linux/include/linux/usb.h' l='1727' c='usb_urb_dir_out'/>
<use f='linux/include/linux/usb.h' l='1732' c='usb_urb_ep_type_check'/>
<use f='linux/include/linux/usb.h' l='1843'/>
<size>192</size>
<doc f='linux/include/linux/usb.h' l='1343'>/**
 * struct urb - USB Request Block
 * @urb_list: For use by current owner of the URB.
 * @anchor_list: membership in the list of an anchor
 * @anchor: to anchor URBs to a common mooring
 * @ep: Points to the endpoint&apos;s data structure.  Will eventually
 *	replace @pipe.
 * @pipe: Holds endpoint number, direction, type, and more.
 *	Create these values with the eight macros available;
 *	usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is &quot;ctrl&quot;
 *	(control), &quot;bulk&quot;, &quot;int&quot; (interrupt), or &quot;iso&quot; (isochronous).
 *	For example usb_sndbulkpipe() or usb_rcvintpipe().  Endpoint
 *	numbers range from zero to fifteen.  Note that &quot;in&quot; endpoint two
 *	is a different endpoint (and pipe) from &quot;out&quot; endpoint two.
 *	The current configuration controls the existence, type, and
 *	maximum packet size of any given endpoint.
 * @stream_id: the endpoint&apos;s stream ID for bulk streams
 * @dev: Identifies the USB device to perform the request.
 * @status: This is read in non-iso completion functions to get the
 *	status of the particular request.  ISO requests only use it
 *	to tell whether the URB was unlinked; detailed status for
 *	each frame is in the fields of the iso_frame-desc.
 * @transfer_flags: A variety of flags may be used to affect how URB
 *	submission, unlinking, or operation are handled.  Different
 *	kinds of URB can use different flags.
 * @transfer_buffer:  This identifies the buffer to (or from) which the I/O
 *	request will be performed unless URB_NO_TRANSFER_DMA_MAP is set
 *	(however, do not leave garbage in transfer_buffer even then).
 *	This buffer must be suitable for DMA; allocate it with
 *	kmalloc() or equivalent.  For transfers to &quot;in&quot; endpoints, contents
 *	of this buffer will be modified.  This buffer is used for the data
 *	stage of control transfers.
 * @transfer_dma: When transfer_flags includes URB_NO_TRANSFER_DMA_MAP,
 *	the device driver is saying that it provided this DMA address,
 *	which the host controller driver should use in preference to the
 *	transfer_buffer.
 * @sg: scatter gather buffer list, the buffer size of each element in
 * 	the list (except the last) must be divisible by the endpoint&apos;s
 * 	max packet size if no_sg_constraint isn&apos;t set in &apos;struct usb_bus&apos;
 * @num_mapped_sgs: (internal) number of mapped sg entries
 * @num_sgs: number of entries in the sg list
 * @transfer_buffer_length: How big is transfer_buffer.  The transfer may
 *	be broken up into chunks according to the current maximum packet
 *	size for the endpoint, which is a function of the configuration
 *	and is encoded in the pipe.  When the length is zero, neither
 *	transfer_buffer nor transfer_dma is used.
 * @actual_length: This is read in non-iso completion functions, and
 *	it tells how many bytes (out of transfer_buffer_length) were
 *	transferred.  It will normally be the same as requested, unless
 *	either an error was reported or a short read was performed.
 *	The URB_SHORT_NOT_OK transfer flag may be used to make such
 *	short reads be reported as errors.
 * @setup_packet: Only used for control transfers, this points to eight bytes
 *	of setup data.  Control transfers always start by sending this data
 *	to the device.  Then transfer_buffer is read or written, if needed.
 * @setup_dma: DMA pointer for the setup packet.  The caller must not use
 *	this field; setup_packet must point to a valid buffer.
 * @start_frame: Returns the initial frame for isochronous transfers.
 * @number_of_packets: Lists the number of ISO transfer buffers.
 * @interval: Specifies the polling interval for interrupt or isochronous
 *	transfers.  The units are frames (milliseconds) for full and low
 *	speed devices, and microframes (1/8 millisecond) for highspeed
 *	and SuperSpeed devices.
 * @error_count: Returns the number of ISO transfers that reported errors.
 * @context: For use in completion functions.  This normally points to
 *	request-specific driver context.
 * @complete: Completion handler. This URB is passed as the parameter to the
 *	completion function.  The completion function may then do what
 *	it likes with the URB, including resubmitting or freeing it.
 * @iso_frame_desc: Used to provide arrays of ISO transfer buffers and to
 *	collect the transfer status for each buffer.
 *
 * This structure identifies USB transfer requests.  URBs must be allocated by
 * calling usb_alloc_urb() and freed with a call to usb_free_urb().
 * Initialization may be done using various usb_fill_*_urb() functions.  URBs
 * are submitted using usb_submit_urb(), and pending requests may be canceled
 * using usb_unlink_urb() or usb_kill_urb().
 *
 * Data Transfer Buffers:
 *
 * Normally drivers provide I/O buffers allocated with kmalloc() or otherwise
 * taken from the general page pool.  That is provided by transfer_buffer
 * (control requests also use setup_packet), and host controller drivers
 * perform a dma mapping (and unmapping) for each buffer transferred.  Those
 * mapping operations can be expensive on some platforms (perhaps using a dma
 * bounce buffer or talking to an IOMMU),
 * although they&apos;re cheap on commodity x86 and ppc hardware.
 *
 * Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag,
 * which tells the host controller driver that no such mapping is needed for
 * the transfer_buffer since
 * the device driver is DMA-aware.  For example, a device driver might
 * allocate a DMA buffer with usb_alloc_coherent() or call usb_buffer_map().
 * When this transfer flag is provided, host controller drivers will
 * attempt to use the dma address found in the transfer_dma
 * field rather than determining a dma address themselves.
 *
 * Note that transfer_buffer must still be set if the controller
 * does not support DMA (as indicated by bus.uses_dma) and when talking
 * to root hub. If you have to trasfer between highmem zone and the device
 * on such controller, create a bounce buffer or bail out with an error.
 * If transfer_buffer cannot be set (is in highmem) and the controller is DMA
 * capable, assign NULL to it, so that usbmon knows not to use the value.
 * The setup_packet must always be set, so it cannot be located in highmem.
 *
 * Initialization:
 *
 * All URBs submitted must initialize the dev, pipe, transfer_flags (may be
 * zero), and complete fields.  All URBs must also initialize
 * transfer_buffer and transfer_buffer_length.  They may provide the
 * URB_SHORT_NOT_OK transfer flag, indicating that short reads are
 * to be treated as errors; that flag is invalid for write requests.
 *
 * Bulk URBs may
 * use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers
 * should always terminate with a short packet, even if it means adding an
 * extra zero length packet.
 *
 * Control URBs must provide a valid pointer in the setup_packet field.
 * Unlike the transfer_buffer, the setup_packet may not be mapped for DMA
 * beforehand.
 *
 * Interrupt URBs must provide an interval, saying how often (in milliseconds
 * or, for highspeed devices, 125 microsecond units)
 * to poll for transfers.  After the URB has been submitted, the interval
 * field reflects how the transfer was actually scheduled.
 * The polling interval may be more frequent than requested.
 * For example, some controllers have a maximum interval of 32 milliseconds,
 * while others support intervals of up to 1024 milliseconds.
 * Isochronous URBs also have transfer intervals.  (Note that for isochronous
 * endpoints, as well as high speed interrupt endpoints, the encoding of
 * the transfer interval in the endpoint descriptor is logarithmic.
 * Device drivers must convert that value to linear units themselves.)
 *
 * If an isochronous endpoint queue isn&apos;t already running, the host
 * controller will schedule a new URB to start as soon as bandwidth
 * utilization allows.  If the queue is running then a new URB will be
 * scheduled to start in the first transfer slot following the end of the
 * preceding URB, if that slot has not already expired.  If the slot has
 * expired (which can happen when IRQ delivery is delayed for a long time),
 * the scheduling behavior depends on the URB_ISO_ASAP flag.  If the flag
 * is clear then the URB will be scheduled to start in the expired slot,
 * implying that some of its packets will not be transferred; if the flag
 * is set then the URB will be scheduled in the first unexpired slot,
 * breaking the queue&apos;s synchronization.  Upon URB completion, the
 * start_frame field will be set to the (micro)frame number in which the
 * transfer was scheduled.  Ranges for frame counter values are HC-specific
 * and can go from as low as 256 to as high as 65536 frames.
 *
 * Isochronous URBs have a different data transfer model, in part because
 * the quality of service is only &quot;best effort&quot;.  Callers provide specially
 * allocated URBs, with number_of_packets worth of iso_frame_desc structures
 * at the end.  Each such packet is an individual ISO transfer.  Isochronous
 * URBs are normally queued, submitted by drivers to arrange that
 * transfers are at least double buffered, and then explicitly resubmitted
 * in completion handlers, so
 * that data (such as audio or video) streams at as constant a rate as the
 * host controller scheduler can support.
 *
 * Completion Callbacks:
 *
 * The completion callback is made in_interrupt(), and one of the first
 * things that a completion handler should do is check the status field.
 * The status field is provided for all URBs.  It is used to report
 * unlinked URBs, and status for all non-ISO transfers.  It should not
 * be examined before the URB is returned to the completion handler.
 *
 * The context field is normally used to link URBs back to the relevant
 * driver or request state.
 *
 * When the completion callback is invoked for non-isochronous URBs, the
 * actual_length field tells how many bytes were transferred.  This field
 * is updated even when the URB terminated with an error or was unlinked.
 *
 * ISO transfer status is reported in the status and actual_length fields
 * of the iso_frame_desc array, and the number of errors is reported in
 * error_count.  Completion callbacks for ISO transfers will normally
 * (re)submit URBs to ensure a constant transfer rate.
 *
 * Note that even fields marked &quot;public&quot; should not be touched by the driver
 * when the urb is owned by the hcd, that is, since the call to
 * usb_submit_urb() till the entry into the completion routine.
 */</doc>
<mbr r='urb::kref' o='0' t='struct kref'/>
<mbr r='urb::hcpriv' o='64' t='void *'/>
<mbr r='urb::use_count' o='128' t='atomic_t'/>
<mbr r='urb::reject' o='160' t='atomic_t'/>
<mbr r='urb::unlinked' o='192' t='int'/>
<mbr r='urb::urb_list' o='256' t='struct list_head'/>
<mbr r='urb::anchor_list' o='384' t='struct list_head'/>
<mbr r='urb::anchor' o='512' t='struct usb_anchor *'/>
<mbr r='urb::dev' o='576' t='struct usb_device *'/>
<mbr r='urb::ep' o='640' t='struct usb_host_endpoint *'/>
<mbr r='urb::pipe' o='704' t='unsigned int'/>
<mbr r='urb::stream_id' o='736' t='unsigned int'/>
<mbr r='urb::status' o='768' t='int'/>
<mbr r='urb::transfer_flags' o='800' t='unsigned int'/>
<mbr r='urb::transfer_buffer' o='832' t='void *'/>
<mbr r='urb::transfer_dma' o='896' t='dma_addr_t'/>
<mbr r='urb::sg' o='960' t='struct scatterlist *'/>
<mbr r='urb::num_mapped_sgs' o='1024' t='int'/>
<mbr r='urb::num_sgs' o='1056' t='int'/>
<mbr r='urb::transfer_buffer_length' o='1088' t='u32'/>
<mbr r='urb::actual_length' o='1120' t='u32'/>
<mbr r='urb::setup_packet' o='1152' t='unsigned char *'/>
<mbr r='urb::setup_dma' o='1216' t='dma_addr_t'/>
<mbr r='urb::start_frame' o='1280' t='int'/>
<mbr r='urb::number_of_packets' o='1312' t='int'/>
<mbr r='urb::interval' o='1344' t='int'/>
<mbr r='urb::error_count' o='1376' t='int'/>
<mbr r='urb::context' o='1408' t='void *'/>
<mbr r='urb::complete' o='1472' t='usb_complete_t'/>
<mbr r='urb::iso_frame_desc' o='1536' t='struct usb_iso_packet_descriptor [0]'/>
<use f='linux/drivers/hid/usbhid/usbhid.h' l='77'/>
<use f='linux/drivers/hid/usbhid/usbhid.h' l='81'/>
<use f='linux/drivers/hid/usbhid/usbhid.h' l='89'/>
<size>192</size>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='270' c='hid_irq_in'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='428' c='hid_irq_out'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='475' c='hid_ctrl'/>
<size>192</size>
<use f='linux/drivers/usb/class/usblp.c' l='291' c='usblp_bulk_read'/>
<use f='linux/drivers/usb/class/usblp.c' l='314' c='usblp_bulk_write'/>
<use f='linux/drivers/usb/class/usblp.c' l='688' c='usblp_new_writeurb'/>
<use f='linux/drivers/usb/class/usblp.c' l='690' c='usblp_new_writeurb'/>
<use f='linux/drivers/usb/class/usblp.c' l='714' c='usblp_write'/>
<use f='linux/drivers/usb/class/usblp.c' l='978' c='usblp_submit_read'/>
<size>192</size>
<use f='linux/include/linux/usb/hcd.h' l='91'/>
<use f='linux/include/linux/usb/hcd.h' l='285'/>
<use f='linux/include/linux/usb/hcd.h' l='287'/>
<use f='linux/include/linux/usb/hcd.h' l='298'/>
<use f='linux/include/linux/usb/hcd.h' l='300'/>
<use f='linux/include/linux/usb/hcd.h' l='416' c='usb_hcd_link_urb_to_ep'/>
<use f='linux/include/linux/usb/hcd.h' l='417' c='usb_hcd_check_unlink_urb'/>
<use f='linux/include/linux/usb/hcd.h' l='419' c='usb_hcd_unlink_urb_from_ep'/>
<use f='linux/include/linux/usb/hcd.h' l='421' c='usb_hcd_submit_urb'/>
<use f='linux/include/linux/usb/hcd.h' l='422' c='usb_hcd_unlink_urb'/>
<use f='linux/include/linux/usb/hcd.h' l='423' c='usb_hcd_giveback_urb'/>
<use f='linux/include/linux/usb/hcd.h' l='425' c='usb_hcd_map_urb_for_dma'/>
<use f='linux/include/linux/usb/hcd.h' l='427' c='usb_hcd_unmap_urb_setup_for_dma'/>
<use f='linux/include/linux/usb/hcd.h' l='428' c='usb_hcd_unmap_urb_for_dma'/>
<use f='linux/include/linux/usb/hcd.h' l='556' c='usb_hub_clear_tt_buffer'/>
<use f='linux/include/linux/usb/hcd.h' l='665'/>
<use f='linux/include/linux/usb/hcd.h' l='666'/>
<use f='linux/include/linux/usb/hcd.h' l='667'/>
<use f='linux/include/linux/usb/hcd.h' l='673' c='usbmon_urb_submit'/>
<use f='linux/include/linux/usb/hcd.h' l='679' c='usbmon_urb_submit_error'/>
<use f='linux/include/linux/usb/hcd.h' l='686' c='usbmon_urb_complete'/>
<size>192</size>
<use f='linux/drivers/usb/core/devio.c' l='94'/>
<use f='linux/drivers/usb/core/devio.c' l='494' c='snoop_urb_data'/>
<use f='linux/drivers/usb/core/devio.c' l='516' c='copy_urb_data_to_user'/>
<use f='linux/drivers/usb/core/devio.c' l='549' c='cancel_bulk_urbs'/>
<use f='linux/drivers/usb/core/devio.c' l='583' c='async_completed'/>
<use f='linux/drivers/usb/core/devio.c' l='629' c='destroy_async'/>
<use f='linux/drivers/usb/core/devio.c' l='1085' c='proc_control'/>
<use f='linux/drivers/usb/core/devio.c' l='1149' c='proc_control'/>
<use f='linux/drivers/usb/core/devio.c' l='1178' c='proc_bulk'/>
<use f='linux/drivers/usb/core/devio.c' l='1180' c='proc_bulk'/>
<use f='linux/drivers/usb/core/devio.c' l='1224' c='proc_bulk'/>
<use f='linux/drivers/usb/core/devio.c' l='1602' c='proc_do_submiturb'/>
<use f='linux/drivers/usb/core/devio.c' l='1806' c='proc_unlinkurb'/>
<use f='linux/drivers/usb/core/devio.c' l='1827' c='compute_isochronous_actual_length'/>
<use f='linux/drivers/usb/core/devio.c' l='1841' c='processcompl'/>
<use f='linux/drivers/usb/core/devio.c' l='2010' c='processcompl_compat'/>
<size>192</size>
<use f='linux/drivers/usb/core/hcd.c' l='474' c='rh_call_control'/>
<use f='linux/drivers/usb/core/hcd.c' l='749' c='usb_hcd_poll_rh_status'/>
<use f='linux/drivers/usb/core/hcd.c' l='800' c='rh_queue_status'/>
<use f='linux/drivers/usb/core/hcd.c' l='831' c='rh_urb_enqueue'/>
<use f='linux/drivers/usb/core/hcd.c' l='845' c='usb_rh_urb_dequeue'/>
<use f='linux/drivers/usb/core/hcd.c' l='1239' c='usb_hcd_link_urb_to_ep'/>
<use f='linux/drivers/usb/core/hcd.c' l='1297' c='usb_hcd_check_unlink_urb'/>
<use f='linux/drivers/usb/core/hcd.c' l='1330' c='usb_hcd_unlink_urb_from_ep'/>
<use f='linux/drivers/usb/core/hcd.c' l='1423' c='usb_hcd_unmap_urb_setup_for_dma'/>
<use f='linux/drivers/usb/core/hcd.c' l='1443' c='unmap_urb_for_dma'/>
<use f='linux/drivers/usb/core/hcd.c' l='1451' c='usb_hcd_unmap_urb_for_dma'/>
<use f='linux/drivers/usb/core/hcd.c' l='1489' c='map_urb_for_dma'/>
<use f='linux/drivers/usb/core/hcd.c' l='1498' c='usb_hcd_map_urb_for_dma'/>
<use f='linux/drivers/usb/core/hcd.c' l='1626' c='usb_hcd_submit_urb'/>
<use f='linux/drivers/usb/core/hcd.c' l='1679' c='unlink1'/>
<use f='linux/drivers/usb/core/hcd.c' l='1701' c='usb_hcd_unlink_urb'/>
<use f='linux/drivers/usb/core/hcd.c' l='1734' c='__usb_hcd_giveback_urb'/>
<use f='linux/drivers/usb/core/hcd.c' l='1790' c='usb_giveback_urb_bh'/>
<use f='linux/drivers/usb/core/hcd.c' l='1792' c='usb_giveback_urb_bh'/>
<use f='linux/drivers/usb/core/hcd.c' l='1792' c='usb_giveback_urb_bh'/>
<use f='linux/drivers/usb/core/hcd.c' l='1792' c='usb_giveback_urb_bh'/>
<use f='linux/drivers/usb/core/hcd.c' l='1824' c='usb_hcd_giveback_urb'/>
<use f='linux/drivers/usb/core/hcd.c' l='1870' c='usb_hcd_flush_endpoint'/>
<use f='linux/drivers/usb/core/hcd.c' l='1924' c='usb_hcd_flush_endpoint'/>
<use f='linux/drivers/usb/core/hcd.c' l='1924' c='usb_hcd_flush_endpoint'/>
<use f='linux/drivers/usb/core/hcd.c' l='1924' c='usb_hcd_flush_endpoint'/>
<size>192</size>
<use f='linux/drivers/usb/core/hub.h' l='23'/>
<use f='linux/drivers/usb/core/hub.c' l='666' c='hub_irq'/>
<use f='linux/drivers/usb/core/hub.c' l='818' c='usb_hub_clear_tt_buffer'/>
<size>192</size>
<use f='linux/drivers/usb/core/message.c' l='32' c='usb_api_blocking_completion'/>
<use f='linux/drivers/usb/core/message.c' l='47' c='usb_start_wait_urb'/>
<use f='linux/drivers/usb/core/message.c' l='89' c='usb_internal_control_msg'/>
<use f='linux/drivers/usb/core/message.c' l='227' c='usb_bulk_msg'/>
<use f='linux/drivers/usb/core/message.c' l='265' c='sg_complete'/>
<use f='linux/drivers/usb/core/message.c' l='397' c='usb_sg_init'/>
<size>192</size>
<use f='linux/drivers/usb/core/urb.c' l='21' c='urb_destroy'/>
<use f='linux/drivers/usb/core/urb.c' l='16' c='urb_destroy'/>
<use f='linux/drivers/usb/core/urb.c' l='16' c='urb_destroy'/>
<use f='linux/drivers/usb/core/urb.c' l='16' c='urb_destroy'/>
<use f='linux/drivers/usb/core/urb.c' l='43' c='usb_init_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='69' c='usb_alloc_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='71' c='usb_alloc_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='73' c='usb_alloc_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='93' c='usb_free_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='110' c='usb_get_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='110' c='usb_get_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='126' c='usb_anchor_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='149' c='__usb_unanchor_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='164' c='usb_unanchor_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='202' c='usb_urb_ep_type_check'/>
<use f='linux/drivers/usb/core/urb.c' l='352' c='usb_submit_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='644' c='usb_unlink_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='683' c='usb_kill_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='724' c='usb_poison_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='739' c='usb_unpoison_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='760' c='usb_block_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='781' c='usb_kill_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='785' c='usb_kill_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='785' c='usb_kill_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='785' c='usb_kill_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='813' c='usb_poison_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='818' c='usb_poison_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='818' c='usb_poison_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='818' c='usb_poison_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='842' c='usb_unpoison_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='866' c='usb_unlink_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='937' c='usb_get_from_anchor'/>
<use f='linux/drivers/usb/core/urb.c' l='939' c='usb_get_from_anchor'/>
<use f='linux/drivers/usb/core/urb.c' l='944' c='usb_get_from_anchor'/>
<use f='linux/drivers/usb/core/urb.c' l='944' c='usb_get_from_anchor'/>
<use f='linux/drivers/usb/core/urb.c' l='944' c='usb_get_from_anchor'/>
<use f='linux/drivers/usb/core/urb.c' l='966' c='usb_scuttle_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='971' c='usb_scuttle_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='971' c='usb_scuttle_anchored_urbs'/>
<use f='linux/drivers/usb/core/urb.c' l='971' c='usb_scuttle_anchored_urbs'/>
<size>192</size>
<use f='linux/drivers/usb/host/ehci.h' l='316'/>
<use f='linux/drivers/usb/host/ehci.h' l='528'/>
<use f='linux/drivers/usb/host/ehci.h' l='574'/>
<use f='linux/drivers/usb/host/ehci-q.c' l='152' c='ehci_clear_tt_buffer'/>
<use f='linux/drivers/usb/host/ehci-q.c' l='185' c='qtd_copy_status'/>
<use f='linux/drivers/usb/host/ehci-q.c' l='240' c='ehci_urb_done'/>
<use f='linux/drivers/usb/host/ehci-q.c' l='313' c='qh_completions'/>
<use f='linux/drivers/usb/host/ehci-q.c' l='546' c='qtd_list_free'/>
<use f='linux/drivers/usb/host/ehci-q.c' l='566' c='qh_urb_transaction'/>
<use f='linux/drivers/usb/host/ehci-q.c' l='751' c='qh_make'/>
<use f='linux/drivers/usb/host/ehci-q.c' l='1011' c='qh_append_tds'/>
<use f='linux/drivers/usb/host/ehci-q.c' l='1093' c='submit_async'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='918' c='intr_submit'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='1032' c='iso_stream_init'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='1138' c='iso_stream_find'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='1196' c='itd_sched_init'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='1250' c='itd_urb_transaction'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='1481' c='iso_stream_schedule'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='1751' c='itd_link_urb'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='1831' c='itd_complete'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='1924' c='itd_submit'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='1997' c='sitd_sched_init'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='2045' c='sitd_urb_transaction'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='2154' c='sitd_link_urb'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='2227' c='sitd_complete'/>
<use f='linux/drivers/usb/host/ehci-sched.c' l='2305' c='sitd_submit'/>
<use f='linux/drivers/usb/host/ehci-hcd.c' l='854' c='ehci_urb_enqueue'/>
<use f='linux/drivers/usb/host/ehci-hcd.c' l='893' c='ehci_urb_dequeue'/>
<size>192</size>
<use f='linux/drivers/usb/host/ohci.h' l='134'/>
<use f='linux/drivers/usb/host/ohci-q.c' l='41' c='finish_urb'/>
<use f='linux/drivers/usb/host/ohci-q.c' l='92' c='finish_urb'/>
<use f='linux/drivers/usb/host/ohci-q.c' l='92' c='finish_urb'/>
<use f='linux/drivers/usb/host/ohci-q.c' l='92' c='finish_urb'/>
<use f='linux/drivers/usb/host/ohci-q.c' l='518' c='td_fill'/>
<use f='linux/drivers/usb/host/ohci-q.c' l='593' c='td_submit_urb'/>
<use f='linux/drivers/usb/host/ohci-q.c' l='756' c='td_done'/>
<use f='linux/drivers/usb/host/ohci-q.c' l='835' c='ed_halted'/>
<use f='linux/drivers/usb/host/ohci-q.c' l='1039' c='finish_unlinks'/>
<use f='linux/drivers/usb/host/ohci-q.c' l='1152' c='takeback_td'/>
<use f='linux/drivers/usb/host/ohci-hcd.c' l='116' c='number_of_tds'/>
<use f='linux/drivers/usb/host/ohci-hcd.c' l='148' c='ohci_urb_enqueue'/>
<use f='linux/drivers/usb/host/ohci-hcd.c' l='314' c='ohci_urb_dequeue'/>
<use f='linux/drivers/usb/host/ohci-hcd.c' l='1019' c='ohci_restart'/>
<size>192</size>
<use f='linux/drivers/usb/host/uhci-hcd.h' l='483'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='72' c='uhci_add_fsbr'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='237' c='uhci_unlink_isochronous_tds'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='316' c='uhci_cleanup_queue'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='724' c='uhci_alloc_urb_priv'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='790' c='uhci_submit_control'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='916' c='uhci_submit_common'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1057' c='uhci_submit_bulk'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1074' c='uhci_submit_interrupt'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1171' c='uhci_result_common'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1255' c='uhci_submit_isochronous'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1296' c='uhci_submit_isochronous'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1370' c='uhci_result_isochronous'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1410' c='uhci_urb_enqueue'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1482' c='uhci_urb_dequeue'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1518' c='uhci_giveback_urb'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1537' c='uhci_giveback_urb'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1579' c='uhci_scan_qh'/>
<size>192</size>
<use f='linux/drivers/usb/mon/usb_mon.h' l='48'/>
<use f='linux/drivers/usb/mon/usb_mon.h' l='49'/>
<use f='linux/drivers/usb/mon/usb_mon.h' l='50'/>
<use f='linux/drivers/usb/mon/mon_bin.c' l='394' c='mon_bin_get_setup'/>
<use f='linux/drivers/usb/mon/mon_bin.c' l='404' c='mon_bin_get_data'/>
<use f='linux/drivers/usb/mon/mon_bin.c' l='448' c='mon_bin_collate_isodesc'/>
<use f='linux/drivers/usb/mon/mon_bin.c' l='466' c='mon_bin_get_isodesc'/>
<use f='linux/drivers/usb/mon/mon_bin.c' l='485' c='mon_bin_event'/>
<use f='linux/drivers/usb/mon/mon_bin.c' l='620' c='mon_bin_submit'/>
<use f='linux/drivers/usb/mon/mon_bin.c' l='626' c='mon_bin_complete'/>
<use f='linux/drivers/usb/mon/mon_bin.c' l='632' c='mon_bin_error'/>
<size>192</size>
<use f='linux/drivers/usb/mon/mon_main.c' l='81' c='mon_bus_submit'/>
<use f='linux/drivers/usb/mon/mon_main.c' l='96' c='mon_submit'/>
<use f='linux/drivers/usb/mon/mon_main.c' l='108' c='mon_bus_submit_error'/>
<use f='linux/drivers/usb/mon/mon_main.c' l='123' c='mon_submit_error'/>
<use f='linux/drivers/usb/mon/mon_main.c' l='135' c='mon_bus_complete'/>
<use f='linux/drivers/usb/mon/mon_main.c' l='150' c='mon_complete'/>
<size>192</size>
<use f='linux/drivers/usb/mon/mon_text.c' l='130' c='mon_text_get_setup'/>
<use f='linux/drivers/usb/mon/mon_text.c' l='143' c='mon_text_get_data'/>
<use f='linux/drivers/usb/mon/mon_text.c' l='191' c='mon_text_event'/>
<use f='linux/drivers/usb/mon/mon_text.c' l='257' c='mon_text_submit'/>
<use f='linux/drivers/usb/mon/mon_text.c' l='263' c='mon_text_complete'/>
<use f='linux/drivers/usb/mon/mon_text.c' l='269' c='mon_text_error'/>
<size>192</size>
<use f='linux/drivers/usb/storage/usb.h' l='130'/>
<size>192</size>
<use f='linux/drivers/usb/storage/transport.c' l='104' c='usb_stor_blocking_completion'/>
<size>192</size>
