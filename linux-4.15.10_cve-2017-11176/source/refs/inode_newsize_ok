<dec f='linux/include/linux/fs.h' l='3183' type='int inode_newsize_ok(const struct inode * , loff_t offset)'/>
<use f='linux/fs/attr.c' l='45' u='c' c='setattr_prepare'/>
<def f='linux/fs/attr.c' l='114' ll='139' type='int inode_newsize_ok(const struct inode * inode, loff_t offset)'/>
<dec f='linux/fs/attr.c' l='140' type='int inode_newsize_ok(const struct inode * , loff_t )'/>
<use f='linux/fs/attr.c' l='140' c='inode_newsize_ok'/>
<use f='linux/fs/attr.c' l='140' u='a'/>
<use f='linux/fs/attr.c' l='140' u='a'/>
<doc f='linux/fs/attr.c' l='99'>/**
 * inode_newsize_ok - may this inode be truncated to a given size
 * @inode:	the inode to be truncated
 * @offset:	the new size to assign to the inode
 * @Returns:	0 on success, -ve errno on failure
 *
 * inode_newsize_ok must be called with i_mutex held.
 *
 * inode_newsize_ok will check filesystem limits and ulimits to check that the
 * new inode size is within limits. inode_newsize_ok will also send SIGXFSZ
 * when necessary. Caller must not proceed with inode size change if failure is
 * returned. @inode must be a file (not directory), with appropriate
 * permissions to allow truncate (inode_newsize_ok does NOT check these
 * conditions).
 */</doc>
<use f='linux/fs/buffer.c' l='2333' u='c' c='generic_cont_expand_simple'/>
<use f='linux/fs/ext4/extents.c' l='4801' u='c' c='ext4_zero_range'/>
<use f='linux/fs/ext4/extents.c' l='4973' u='c' c='ext4_fallocate'/>
<use f='linux/fs/hugetlbfs/inode.c' l='569' u='c' c='hugetlbfs_fallocate'/>
<use f='linux/fs/nfs/inode.c' l='591' u='c' c='nfs_setattr'/>
<use f='linux/fs/nfs/inode.c' l='645' u='c' c='nfs_vmtruncate'/>
<use f='linux/mm/shmem.c' l='2878' u='c' c='shmem_fallocate'/>
