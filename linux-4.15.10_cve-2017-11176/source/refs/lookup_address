<dec f='linux/arch/x86/include/asm/pgtable_types.h' l='538' type='pte_t * lookup_address(unsigned long address, unsigned int * level)'/>
<doc f='linux/arch/x86/include/asm/pgtable_types.h' l='532'>/*
 * Helper function that returns the kernel pagetable entry controlling
 * the virtual address &apos;address&apos;. NULL means no pagetable entry present.
 * NOTE: the return type is pte_t but if the pmd is PSE then we return it
 * as a pte too.
 */</doc>
<use f='linux/arch/x86/mm/pageattr.c' l='210' u='c' c='cpa_flush_range'/>
<use f='linux/arch/x86/mm/pageattr.c' l='261' u='c' c='cpa_flush_array'/>
<use f='linux/arch/x86/mm/pageattr.c' l='339' u='c' c='static_protections'/>
<def f='linux/arch/x86/mm/pageattr.c' l='402' ll='405' type='pte_t * lookup_address(unsigned long address, unsigned int * level)'/>
<dec f='linux/arch/x86/mm/pageattr.c' l='406' type='pte_t * lookup_address(unsigned long , unsigned int * )'/>
<use f='linux/arch/x86/mm/pageattr.c' l='406' c='lookup_address'/>
<use f='linux/arch/x86/mm/pageattr.c' l='406' u='a'/>
<use f='linux/arch/x86/mm/pageattr.c' l='406' u='a'/>
<use f='linux/arch/x86/mm/pageattr.c' l='415' u='c' c='_lookup_address_cpa'/>
<use f='linux/arch/x86/mm/pageattr.c' l='462' u='c' c='slow_virt_to_phys'/>
<doc f='linux/arch/x86/mm/pageattr.c' l='394'>/*
 * Lookup the page table entry for a virtual address. Return a pointer
 * to the entry and the level of the mapping.
 *
 * Note: We return pud and pmd either when the entry is marked large
 * or when the present bit is not set. Otherwise we would return a
 * pointer to a nonexisting mapping.
 */</doc>
<use f='linux/arch/x86/mm/pti.c' l='255' u='c' c='pti_setup_vsyscall'/>
