<dec f='linux/include/net/sock.h' l='1000' type='int sk_wait_data(struct sock * sk, long * timeo, const struct sk_buff * skb)'/>
<def f='linux/net/core/sock.c' l='2296' ll='2307' type='int sk_wait_data(struct sock * sk, long * timeo, const struct sk_buff * skb)'/>
<dec f='linux/net/core/sock.c' l='2308' type='int sk_wait_data(struct sock * , long * , const struct sk_buff * )'/>
<use f='linux/net/core/sock.c' l='2308' c='sk_wait_data'/>
<use f='linux/net/core/sock.c' l='2308' u='a'/>
<use f='linux/net/core/sock.c' l='2308' u='a'/>
<doc f='linux/net/core/sock.c' l='2285'>/**
 * sk_wait_data - wait for data to arrive at sk_receive_queue
 * @sk:    sock to wait on
 * @timeo: for how long
 * @skb:   last skb seen on sk_receive_queue
 *
 * Now socket state including sk-&gt;sk_err is changed only under lock,
 * hence we may omit checks after joining wait queue.
 * We check receive queue before schedule() only as optimization;
 * it is very likely that release_sock() added new data.
 */</doc>
<use f='linux/net/ipv4/tcp.c' l='829' u='c' c='tcp_splice_read'/>
<use f='linux/net/ipv4/tcp.c' l='1934' u='c' c='tcp_recvmsg'/>
