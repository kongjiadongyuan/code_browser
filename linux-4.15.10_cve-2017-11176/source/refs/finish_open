<dec f='linux/include/linux/fs.h' l='2417' type='int finish_open(struct file * file, struct dentry * dentry, int (*)(struct inode *, struct file *) open, int * opened)'/>
<use f='linux/fs/namei.c' l='3463' u='c' c='do_tmpfile'/>
<use f='linux/fs/nfs/dir.c' l='1424' u='c' c='nfs_finish_open'/>
<def f='linux/fs/open.c' l='807' ll='821' type='int finish_open(struct file * file, struct dentry * dentry, int (*)(struct inode *, struct file *) open, int * opened)'/>
<dec f='linux/fs/open.c' l='822' type='int finish_open(struct file * , struct dentry * , int (*)(struct inode *, struct file *) , int * )'/>
<use f='linux/fs/open.c' l='822' c='finish_open'/>
<use f='linux/fs/open.c' l='822' u='a'/>
<use f='linux/fs/open.c' l='822' u='a'/>
<doc f='linux/fs/open.c' l='786'>/**
 * finish_open - finish opening a file
 * @file: file pointer
 * @dentry: pointer to dentry
 * @open: open callback
 * @opened: state of open
 *
 * This can be used to finish opening a file passed to i_op-&gt;atomic_open().
 *
 * If the open callback is set to NULL, then the standard f_op-&gt;open()
 * filesystem callback is substituted.
 *
 * NB: the dentry reference is _not_ consumed.  If, for example, the dentry is
 * the return value of d_splice_alias(), then the caller needs to perform dput()
 * on it after finish_open().
 *
 * On successful return @file is a fully instantiated open file.  After this, if
 * an error occurs in -&gt;atomic_open(), it needs to clean up with fput().
 *
 * Returns zero on success or -errno if the open failed.
 */</doc>
