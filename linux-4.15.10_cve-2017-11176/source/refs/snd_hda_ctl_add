<dec f='linux/sound/pci/hda/hda_local.h' l='553' type='int snd_hda_ctl_add(struct hda_codec * codec, hda_nid_t nid, struct snd_kcontrol * kctl)'/>
<def f='linux/sound/pci/hda/hda_codec.c' l='1614' ll='1640' type='int snd_hda_ctl_add(struct hda_codec * codec, hda_nid_t nid, struct snd_kcontrol * kctl)'/>
<dec f='linux/sound/pci/hda/hda_codec.c' l='1641' type='int snd_hda_ctl_add(struct hda_codec * , hda_nid_t , struct snd_kcontrol * )'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='1641' c='snd_hda_ctl_add'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='1641' u='a'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='1641' u='a'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='1924' u='c' c='__snd_hda_add_vmaster'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2030' u='c' c='snd_hda_add_vmaster_hook'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2441' u='c' c='snd_hda_create_dig_out_ctls'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2561' u='c' c='snd_hda_create_spdif_share_sw'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2662' u='c' c='snd_hda_create_spdif_in_ctls'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='3278' u='c' c='snd_hda_add_new_ctls'/>
<doc f='linux/sound/pci/hda/hda_codec.c' l='1595'>/**
 * snd_hda_ctl_add - Add a control element and assign to the codec
 * @codec: HD-audio codec
 * @nid: corresponding NID (optional)
 * @kctl: the control element to assign
 *
 * Add the given control element to an array inside the codec instance.
 * All control elements belonging to a codec are supposed to be added
 * by this function so that a proper clean-up works at the free or
 * reconfiguration time.
 *
 * If non-zero @nid is passed, the NID is assigned to the control element.
 * The assignment is shown in the codec proc file.
 *
 * snd_hda_ctl_add() checks the control subdev id field whether
 * #HDA_SUBDEV_NID_FLAG bit is set.  If set (and @nid is zero), the lower
 * bits value is taken as the NID to assign. The #HDA_NID_ITEM_AMP bit
 * specifies if kctl-&gt;private_value is a HDA amplifier value.
 */</doc>
