<dec f='linux/drivers/gpu/drm/i915/i915_vma.h' l='367' type='int i915_vma_pin_fence(struct i915_vma * vma)'/>
<doc f='linux/drivers/gpu/drm/i915/i915_vma.h' l='352'>/**
 * i915_vma_pin_fence - pin fencing state
 * @vma: vma to pin fencing for
 *
 * This pins the fencing state (whether tiled or untiled) to make sure the
 * vma (and its object) is ready to be used as a scanout target. Fencing
 * status must be synchronize first by calling i915_vma_get_fence():
 *
 * The resulting fence pin reference must be released again with
 * i915_vma_unpin_fence().
 *
 * Returns:
 *
 * True if the vma has a fence, false otherwise.
 */</doc>
<use f='linux/drivers/gpu/drm/i915/i915_gem.c' l='1932' u='c' c='i915_gem_fault'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_execbuffer.c' l='374' u='c' c='eb_pin_vma'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_execbuffer.c' l='572' u='c' c='eb_reserve_vma'/>
<def f='linux/drivers/gpu/drm/i915/i915_gem_fence_reg.c' l='335' ll='380' type='int i915_vma_pin_fence(struct i915_vma * vma)'/>
<doc f='linux/drivers/gpu/drm/i915/i915_gem_fence_reg.c' l='317'>/**
 * i915_vma_pin_fence - set up fencing for a vma
 * @vma: vma to map through a fence reg
 *
 * When mapping objects through the GTT, userspace wants to be able to write
 * to them without having to worry about swizzling if the object is tiled.
 * This function walks the fence regs looking for a free one for @obj,
 * stealing one if it can&apos;t find any.
 *
 * It then sets up the reg based on the object&apos;s properties: address, pitch
 * and tiling format.
 *
 * For an untiled surface, this removes any existing fence.
 *
 * Returns:
 *
 * 0 on success, negative error code on failure.
 */</doc>
<use f='linux/drivers/gpu/drm/i915/i915_vma.c' l='321' u='c' c='i915_vma_pin_iomap'/>
<use f='linux/drivers/gpu/drm/i915/intel_display.c' l='2159' u='c' c='intel_pin_and_fence_fb_obj'/>
