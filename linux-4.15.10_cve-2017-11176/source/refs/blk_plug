<use f='linux/include/linux/sched.h' l='864'/>
<def f='linux/include/linux/blkdev.h' l='1285' ll='1289'/>
<use f='linux/include/linux/blkdev.h' l='1302' c='blk_start_plug'/>
<use f='linux/include/linux/blkdev.h' l='1303' c='blk_finish_plug'/>
<use f='linux/include/linux/blkdev.h' l='1304' c='blk_flush_plug_list'/>
<use f='linux/include/linux/blkdev.h' l='1308' c='blk_flush_plug'/>
<use f='linux/include/linux/blkdev.h' l='1316' c='blk_schedule_flush_plug'/>
<use f='linux/include/linux/blkdev.h' l='1324' c='blk_needs_flush_plug'/>
<use f='linux/include/linux/blk-mq.h' l='207' c='blk_mq_flush_plug_list'/>
<size>48</size>
<doc f='linux/include/linux/blkdev.h' l='1273'>/*
 * blk_plug permits building a queue of related requests by holding the I/O
 * fragments for a short period. This allows merging of sequential requests
 * into single larger request. As the requests are moved from a per-task list to
 * the device&apos;s request_queue in a batch, this results in improved scalability
 * as the lock contention for request_queue lock is reduced.
 *
 * It is ok not to disable preemption when adding the request to the plug list
 * or when attempting a merge, because blk_schedule_flush_list() will only flush
 * the plug list when the task sleeps by itself. For details, please see
 * schedule() where blk_schedule_flush_plug() is called.
 */</doc>
<mbr r='blk_plug::list' o='0' t='struct list_head'/>
<mbr r='blk_plug::mq_list' o='128' t='struct list_head'/>
<mbr r='blk_plug::cb_list' o='256' t='struct list_head'/>
<use f='linux/block/blk-core.c' l='1798' c='blk_attempt_plug_merge'/>
<use f='linux/block/blk-core.c' l='1852' c='blk_plug_queued_count'/>
<use f='linux/block/blk-core.c' l='1895' c='blk_queue_bio'/>
<use f='linux/block/blk-core.c' l='3455' c='blk_start_plug'/>
<use f='linux/block/blk-core.c' l='3506' c='flush_plug_callbacks'/>
<use f='linux/block/blk-core.c' l='3526' c='blk_check_plugged'/>
<use f='linux/block/blk-core.c' l='3548' c='blk_flush_plug_list'/>
<use f='linux/block/blk-core.c' l='3619' c='blk_finish_plug'/>
<size>48</size>
<use f='linux/block/blk-lib.c' l='117' c='blkdev_issue_discard'/>
<use f='linux/block/blk-lib.c' l='210' c='blkdev_issue_write_same'/>
<use f='linux/block/blk-lib.c' l='371' c='blkdev_issue_zeroout'/>
<size>48</size>
<use f='linux/block/blk-mq.c' l='1525' c='blk_mq_flush_plug_list'/>
<use f='linux/block/blk-mq.c' l='1680' c='blk_mq_make_request'/>
<size>48</size>
<use f='linux/drivers/md/dm-kcopyd.c' l='622' c='do_work'/>
<size>48</size>
<use f='linux/drivers/md/dm.c' l='1123'/>
<size>48</size>
<use f='linux/drivers/md/md.c' l='8168' c='md_do_sync'/>
<size>48</size>
<use f='linux/fs/aio.c' l='1645' c='do_io_submit'/>
<size>48</size>
<use f='linux/fs/block_dev.c' l='325' c='__blkdev_direct_IO'/>
<use f='linux/fs/block_dev.c' l='1875' c='blkdev_write_iter'/>
<size>48</size>
<use f='linux/fs/buffer.c' l='707' c='fsync_buffers_list'/>
<size>48</size>
<use f='linux/fs/direct-io.c' l='1165' c='do_blockdev_direct_IO'/>
<size>48</size>
<use f='linux/fs/ext4/inode.c' l='2718' c='ext4_writepages'/>
<use f='linux/fs/ext4/inode.c' l='2742' c='ext4_writepages'/>
<size>48</size>
<use f='linux/fs/fs-writeback.c' l='1679' c='writeback_inodes_wb'/>
<use f='linux/fs/fs-writeback.c' l='1715' c='wb_writeback'/>
<size>48</size>
<use f='linux/fs/iomap.c' l='971' c='iomap_dio_rw'/>
<size>48</size>
<use f='linux/fs/jbd2/checkpoint.c' l='185' c='__flush_batch'/>
<size>48</size>
<use f='linux/fs/jbd2/commit.c' l='368' c='jbd2_journal_commit_transaction'/>
<size>48</size>
<use f='linux/fs/mpage.c' l='701' c='mpage_writepages'/>
<size>48</size>
<use f='linux/mm/madvise.c' l='799' c='SYSC_madvise'/>
<size>48</size>
<use f='linux/mm/page-writeback.c' l='2317' c='generic_writepages'/>
<size>48</size>
<use f='linux/mm/readahead.c' l='114' c='read_pages'/>
<size>48</size>
<use f='linux/mm/swap_state.c' l='563' c='swapin_readahead'/>
<use f='linux/mm/swap_state.c' l='724' c='do_swap_page_readahead'/>
<size>48</size>
<use f='linux/mm/vmscan.c' l='2394' c='shrink_node_memcg'/>
<size>48</size>
