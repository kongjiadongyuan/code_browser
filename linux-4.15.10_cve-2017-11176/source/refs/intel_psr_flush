<dec f='linux/drivers/gpu/drm/i915/intel_drv.h' l='1757' type='void intel_psr_flush(struct drm_i915_private * dev_priv, unsigned int frontbuffer_bits, enum fb_op_origin origin)'/>
<use f='linux/drivers/gpu/drm/i915/intel_frontbuffer.c' l='112' u='c' c='intel_frontbuffer_flush'/>
<def f='linux/drivers/gpu/drm/i915/intel_psr.c' l='882' ll='912' type='void intel_psr_flush(struct drm_i915_private * dev_priv, unsigned int frontbuffer_bits, enum fb_op_origin origin)'/>
<doc f='linux/drivers/gpu/drm/i915/intel_psr.c' l='869'>/**
 * intel_psr_flush - Flush PSR
 * @dev_priv: i915 device
 * @frontbuffer_bits: frontbuffer plane tracking bits
 * @origin: which operation caused the flush
 *
 * Since the hardware frontbuffer tracking has gaps we need to integrate
 * with the software frontbuffer tracking. This function gets called every
 * time frontbuffer rendering has completed and flushed out to memory. PSR
 * can be enabled again if no other frontbuffer relevant to PSR is dirty.
 *
 * Dirty frontbuffers relevant to PSR are tracked in busy_frontbuffer_bits.
 */</doc>
