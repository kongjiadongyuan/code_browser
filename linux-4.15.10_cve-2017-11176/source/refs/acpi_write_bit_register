<dec f='linux/include/acpi/acpixf.h' l='869' type='acpi_status acpi_write_bit_register(u32 register_id, u32 value)'/>
<use f='linux/drivers/acpi/acpica/evevent.c' l='177' u='c' c='acpi_ev_fixed_event_initialize'/>
<use f='linux/drivers/acpi/acpica/evevent.c' l='272' u='c' c='acpi_ev_fixed_event_dispatch'/>
<use f='linux/drivers/acpi/acpica/evevent.c' l='280' u='c' c='acpi_ev_fixed_event_dispatch'/>
<use f='linux/drivers/acpi/acpica/evglock.c' l='327' u='c' c='acpi_ev_release_global_lock'/>
<use f='linux/drivers/acpi/acpica/evxfevnt.c' l='200' u='c' c='acpi_enable_event'/>
<use f='linux/drivers/acpi/acpica/evxfevnt.c' l='263' u='c' c='acpi_disable_event'/>
<use f='linux/drivers/acpi/acpica/evxfevnt.c' l='322' u='c' c='acpi_clear_event'/>
<use f='linux/drivers/acpi/acpica/hwsleep.c' l='82' u='c' c='acpi_hw_legacy_sleep'/>
<use f='linux/drivers/acpi/acpica/hwsleep.c' l='326' u='c' c='acpi_hw_legacy_wake'/>
<use f='linux/drivers/acpi/acpica/hwsleep.c' l='333' u='c' c='acpi_hw_legacy_wake'/>
<use f='linux/drivers/acpi/acpica/hwsleep.c' l='338' u='c' c='acpi_hw_legacy_wake'/>
<def f='linux/drivers/acpi/acpica/hwxface.c' l='248' ll='327' type='acpi_status acpi_write_bit_register(u32 register_id, u32 value)'/>
<dec f='linux/drivers/acpi/acpica/hwxface.c' l='329' type='acpi_status acpi_write_bit_register(u32 , u32 )'/>
<use f='linux/drivers/acpi/acpica/hwxface.c' l='329' c='acpi_write_bit_register'/>
<use f='linux/drivers/acpi/acpica/hwxface.c' l='329' u='a'/>
<use f='linux/drivers/acpi/acpica/hwxface.c' l='329' u='a'/>
<doc f='linux/drivers/acpi/acpica/hwxface.c' l='227'>/*******************************************************************************
 *
 * FUNCTION:    acpi_write_bit_register
 *
 * PARAMETERS:  register_id     - ID of ACPI Bit Register to access
 *              value           - Value to write to the register, in bit
 *                                position zero. The bit is automatically
 *                                shifted to the correct position.
 *
 * RETURN:      Status
 *
 * DESCRIPTION: ACPI Bit Register write function. Acquires the hardware lock
 *              since most operations require a read/modify/write sequence.
 *
 * SUPPORTS:    Bit fields in PM1 Status, PM1 Enable, PM1 Control, and
 *              PM2 Control.
 *
 * Note that at this level, the fact that there may be actually two
 * hardware registers (A and B - and B may not exist) is abstracted.
 *
 ******************************************************************************/</doc>
<use f='linux/drivers/acpi/acpica/hwxfsleep.c' l='201' u='c' c='acpi_enter_sleep_state_s4bios'/>
<use f='linux/drivers/acpi/processor_idle.c' l='538' u='c' c='acpi_processor_power_verify_c3'/>
<use f='linux/drivers/acpi/processor_idle.c' l='631' u='c' c='acpi_idle_bm_check'/>
<use f='linux/drivers/acpi/processor_idle.c' l='736' u='c' c='acpi_idle_enter_bm'/>
<use f='linux/drivers/acpi/processor_idle.c' l='745' u='c' c='acpi_idle_enter_bm'/>
<use f='linux/drivers/acpi/sleep.c' l='581' u='c' c='acpi_suspend_enter'/>
<use f='linux/drivers/acpi/sleep.c' l='1067' u='c' c='acpi_restore_bm_rld'/>
