<dec f='linux/fs/internal.h' l='182' type='loff_t iomap_apply(struct inode * inode, loff_t pos, loff_t length, unsigned int flags, const struct iomap_ops * ops, void * data, iomap_actor_t actor)'/>
<def f='linux/fs/iomap.c' l='44' ll='94' type='loff_t iomap_apply(struct inode * inode, loff_t pos, loff_t length, unsigned int flags, const struct iomap_ops * ops, void * data, iomap_actor_t actor)'/>
<use f='linux/fs/iomap.c' l='240' u='c' c='iomap_file_buffered_write'/>
<use f='linux/fs/iomap.c' l='321' u='c' c='iomap_file_dirty'/>
<use f='linux/fs/iomap.c' l='402' u='c' c='iomap_zero_range'/>
<use f='linux/fs/iomap.c' l='469' u='c' c='iomap_page_mkwrite'/>
<use f='linux/fs/iomap.c' l='564' u='c' c='iomap_fiemap'/>
<use f='linux/fs/iomap.c' l='619' u='c' c='iomap_seek_hole'/>
<use f='linux/fs/iomap.c' l='665' u='c' c='iomap_seek_data'/>
<use f='linux/fs/iomap.c' l='1037' u='c' c='iomap_dio_rw'/>
<doc f='linux/fs/iomap.c' l='33'>/*
 * Execute a iomap write on a segment of the mapping that spans a
 * contiguous range of pages that have identical block mapping state.
 *
 * This avoids the need to map pages individually, do individual allocations
 * for each page and most importantly avoid the need for filesystem specific
 * locking per page. Instead, all the operations are amortised over the entire
 * range of pages. It is assumed that the filesystems will lock whatever
 * resources they require in the iomap_begin call, and release them in the
 * iomap_end call.
 */</doc>
