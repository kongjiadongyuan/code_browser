<dec f='linux/arch/x86/include/asm/traps.h' l='85' type='void do_machine_check(struct pt_regs * , long )'/>
<dec f='linux/arch/x86/include/asm/mce.h' l='297' type='void do_machine_check(struct pt_regs * , long )'/>
<def f='linux/arch/x86/kernel/cpu/mcheck/mce.c' l='1119' ll='1334' type='void do_machine_check(struct pt_regs * regs, long error_code)'/>
<dec f='linux/arch/x86/kernel/cpu/mcheck/mce.c' l='1335' type='void do_machine_check(struct pt_regs * , long )'/>
<use f='linux/arch/x86/kernel/cpu/mcheck/mce.c' l='1335' c='do_machine_check'/>
<use f='linux/arch/x86/kernel/cpu/mcheck/mce.c' l='1335' u='a'/>
<use f='linux/arch/x86/kernel/cpu/mcheck/mce.c' l='1335' u='a'/>
<use f='linux/arch/x86/kernel/cpu/mcheck/mce.c' l='1829' u='r' c='mcheck_cpu_init'/>
<doc f='linux/arch/x86/kernel/cpu/mcheck/mce.c' l='1107'>/*
 * The actual machine check handler. This only handles real
 * exceptions when something got corrupted coming in through int 18.
 *
 * This is executed in NMI context not subject to normal locking rules. This
 * implies that most kernel services cannot be safely used. Don&apos;t even
 * think about putting a printk in there!
 *
 * On Intel systems this is entered on all CPUs in parallel through
 * MCE broadcast. However some CPUs might be broken beyond repair,
 * so be always careful when synchronizing with others.
 */</doc>
