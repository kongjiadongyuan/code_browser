<dec f='linux/include/linux/pm_runtime.h' l='45' type='int pm_runtime_barrier(struct device * dev)'/>
<use f='linux/drivers/base/core.c' l='2800' u='c' c='device_shutdown'/>
<use f='linux/drivers/base/dd.c' l='565' u='c' c='driver_probe_device'/>
<use f='linux/drivers/base/power/main.c' l='1481' u='c' c='__device_suspend'/>
<def f='linux/drivers/base/power/runtime.c' l='1209' ll='1228' type='int pm_runtime_barrier(struct device * dev)'/>
<dec f='linux/drivers/base/power/runtime.c' l='1229' type='int pm_runtime_barrier(struct device * )'/>
<use f='linux/drivers/base/power/runtime.c' l='1229' c='pm_runtime_barrier'/>
<use f='linux/drivers/base/power/runtime.c' l='1229' u='a'/>
<use f='linux/drivers/base/power/runtime.c' l='1229' u='a'/>
<doc f='linux/drivers/base/power/runtime.c' l='1195'>/**
 * pm_runtime_barrier - Flush pending requests and wait for completions.
 * @dev: Device to handle.
 *
 * Prevent the device from being suspended by incrementing its usage counter and
 * if there&apos;s a pending resume request for the device, wake the device up.
 * Next, make sure that all pending requests for the device have been flushed
 * from pm_wq and wait for all runtime PM operations involving the device in
 * progress to complete.
 *
 * Return value:
 * 1, if there was a resume request pending and the device had to be woken up,
 * 0, otherwise
 */</doc>
<use f='linux/drivers/pci/pci.c' l='2227' u='c' c='pci_config_pm_runtime_get'/>
<use f='linux/drivers/usb/core/hub.c' l='1272' u='c' c='hub_pm_barrier_for_all_ports'/>
<use f='linux/drivers/usb/core/hub.c' l='2113' u='c' c='usb_disconnect'/>
<use f='linux/drivers/usb/core/hub.c' l='5218' u='c' c='hub_event'/>
