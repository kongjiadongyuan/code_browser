<def f='linux/include/linux/wait_bit.h' l='78' ll='87' type='int wait_on_bit(unsigned long * word, int bit, unsigned int mode)'/>
<use f='linux/include/linux/writeback.h' l='178' u='c' c='wait_on_inode'/>
<doc f='linux/include/linux/wait_bit.h' l='62'>/**
 * wait_on_bit - wait for a bit to be cleared
 * @word: the word being waited on, a kernel virtual address
 * @bit: the bit of the word being waited on
 * @mode: the task state to sleep in
 *
 * There is a standard hashed waitqueue table for generic use. This
 * is the part of the hashtable&apos;s accessor API that waits on a bit.
 * For instance, if one were to have waiters on a bitflag, one would
 * call wait_on_bit() in threads waiting for the bit to clear.
 * One uses wait_on_bit() where one is waiting for the bit to clear,
 * but has no intention of setting it.
 * Returned value will be zero if the bit was cleared, or non-zero
 * if the process received a signal and the mode permitted wakeup
 * on that signal.
 */</doc>
<use f='linux/drivers/gpu/drm/i915/i915_debugfs.c' l='4095' u='c' c='i915_wedged_set'/>
<use f='linux/drivers/gpu/drm/i915/i915_irq.c' l='2897' u='c' c='i915_handle_error'/>
<use f='linux/drivers/md/dm.c' l='2454' u='c' c='dm_suspend'/>
<use f='linux/drivers/md/dm.c' l='2511' u='c' c='dm_resume'/>
<use f='linux/kernel/ptrace.c' l='440' u='c' c='ptrace_attach'/>
<use f='linux/mm/backing-dev.c' l='377' u='c' c='wb_shutdown'/>
<use f='linux/net/sunrpc/xprt.c' l='884' u='c' c='xprt_wait_on_pinned_rqst'/>
<use f='linux/security/keys/gc.c' l='117' u='c' c='key_gc_keytype'/>
<use f='linux/security/keys/request_key.c' l='620' u='c' c='wait_for_key_construction'/>
