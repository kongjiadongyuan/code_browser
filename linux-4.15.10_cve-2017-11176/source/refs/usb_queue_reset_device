<dec f='linux/include/linux/usb.h' l='727' type='void usb_queue_reset_device(struct usb_interface * dev)'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='137' u='c' c='hid_reset'/>
<def f='linux/drivers/usb/core/hub.c' l='5741' ll='5745' type='void usb_queue_reset_device(struct usb_interface * iface)'/>
<dec f='linux/drivers/usb/core/hub.c' l='5746' type='void usb_queue_reset_device(struct usb_interface * )'/>
<use f='linux/drivers/usb/core/hub.c' l='5746' c='usb_queue_reset_device'/>
<use f='linux/drivers/usb/core/hub.c' l='5746' u='a'/>
<use f='linux/drivers/usb/core/hub.c' l='5746' u='a'/>
<doc f='linux/drivers/usb/core/hub.c' l='5713'>/**
 * usb_queue_reset_device - Reset a USB device from an atomic context
 * @iface: USB interface belonging to the device to reset
 *
 * This function can be used to reset a USB device from an atomic
 * context, where usb_reset_device() won&apos;t work (as it blocks).
 *
 * Doing a reset via this method is functionally equivalent to calling
 * usb_reset_device(), except for the fact that it is delayed to a
 * workqueue. This means that any drivers bound to other interfaces
 * might be unbound, as well as users from usbfs in user space.
 *
 * Corner cases:
 *
 * - Scheduling two resets at the same time from two different drivers
 *   attached to two different interfaces of the same device is
 *   possible; depending on how the driver attached to each interface
 *   handles -&gt;pre_reset(), the second reset might happen or not.
 *
 * - If the reset is delayed so long that the interface is unbound from
 *   its driver, the reset will be skipped.
 *
 * - This function can be called during .probe().  It can also be called
 *   during .disconnect(), but doing so is pointless because the reset
 *   will not occur.  If you really want to reset the device during
 *   .disconnect(), call usb_reset_device() directly -- but watch out
 *   for nested unbinding issues!
 */</doc>
