<dec f='linux/include/linux/regmap.h' l='855' type='int regmap_multi_reg_write_bypassed(struct regmap * map, const struct reg_sequence * regs, int num_regs)'/>
<def f='linux/drivers/base/regmap/regmap.c' l='2312' ll='2331' type='int regmap_multi_reg_write_bypassed(struct regmap * map, const struct reg_sequence * regs, int num_regs)'/>
<dec f='linux/drivers/base/regmap/regmap.c' l='2332' type='int regmap_multi_reg_write_bypassed(struct regmap * , const struct reg_sequence * , int )'/>
<use f='linux/drivers/base/regmap/regmap.c' l='2332' c='regmap_multi_reg_write_bypassed'/>
<use f='linux/drivers/base/regmap/regmap.c' l='2332' u='a'/>
<use f='linux/drivers/base/regmap/regmap.c' l='2332' u='a'/>
<doc f='linux/drivers/base/regmap/regmap.c' l='2294'>/**
 * regmap_multi_reg_write_bypassed() - Write multiple registers to the
 *                                     device but not the cache
 *
 * @map: Register map to write to
 * @regs: Array of structures containing register,value to be written
 * @num_regs: Number of registers to write
 *
 * Write multiple registers to the device but not the cache where the set
 * of register are supplied in any order.
 *
 * This function is intended to be used for writing a large block of data
 * atomically to the device in single transfer for those I2C client devices
 * that implement this alternative block write mode.
 *
 * A value of zero will be returned on success, a negative errno will
 * be returned in error cases.
 */</doc>
