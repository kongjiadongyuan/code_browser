<dec f='linux/include/linux/skbuff.h' l='1999' type='void * pskb_put(struct sk_buff * skb, struct sk_buff * tail, int len)'/>
<doc f='linux/include/linux/skbuff.h' l='1996'>/*
 *	Add data to an sk_buff
 */</doc>
<def f='linux/net/core/skbuff.c' l='1669' ll='1676' type='void * pskb_put(struct sk_buff * skb, struct sk_buff * tail, int len)'/>
<dec f='linux/net/core/skbuff.c' l='1677' type='void * pskb_put(struct sk_buff * , struct sk_buff * , int )'/>
<use f='linux/net/core/skbuff.c' l='1677' c='pskb_put'/>
<use f='linux/net/core/skbuff.c' l='1677' u='a'/>
<use f='linux/net/core/skbuff.c' l='1677' u='a'/>
<doc f='linux/net/core/skbuff.c' l='1656'>/**
 *	pskb_put - add data to the tail of a potentially fragmented buffer
 *	@skb: start of the buffer to use
 *	@tail: tail fragment of the buffer to use
 *	@len: amount of data to add
 *
 *	This function extends the used data area of the potentially
 *	fragmented buffer. @tail must be the last fragment of @skb -- or
 *	@skb itself. If this would exceed the total buffer size the kernel
 *	will panic. A pointer to the first byte of the extra data is
 *	returned.
 */</doc>
<use f='linux/net/ipv6/esp6.c' l='293' u='c' c='esp6_output_head'/>
