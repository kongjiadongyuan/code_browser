<dec f='linux/include/linux/skbuff.h' l='1049' type='int skb_cow_data(struct sk_buff * skb, int tailbits, struct sk_buff ** trailer)'/>
<def f='linux/net/core/skbuff.c' l='4047' ll='4137' type='int skb_cow_data(struct sk_buff * skb, int tailbits, struct sk_buff ** trailer)'/>
<dec f='linux/net/core/skbuff.c' l='4138' type='int skb_cow_data(struct sk_buff * , int , struct sk_buff ** )'/>
<use f='linux/net/core/skbuff.c' l='4138' c='skb_cow_data'/>
<use f='linux/net/core/skbuff.c' l='4138' u='a'/>
<use f='linux/net/core/skbuff.c' l='4138' u='a'/>
<doc f='linux/net/core/skbuff.c' l='4030'>/**
 *	skb_cow_data - Check that a socket buffer&apos;s data buffers are writable
 *	@skb: The socket buffer to check.
 *	@tailbits: Amount of trailing space to be added
 *	@trailer: Returned pointer to the skb where the @tailbits space begins
 *
 *	Make sure that the data buffers attached to a socket buffer are
 *	writable. If they are not, private copies are made of the data buffers
 *	and the socket buffer is set to use these instead.
 *
 *	If @tailbits is given, make sure that there is space to write @tailbits
 *	bytes of data beyond current end of socket buffer.  @trailer will be
 *	set to point to the skb in which this space begins.
 *
 *	The number of scatterlist elements required to completely map the
 *	COW&apos;d and extended socket buffer will be returned.
 */</doc>
<use f='linux/net/ipv6/ah6.c' l='358' u='c' c='ah6_output'/>
<use f='linux/net/ipv6/ah6.c' l='570' u='c' c='ah6_input'/>
<use f='linux/net/ipv6/esp6.c' l='286' u='c' c='esp6_output_head'/>
<use f='linux/net/ipv6/esp6.c' l='632' u='c' c='esp6_input'/>
