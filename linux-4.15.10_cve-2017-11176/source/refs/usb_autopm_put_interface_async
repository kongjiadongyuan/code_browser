<dec f='linux/include/linux/usb.h' l='748' type='void usb_autopm_put_interface_async(struct usb_interface * intf)'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='220' u='c' c='usbhid_restart_out_queue'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='259' u='c' c='usbhid_restart_ctrl_queue'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='467' u='c' c='hid_irq_out'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='517' u='c' c='hid_ctrl'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='575' u='c' c='__usbhid_submit_report'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='626' u='c' c='__usbhid_submit_report'/>
<def f='linux/drivers/usb/core/driver.c' l='1662' ll='1673' type='void usb_autopm_put_interface_async(struct usb_interface * intf)'/>
<dec f='linux/drivers/usb/core/driver.c' l='1674' type='void usb_autopm_put_interface_async(struct usb_interface * )'/>
<use f='linux/drivers/usb/core/driver.c' l='1674' c='usb_autopm_put_interface_async'/>
<use f='linux/drivers/usb/core/driver.c' l='1674' u='a'/>
<use f='linux/drivers/usb/core/driver.c' l='1674' u='a'/>
<doc f='linux/drivers/usb/core/driver.c' l='1647'>/**
 * usb_autopm_put_interface_async - decrement a USB interface&apos;s PM-usage counter
 * @intf: the usb_interface whose counter should be decremented
 *
 * This routine does much the same thing as usb_autopm_put_interface():
 * It decrements @intf&apos;s usage counter and schedules a delayed
 * autosuspend request if the counter is &lt;= 0.  The difference is that it
 * does not perform any synchronization; callers should hold a private
 * lock and handle all synchronization issues themselves.
 *
 * Typically a driver would call this routine during an URB&apos;s completion
 * handler, if no more URBs were pending.
 *
 * This routine can run in atomic context.
 */</doc>
<use f='linux/drivers/usb/core/hub.c' l='629' u='c' c='kick_hub_wq'/>
<use f='linux/drivers/usb/core/hub.c' l='1217' u='c' c='hub_activate'/>
