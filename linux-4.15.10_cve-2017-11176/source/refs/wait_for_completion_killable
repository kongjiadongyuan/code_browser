<dec f='linux/include/linux/completion.h' l='106' type='int wait_for_completion_killable(struct completion * x)'/>
<use f='linux/crypto/algapi.c' l='359' u='c' c='crypto_wait_for_test'/>
<use f='linux/fs/nfs/direct.c' l='358' u='c' c='nfs_direct_wait'/>
<use f='linux/kernel/fork.c' l='1102' u='c' c='wait_for_vfork_done'/>
<use f='linux/kernel/kthread.c' l='303' u='c' c='__kthread_create_on_node'/>
<def f='linux/kernel/sched/completion.c' l='242' ll='248' type='int wait_for_completion_killable(struct completion * x)'/>
<dec f='linux/kernel/sched/completion.c' l='249' type='int wait_for_completion_killable(struct completion * )'/>
<use f='linux/kernel/sched/completion.c' l='249' c='wait_for_completion_killable'/>
<use f='linux/kernel/sched/completion.c' l='249' u='a'/>
<use f='linux/kernel/sched/completion.c' l='249' u='a'/>
<doc f='linux/kernel/sched/completion.c' l='233'>/**
 * wait_for_completion_killable: - waits for completion of a task (killable)
 * @x:  holds the state of this particular completion
 *
 * This waits to be signaled for completion of a specific task. It can be
 * interrupted by a kill signal.
 *
 * Return: -ERESTARTSYS if interrupted, 0 if completed.
 */</doc>
<use f='linux/kernel/umh.c' l='444' u='c' c='call_usermodehelper_exec'/>
