<dec f='linux/include/linux/relay.h' l='169' type='struct rchan * relay_open(const char * base_filename, struct dentry * parent, size_t subbuf_size, size_t n_subbufs, struct rchan_callbacks * cb, void * private_data)'/>
<doc f='linux/include/linux/relay.h' l='165'>/*
 * CONFIG_RELAY kernel API, kernel/relay.c
 */</doc>
<use f='linux/drivers/gpu/drm/i915/intel_guc_log.c' l='401' u='c' c='guc_log_runtime_create'/>
<def f='linux/kernel/relay.c' l='560' ll='615' type='struct rchan * relay_open(const char * base_filename, struct dentry * parent, size_t subbuf_size, size_t n_subbufs, struct rchan_callbacks * cb, void * private_data)'/>
<dec f='linux/kernel/relay.c' l='616' type='struct rchan * relay_open(const char * , struct dentry * , size_t , size_t , struct rchan_callbacks * , void * )'/>
<use f='linux/kernel/relay.c' l='616' c='relay_open'/>
<use f='linux/kernel/relay.c' l='616' u='a'/>
<use f='linux/kernel/relay.c' l='616' u='a'/>
<doc f='linux/kernel/relay.c' l='540'>/**
 *	relay_open - create a new relay channel
 *	@base_filename: base name of files to create, %NULL for buffering only
 *	@parent: dentry of parent directory, %NULL for root directory or buffer
 *	@subbuf_size: size of sub-buffers
 *	@n_subbufs: number of sub-buffers
 *	@cb: client callback functions
 *	@private_data: user-defined data
 *
 *	Returns channel pointer if successful, %NULL otherwise.
 *
 *	Creates a channel buffer for each cpu using the sizes and
 *	attributes specified.  The created channel buffer files
 *	will be named base_filename0...base_filenameN-1.  File
 *	permissions will be %S_IRUSR.
 *
 *	If opening a buffer (@parent = NULL) that you later wish to register
 *	in a filesystem, call relay_late_setup_files() once the @parent dentry
 *	is available.
 */</doc>
<use f='linux/kernel/trace/blktrace.c' l='544' u='c' c='do_blk_trace_setup'/>
