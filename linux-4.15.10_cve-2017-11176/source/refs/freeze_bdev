<dec f='linux/include/linux/fs.h' l='2448' type='struct super_block * freeze_bdev(struct block_device * )'/>
<use f='linux/drivers/md/dm.c' l='2295' u='c' c='lock_fs'/>
<def f='linux/fs/block_dev.c' l='490' ll='527' type='struct super_block * freeze_bdev(struct block_device * bdev)'/>
<dec f='linux/fs/block_dev.c' l='528' type='struct super_block * freeze_bdev(struct block_device * )'/>
<use f='linux/fs/block_dev.c' l='528' c='freeze_bdev'/>
<use f='linux/fs/block_dev.c' l='528' u='a'/>
<use f='linux/fs/block_dev.c' l='528' u='a'/>
<doc f='linux/fs/block_dev.c' l='478'>/**
 * freeze_bdev  --  lock a filesystem and force it into a consistent state
 * @bdev:	blockdevice to lock
 *
 * If a superblock is found on this device, we take the s_umount semaphore
 * on it to make sure nobody unmounts until the snapshot creation is done.
 * The reference counter (bd_fsfreeze_count) guarantees that only the last
 * unfreeze process can unfreeze the frozen filesystem actually when multiple
 * freeze requests arrive simultaneously. It counts up in freeze_bdev() and
 * count down in thaw_bdev(). When it becomes 0, thaw_bdev() will unfreeze
 * actually.
 */</doc>
<use f='linux/fs/ext4/ioctl.c' l='486' u='c' c='ext4_shutdown'/>
