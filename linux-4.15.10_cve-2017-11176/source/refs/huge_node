<dec f='linux/include/linux/mempolicy.h' l='149' type='int huge_node(struct vm_area_struct * vma, unsigned long addr, gfp_t gfp_flags, struct mempolicy ** mpol, nodemask_t ** nodemask)'/>
<use f='linux/mm/hugetlb.c' l='960' u='c' c='dequeue_huge_page_vma'/>
<use f='linux/mm/hugetlb.c' l='1618' u='c' c='__alloc_buddy_huge_page_with_mpol'/>
<def f='linux/mm/mempolicy.c' l='1797' ll='1814' type='int huge_node(struct vm_area_struct * vma, unsigned long addr, gfp_t gfp_flags, struct mempolicy ** mpol, nodemask_t ** nodemask)'/>
<doc f='linux/mm/mempolicy.c' l='1782'>/*
 * huge_node(@vma, @addr, @gfp_flags, @mpol)
 * @vma: virtual memory area whose policy is sought
 * @addr: address in @vma for shared policy lookup and interleave policy
 * @gfp_flags: for requested zone
 * @mpol: pointer to mempolicy pointer for reference counted mempolicy
 * @nodemask: pointer to nodemask pointer for MPOL_BIND nodemask
 *
 * Returns a nid suitable for a huge page allocation and a pointer
 * to the struct mempolicy for conditional unref after allocation.
 * If the effective policy is &apos;BIND, returns a pointer to the mempolicy&apos;s
 * @nodemask for filtering the zonelist.
 *
 * Must be protected by read_mems_allowed_begin()
 */</doc>
