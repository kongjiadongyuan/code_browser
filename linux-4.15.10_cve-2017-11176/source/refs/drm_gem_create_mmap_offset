<dec f='linux/include/drm/drm_gem.h' l='297' type='int drm_gem_create_mmap_offset(struct drm_gem_object * obj)'/>
<use f='linux/drivers/gpu/drm/drm_gem.c' l='334' u='c' c='drm_gem_dumb_map_offset'/>
<def f='linux/drivers/gpu/drm/drm_gem.c' l='513' ll='516' type='int drm_gem_create_mmap_offset(struct drm_gem_object * obj)'/>
<dec f='linux/drivers/gpu/drm/drm_gem.c' l='517' type='int drm_gem_create_mmap_offset(struct drm_gem_object * )'/>
<use f='linux/drivers/gpu/drm/drm_gem.c' l='517' c='drm_gem_create_mmap_offset'/>
<use f='linux/drivers/gpu/drm/drm_gem.c' l='517' u='a'/>
<use f='linux/drivers/gpu/drm/drm_gem.c' l='517' u='a'/>
<doc f='linux/drivers/gpu/drm/drm_gem.c' l='499'>/**
 * drm_gem_create_mmap_offset - create a fake mmap offset for an object
 * @obj: obj in question
 *
 * GEM memory mapping works by handing back to userspace a fake mmap offset
 * it can use in a subsequent mmap(2) call.  The DRM core code then looks
 * up the object based on the offset and sets up the various memory mapping
 * structures.
 *
 * This routine allocates and attaches a fake offset for @obj.
 *
 * Drivers can call drm_gem_free_mmap_offset() before freeing @obj to release
 * the fake offset again.
 */</doc>
<use f='linux/drivers/gpu/drm/i915/i915_gem.c' l='2118' u='c' c='i915_gem_object_create_mmap_offset'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem.c' l='2129' u='c' c='i915_gem_object_create_mmap_offset'/>
