<dec f='linux/include/linux/blkdev.h' l='1254' type='void blk_pm_runtime_init(struct request_queue * q, struct device * dev)'/>
<def f='linux/block/blk-core.c' l='3651' ll='3661' type='void blk_pm_runtime_init(struct request_queue * q, struct device * dev)'/>
<dec f='linux/block/blk-core.c' l='3662' type='void blk_pm_runtime_init(struct request_queue * , struct device * )'/>
<use f='linux/block/blk-core.c' l='3662' c='blk_pm_runtime_init'/>
<use f='linux/block/blk-core.c' l='3662' u='a'/>
<use f='linux/block/blk-core.c' l='3662' u='a'/>
<doc f='linux/block/blk-core.c' l='3630'>/**
 * blk_pm_runtime_init - Block layer runtime PM initialization routine
 * @q: the queue of the device
 * @dev: the device the queue belongs to
 *
 * Description:
 *    Initialize runtime-PM-related fields for @q and start auto suspend for
 *    @dev. Drivers that want to take advantage of request-based runtime PM
 *    should call this function after @dev has been initialized, and its
 *    request queue @q has been allocated, and runtime PM for it can not happen
 *    yet(either due to disabled/forbidden or its usage_count &gt; 0). In most
 *    cases, driver should call this function before any I/O has taken place.
 *
 *    This function takes care of setting up using auto suspend for the device,
 *    the autosuspend delay is set to -1 to make runtime suspend impossible
 *    until an updated value is either set by user or by driver. Drivers do
 *    not need to touch other autosuspend settings.
 *
 *    The block layer runtime PM is request based, so only works for drivers
 *    that use request as their IO unit instead of those directly use bio&apos;s.
 */</doc>
<use f='linux/drivers/scsi/sd.c' l='3299' u='c' c='sd_probe_async'/>
<use f='linux/drivers/scsi/sr.c' l='731' u='c' c='sr_probe'/>
