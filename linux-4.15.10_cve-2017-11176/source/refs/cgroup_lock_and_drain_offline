<dec f='linux/kernel/cgroup/cgroup-internal.h' l='194' type='void cgroup_lock_and_drain_offline(struct cgroup * cgrp)'/>
<use f='linux/kernel/cgroup/cgroup-v1.c' l='1061' u='c' c='cgroup1_remount'/>
<use f='linux/kernel/cgroup/cgroup-v1.c' l='1132' u='c' c='cgroup1_mount'/>
<use f='linux/kernel/cgroup/cgroup.c' l='1246' u='c' c='cgroup_destroy_root'/>
<use f='linux/kernel/cgroup/cgroup.c' l='1533' u='c' c='cgroup_kn_lock_live'/>
<def f='linux/kernel/cgroup/cgroup.c' l='2784' ll='2815' type='void cgroup_lock_and_drain_offline(struct cgroup * cgrp)'/>
<doc f='linux/kernel/cgroup/cgroup.c' l='2776'>/**
 * cgroup_lock_and_drain_offline - lock cgroup_mutex and drain offlined csses
 * @cgrp: root of the target subtree
 *
 * Because css offlining is asynchronous, userland may try to re-enable a
 * controller while the previous css is still around.  This function grabs
 * cgroup_mutex and drains the previous css instances of @cgrp&apos;s subtree.
 */</doc>
