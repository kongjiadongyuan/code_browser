<dec f='linux/include/linux/hugetlb.h' l='140' type='pte_t * huge_pte_offset(struct mm_struct * mm, unsigned long addr, unsigned long sz)'/>
<use f='linux/mm/hugetlb.c' l='3231' u='c' c='copy_hugetlb_page_range'/>
<use f='linux/mm/hugetlb.c' l='3321' u='c' c='__unmap_hugepage_range'/>
<use f='linux/mm/hugetlb.c' l='3539' u='c' c='hugetlb_cow'/>
<use f='linux/mm/hugetlb.c' l='3579' u='c' c='hugetlb_cow'/>
<use f='linux/mm/hugetlb.c' l='3867' u='c' c='hugetlb_fault'/>
<use f='linux/mm/hugetlb.c' l='4153' u='c' c='follow_hugetlb_page'/>
<use f='linux/mm/hugetlb.c' l='4289' u='c' c='hugetlb_change_protection'/>
<use f='linux/mm/hugetlb.c' l='4559' u='c' c='huge_pmd_share'/>
<def f='linux/mm/hugetlb.c' l='4667' ll='4697' type='pte_t * huge_pte_offset(struct mm_struct * mm, unsigned long addr, unsigned long sz)'/>
<doc f='linux/mm/hugetlb.c' l='4658'>/*
 * huge_pte_offset() - Walk the page table to resolve the hugepage
 * entry at address @addr
 *
 * Return: Pointer to page table or swap entry (PUD or PMD) for
 * address @addr, or NULL if a p*d_none() entry is encountered and the
 * size @sz doesn&apos;t match the hugepage size at this level of the page
 * table.
 */</doc>
<use f='linux/mm/page_vma_mapped.c' l='134' u='c' c='page_vma_mapped_walk'/>
<use f='linux/mm/pagewalk.c' l='190' u='c' c='walk_hugetlb_range'/>
