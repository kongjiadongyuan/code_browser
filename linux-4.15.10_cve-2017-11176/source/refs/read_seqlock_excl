<def f='linux/include/linux/seqlock.h' l='507' ll='510' type='void read_seqlock_excl(seqlock_t * sl)'/>
<use f='linux/include/linux/seqlock.h' l='532' u='c' c='read_seqbegin_or_lock'/>
<doc f='linux/include/linux/seqlock.h' l='502'>/*
 * A locking reader exclusively locks out other writers and locking readers,
 * but doesn&apos;t update the sequence number. Acts like a normal spin_lock/unlock.
 * Don&apos;t need preempt_disable() because that is in the spin_lock already.
 */</doc>
<use f='linux/fs/dcache.c' l='1340' u='c' c='path_has_submounts'/>
<use f='linux/fs/namei.c' l='1089' u='c' c='follow_up'/>
<use f='linux/fs/namespace.c' l='791' u='c' c='get_mountpoint'/>
<use f='linux/fs/namespace.c' l='817' u='c' c='get_mountpoint'/>
<use f='linux/fs/namespace.c' l='2070' u='c' c='attach_recursive_mnt'/>
<use f='linux/fs/namespace.c' l='2110' u='c' c='unlock_mount'/>
<use f='linux/fs/namespace.c' l='3087' u='c' c='path_is_under'/>
<use f='linux/fs/pnode.c' l='273' u='c' c='propagate_one'/>
<use f='linux/fs/pnode.c' l='333' u='c' c='propagate_mnt'/>
