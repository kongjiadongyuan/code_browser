<dec f='linux/include/drm/drm_drv.h' l='613' type='void drm_dev_unregister(struct drm_device * dev)'/>
<use f='linux/drivers/gpu/drm/drm_drv.c' l='363' u='c' c='drm_put_dev'/>
<use f='linux/drivers/gpu/drm/drm_drv.c' l='385' u='c' c='drm_dev_unplug'/>
<def f='linux/drivers/gpu/drm/drm_drv.c' l='864' ll='889' type='void drm_dev_unregister(struct drm_device * dev)'/>
<dec f='linux/drivers/gpu/drm/drm_drv.c' l='890' type='void drm_dev_unregister(struct drm_device * )'/>
<use f='linux/drivers/gpu/drm/drm_drv.c' l='890' c='drm_dev_unregister'/>
<use f='linux/drivers/gpu/drm/drm_drv.c' l='890' u='a'/>
<use f='linux/drivers/gpu/drm/drm_drv.c' l='890' u='a'/>
<doc f='linux/drivers/gpu/drm/drm_drv.c' l='850'>/**
 * drm_dev_unregister - Unregister DRM device
 * @dev: Device to unregister
 *
 * Unregister the DRM device from the system. This does the reverse of
 * drm_dev_register() but does not deallocate the device. The caller must call
 * drm_dev_put() to drop their final reference.
 *
 * A special form of unregistering for hotpluggable devices is drm_dev_unplug(),
 * which can be called while there are still open users of @dev.
 *
 * This should be called first in the device teardown code to make sure
 * userspace can&apos;t access the device instance any more.
 */</doc>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='1276' u='c' c='i915_driver_unregister'/>
