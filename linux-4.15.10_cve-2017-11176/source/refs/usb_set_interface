<dec f='linux/include/linux/usb.h' l='1793' type='int usb_set_interface(struct usb_device * dev, int ifnum, int alternate)'/>
<use f='linux/drivers/usb/class/usblp.c' l='1304' u='c' c='usblp_set_protocol'/>
<use f='linux/drivers/usb/core/devio.c' l='1355' u='c' c='proc_setintf'/>
<use f='linux/drivers/usb/core/driver.c' l='354' u='c' c='usb_probe_interface'/>
<use f='linux/drivers/usb/core/driver.c' l='455' u='c' c='usb_unbind_interface'/>
<use f='linux/drivers/usb/core/driver.c' l='1236' u='c' c='usb_resume_interface'/>
<use f='linux/drivers/usb/core/hub.c' l='1425' u='c' c='hub_configure'/>
<use f='linux/drivers/usb/core/hub.c' l='5569' u='c' c='usb_reset_and_verify_device'/>
<def f='linux/drivers/usb/core/message.c' l='1322' ll='1451' type='int usb_set_interface(struct usb_device * dev, int interface, int alternate)'/>
<dec f='linux/drivers/usb/core/message.c' l='1452' type='int usb_set_interface(struct usb_device * , int , int )'/>
<use f='linux/drivers/usb/core/message.c' l='1452' c='usb_set_interface'/>
<use f='linux/drivers/usb/core/message.c' l='1452' u='a'/>
<use f='linux/drivers/usb/core/message.c' l='1452' u='a'/>
<doc f='linux/drivers/usb/core/message.c' l='1289'>/**
 * usb_set_interface - Makes a particular alternate setting be current
 * @dev: the device whose interface is being updated
 * @interface: the interface being updated
 * @alternate: the setting being chosen.
 * Context: !in_interrupt ()
 *
 * This is used to enable data transfers on interfaces that may not
 * be enabled by default.  Not all devices support such configurability.
 * Only the driver bound to an interface may change its setting.
 *
 * Within any given configuration, each interface may have several
 * alternative settings.  These are often used to control levels of
 * bandwidth consumption.  For example, the default setting for a high
 * speed interrupt endpoint may not send more than 64 bytes per microframe,
 * while interrupt transfers of up to 3KBytes per microframe are legal.
 * Also, isochronous endpoints may never be part of an
 * interface&apos;s default setting.  To access such bandwidth, alternate
 * interface settings must be made current.
 *
 * Note that in the Linux USB subsystem, bandwidth associated with
 * an endpoint in a given alternate setting is not reserved until an URB
 * is submitted that needs that bandwidth.  Some other operating systems
 * allocate bandwidth early, when a configuration is chosen.
 *
 * This call is synchronous, and may not be used in an interrupt context.
 * Also, drivers must not change altsettings while urbs are scheduled for
 * endpoints in that interface; all such urbs must first be completed
 * (perhaps forced by unlinking).
 *
 * Return: Zero on success, or else the status code returned by the
 * underlying usb_control_msg() call.
 */</doc>
