<dec f='linux/include/linux/rmap.h' l='249' type='struct anon_vma * page_lock_anon_vma_read(struct page * page)'/>
<doc f='linux/include/linux/rmap.h' l='246'>/*
 * Called by memory-failure.c to kill processes.
 */</doc>
<def f='linux/mm/rmap.c' l='506' ll='566' type='struct anon_vma * page_lock_anon_vma_read(struct page * page)'/>
<use f='linux/mm/rmap.c' l='848' u='r' c='page_referenced'/>
<use f='linux/mm/rmap.c' l='848' u='r' c='page_referenced'/>
<use f='linux/mm/rmap.c' l='1651' u='r' c='try_to_unmap'/>
<use f='linux/mm/rmap.c' l='1651' u='r' c='try_to_unmap'/>
<use f='linux/mm/rmap.c' l='1694' u='r' c='try_to_munlock'/>
<use f='linux/mm/rmap.c' l='1694' u='r' c='try_to_munlock'/>
<doc f='linux/mm/rmap.c' l='499'>/*
 * Similar to page_get_anon_vma() except it locks the anon_vma.
 *
 * Its a little more complex as it tries to keep the fast path to a single
 * atomic op -- the trylock. If we fail the trylock, we fall back to getting a
 * reference like with page_get_anon_vma() and then block on the mutex.
 */</doc>
