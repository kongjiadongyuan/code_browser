<dec f='linux/include/linux/pm.h' l='57' type='const char []'/>
<doc f='linux/include/linux/pm.h' l='57'>/* = &quot;power&quot; */</doc>
<def f='linux/drivers/base/power/sysfs.c' l='95' type='const char [6]'/>
<dec f='linux/drivers/base/power/sysfs.c' l='96' type='typeof (power_group_name)'/>
<use f='linux/drivers/base/power/sysfs.c' l='96'/>
<use f='linux/drivers/base/power/sysfs.c' l='96' u='a'/>
<use f='linux/drivers/base/power/sysfs.c' l='96' u='a'/>
<use f='linux/drivers/base/power/sysfs.c' l='603'/>
<use f='linux/drivers/base/power/sysfs.c' l='603'/>
<use f='linux/drivers/base/power/sysfs.c' l='625'/>
<use f='linux/drivers/base/power/sysfs.c' l='625'/>
<use f='linux/drivers/base/power/sysfs.c' l='640'/>
<use f='linux/drivers/base/power/sysfs.c' l='640'/>
<use f='linux/drivers/base/power/sysfs.c' l='649'/>
<use f='linux/drivers/base/power/sysfs.c' l='649'/>
<use f='linux/drivers/base/power/sysfs.c' l='658'/>
<use f='linux/drivers/base/power/sysfs.c' l='658'/>
<use f='linux/drivers/base/power/sysfs.c' l='667'/>
<use f='linux/drivers/base/power/sysfs.c' l='667'/>
<doc f='linux/drivers/base/power/sysfs.c' l='14'>/*
 *	control - Report/change current runtime PM setting of the device
 *
 *	Runtime power management of a device can be blocked with the help of
 *	this attribute.  All devices have one of the following two values for
 *	the power/control file:
 *
 *	 + &quot;auto\n&quot; to allow the device to be power managed at run time;
 *	 + &quot;on\n&quot; to prevent the device from being power managed at run time;
 *
 *	The default for all devices is &quot;auto&quot;, which means that devices may be
 *	subject to automatic power management, depending on their drivers.
 *	Changing this attribute to &quot;on&quot; prevents the driver from power managing
 *	the device at run time.  Doing that while the device is suspended causes
 *	it to be woken up.
 *
 *	wakeup - Report/change current wakeup option for device
 *
 *	Some devices support &quot;wakeup&quot; events, which are hardware signals
 *	used to activate devices from suspended or low power states.  Such
 *	devices have one of three values for the sysfs power/wakeup file:
 *
 *	 + &quot;enabled\n&quot; to issue the events;
 *	 + &quot;disabled\n&quot; not to do so; or
 *	 + &quot;\n&quot; for temporary or permanent inability to issue wakeup.
 *
 *	(For example, unconfigured USB devices can&apos;t issue wakeups.)
 *
 *	Familiar examples of devices that can issue wakeup events include
 *	keyboards and mice (both PS2 and USB styles), power buttons, modems,
 *	&quot;Wake-On-LAN&quot; Ethernet links, GPIO lines, and more.  Some events
 *	will wake the entire system from a suspend state; others may just
 *	wake up the device (if the system as a whole is already active).
 *	Some wakeup events use normal IRQ lines; other use special out
 *	of band signaling.
 *
 *	It is the responsibility of device drivers to enable (or disable)
 *	wakeup signaling as part of changing device power states, respecting
 *	the policy choices provided through the driver model.
 *
 *	Devices may not be able to generate wakeup events from all power
 *	states.  Also, the events may be ignored in some configurations;
 *	for example, they might need help from other devices that aren&apos;t
 *	active, or which may have wakeup disabled.  Some drivers rely on
 *	wakeup events internally (unless they are disabled), keeping
 *	their hardware in low power modes whenever they&apos;re unused.  This
 *	saves runtime power, without requiring system-wide sleep states.
 *
 *	async - Report/change current async suspend setting for the device
 *
 *	Asynchronous suspend and resume of the device during system-wide power
 *	state transitions can be enabled by writing &quot;enabled&quot; to this file.
 *	Analogously, if &quot;disabled&quot; is written to this file, the device will be
 *	suspended and resumed synchronously.
 *
 *	All devices have one of the following two values for power/async:
 *
 *	 + &quot;enabled\n&quot; to permit the asynchronous suspend/resume of the device;
 *	 + &quot;disabled\n&quot; to forbid it;
 *
 *	NOTE: It generally is unsafe to permit the asynchronous suspend/resume
 *	of a device unless it is certain that all of the PM dependencies of the
 *	device are known to the PM core.  However, for some devices this
 *	attribute is set to &quot;enabled&quot; by bus type code or device drivers and in
 *	that cases it should be safe to leave the default value.
 *
 *	autosuspend_delay_ms - Report/change a device&apos;s autosuspend_delay value
 *
 *	Some drivers don&apos;t want to carry out a runtime suspend as soon as a
 *	device becomes idle; they want it always to remain idle for some period
 *	of time before suspending it.  This period is the autosuspend_delay
 *	value (expressed in milliseconds) and it can be controlled by the user.
 *	If the value is negative then the device will never be runtime
 *	suspended.
 *
 *	NOTE: The autosuspend_delay_ms attribute and the autosuspend_delay
 *	value are used only if the driver calls pm_runtime_use_autosuspend().
 *
 *	wakeup_count - Report the number of wakeup events related to the device
 */</doc>
<use f='linux/drivers/gpu/drm/i915/i915_sysfs.c' l='100'/>
<use f='linux/drivers/gpu/drm/i915/i915_sysfs.c' l='100'/>
<use f='linux/drivers/gpu/drm/i915/i915_sysfs.c' l='111'/>
<use f='linux/drivers/gpu/drm/i915/i915_sysfs.c' l='111'/>
<use f='linux/drivers/gpu/drm/i915/i915_sysfs.c' l='121'/>
<use f='linux/drivers/gpu/drm/i915/i915_sysfs.c' l='121'/>
<use f='linux/drivers/usb/core/sysfs.c' l='357' u='r' c='add_persist_attributes'/>
<use f='linux/drivers/usb/core/sysfs.c' l='366' u='r' c='remove_persist_attributes'/>
<use f='linux/drivers/usb/core/sysfs.c' l='621'/>
<use f='linux/drivers/usb/core/sysfs.c' l='621'/>
<use f='linux/drivers/usb/core/sysfs.c' l='631'/>
<use f='linux/drivers/usb/core/sysfs.c' l='631'/>
<use f='linux/drivers/usb/core/sysfs.c' l='643'/>
<use f='linux/drivers/usb/core/sysfs.c' l='643'/>
