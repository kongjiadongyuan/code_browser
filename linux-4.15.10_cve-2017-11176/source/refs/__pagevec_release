<dec f='linux/include/linux/pagevec.h' l='24' type='void __pagevec_release(struct pagevec * pvec)'/>
<use f='linux/include/linux/pagevec.h' l='86' u='c' c='pagevec_release'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_gtt.c' l='452' u='c' c='vm_free_pages_release'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_gtt.c' l='2874' u='c' c='i915_ggtt_cleanup_hw'/>
<def f='linux/mm/swap.c' l='834' ll='842' type='void __pagevec_release(struct pagevec * pvec)'/>
<dec f='linux/mm/swap.c' l='843' type='void __pagevec_release(struct pagevec * )'/>
<use f='linux/mm/swap.c' l='843' c='__pagevec_release'/>
<use f='linux/mm/swap.c' l='843' u='a'/>
<use f='linux/mm/swap.c' l='843' u='a'/>
<doc f='linux/mm/swap.c' l='824'>/*
 * The pages which we&apos;re about to release may be in the deferred lru-addition
 * queues.  That would prevent them from really being freed right now.  That&apos;s
 * OK from a correctness point of view but is inefficient - those pages may be
 * cache-warm and we want to give them back to the page allocator ASAP.
 *
 * So __pagevec_release() will drain those queues here.  __pagevec_lru_add()
 * and __pagevec_lru_add_active() call release_pages() directly to avoid
 * mutual recursion.
 */</doc>
