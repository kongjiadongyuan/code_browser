<dec f='linux/include/linux/stop_machine.h' l='124' type='int stop_machine(cpu_stop_fn_t fn, void * data, const struct cpumask * cpus)'/>
<doc f='linux/include/linux/stop_machine.h' l='108'>/**
 * stop_machine: freeze the machine on all CPUs and run this function
 * @fn: the function to run
 * @data: the data ptr for the @fn()
 * @cpus: the cpus to run the @fn() on (NULL = any online cpu)
 *
 * Description: This causes a thread to be scheduled on every cpu,
 * each of which disables interrupts.  The result is that no one is
 * holding a spinlock or inside any other preempt-disabled region when
 * @fn() runs.
 *
 * This can be thought of as a very heavy write lock, equivalent to
 * grabbing every spinlock in the kernel.
 *
 * Protects against CPU hotplug.
 */</doc>
<use f='linux/arch/x86/kernel/cpu/mtrr/main.c' l='237' u='c' c='set_mtrr'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_gtt.c' l='2477' u='c' c='bxt_vtd_ggtt_insert_page__BKL'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_gtt.c' l='2503' u='c' c='bxt_vtd_ggtt_insert_entries__BKL'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_gtt.c' l='2528' u='c' c='bxt_vtd_ggtt_clear_range__BKL'/>
<use f='linux/drivers/gpu/drm/i915/i915_gpu_error.c' l='1741' u='c' c='i915_capture_gpu_state'/>
<def f='linux/kernel/stop_machine.c' l='591' ll='600' type='int stop_machine(cpu_stop_fn_t fn, void * data, const struct cpumask * cpus)'/>
<dec f='linux/kernel/stop_machine.c' l='601' type='int stop_machine(cpu_stop_fn_t , void * , const struct cpumask * )'/>
<use f='linux/kernel/stop_machine.c' l='601' c='stop_machine'/>
<use f='linux/kernel/stop_machine.c' l='601' u='a'/>
<use f='linux/kernel/stop_machine.c' l='601' u='a'/>
<use f='linux/kernel/time/timekeeping.c' l='1406' u='c' c='timekeeping_notify'/>
