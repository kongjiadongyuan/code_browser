<dec f='linux/include/linux/usb/hcd.h' l='423' type='void usb_hcd_giveback_urb(struct usb_hcd * hcd, struct urb * urb, int status)'/>
<use f='linux/drivers/usb/core/hcd.c' l='732' u='c' c='rh_call_control'/>
<use f='linux/drivers/usb/core/hcd.c' l='772' u='c' c='usb_hcd_poll_rh_status'/>
<use f='linux/drivers/usb/core/hcd.c' l='864' u='c' c='usb_rh_urb_dequeue'/>
<def f='linux/drivers/usb/core/hcd.c' l='1824' ll='1857' type='void usb_hcd_giveback_urb(struct usb_hcd * hcd, struct urb * urb, int status)'/>
<dec f='linux/drivers/usb/core/hcd.c' l='1858' type='void usb_hcd_giveback_urb(struct usb_hcd * , struct urb * , int )'/>
<use f='linux/drivers/usb/core/hcd.c' l='1858' c='usb_hcd_giveback_urb'/>
<use f='linux/drivers/usb/core/hcd.c' l='1858' u='a'/>
<use f='linux/drivers/usb/core/hcd.c' l='1858' u='a'/>
<doc f='linux/drivers/usb/core/hcd.c' l='1807'>/**
 * usb_hcd_giveback_urb - return URB from HCD to device driver
 * @hcd: host controller returning the URB
 * @urb: urb being returned to the USB device driver.
 * @status: completion status code for the URB.
 * Context: in_interrupt()
 *
 * This hands the URB from HCD to its USB device driver, using its
 * completion function.  The HCD has freed all per-urb resources
 * (and is done using urb-&gt;hcpriv).  It also released all HCD locks;
 * the device driver won&apos;t cause problems if it frees, modifies,
 * or resubmits this URB.
 *
 * If @urb was unlinked, the value of @status will be overridden by
 * @urb-&gt;unlinked.  Erroneous short transfers are detected in case
 * the HCD hasn&apos;t checked for them.
 */</doc>
<use f='linux/drivers/usb/host/ehci-q.c' l='267' u='c' c='ehci_urb_done'/>
<use f='linux/drivers/usb/host/ohci-q.c' l='75' u='c' c='finish_urb'/>
<use f='linux/drivers/usb/host/uhci-q.c' l='1557' u='c' c='uhci_giveback_urb'/>
