<dec f='linux/include/linux/uaccess.h' l='242' type='long probe_kernel_read(void * dst, const void * src, size_t size)'/>
<doc f='linux/include/linux/uaccess.h' l='233'>/*
 * probe_kernel_read(): safely attempt to read from a location
 * @dst: pointer to the buffer that shall take the data
 * @src: address to read from
 * @size: size of the data chunk
 *
 * Safely read from address @src to the buffer at @dst.  If a kernel fault
 * happens, handle that and return -EFAULT.
 */</doc>
<use f='linux/arch/x86/kernel/dumpstack_64.c' l='175' macro='1' u='c' c='show_regs'/>
<use f='linux/arch/x86/kernel/dumpstack_64.c' l='182' macro='1' u='c' c='show_regs'/>
<use f='linux/arch/x86/kernel/kprobes/core.c' l='260' u='c' c='__recover_probed_insn'/>
<use f='linux/arch/x86/kernel/kprobes/core.c' l='363' u='c' c='__copy_instruction'/>
<use f='linux/arch/x86/kernel/kprobes/opt.c' l='72' u='c' c='__recover_optprobed_insn'/>
<use f='linux/arch/x86/kernel/probe_roms.c' l='102' macro='1' u='c' c='probe_list'/>
<use f='linux/arch/x86/kernel/probe_roms.c' l='128' macro='1' u='c' c='find_oprom'/>
<use f='linux/arch/x86/kernel/probe_roms.c' l='131' macro='1' u='c' c='find_oprom'/>
<use f='linux/arch/x86/kernel/probe_roms.c' l='134' macro='1' u='c' c='find_oprom'/>
<use f='linux/arch/x86/kernel/probe_roms.c' l='142' macro='1' u='c' c='find_oprom'/>
<use f='linux/arch/x86/kernel/probe_roms.c' l='143' macro='1' u='c' c='find_oprom'/>
<use f='linux/arch/x86/kernel/probe_roms.c' l='186' macro='1' u='c' c='romsignature'/>
<use f='linux/arch/x86/kernel/probe_roms.c' l='193' macro='1' u='c' c='romchecksum'/>
<use f='linux/arch/x86/kernel/probe_roms.c' l='214' macro='1' u='c' c='probe_roms'/>
<use f='linux/arch/x86/kernel/probe_roms.c' l='252' macro='1' u='c' c='probe_roms'/>
<use f='linux/arch/x86/kernel/traps.c' l='167' macro='1' u='c' c='is_valid_bugaddr'/>
<use f='linux/arch/x86/mm/fault.c' l='110' macro='1' u='c' c='check_prefetch_opcode'/>
<use f='linux/arch/x86/mm/fault.c' l='144' macro='1' u='c' c='is_prefetch'/>
<use f='linux/arch/x86/mm/fault.c' l='532' macro='1' u='c' c='bad_address'/>
<use f='linux/fs/proc/kcore.c' l='519' u='c' c='read_kcore'/>
<use f='linux/kernel/exit.c' l='249' macro='1' u='c' c='task_rcu_dereference'/>
<use f='linux/kernel/kthread.c' l='174' u='c' c='kthread_probe_data'/>
<use f='linux/kernel/trace/trace_kprobe.c' l='174' macro='1' u='c' c='fetch_memory_u8'/>
<use f='linux/kernel/trace/trace_kprobe.c' l='174' macro='1' u='c' c='fetch_memory_u16'/>
<use f='linux/kernel/trace/trace_kprobe.c' l='174' macro='1' u='c' c='fetch_memory_u32'/>
<use f='linux/kernel/trace/trace_kprobe.c' l='174' macro='1' u='c' c='fetch_memory_u64'/>
<use f='linux/kernel/workqueue.c' l='4335' u='c' c='print_worker_info'/>
<use f='linux/kernel/workqueue.c' l='4336' u='c' c='print_worker_info'/>
<use f='linux/kernel/workqueue.c' l='4337' u='c' c='print_worker_info'/>
<use f='linux/kernel/workqueue.c' l='4338' u='c' c='print_worker_info'/>
<use f='linux/kernel/workqueue.c' l='4341' u='c' c='print_worker_info'/>
<use f='linux/kernel/workqueue.c' l='4343' u='c' c='print_worker_info'/>
<def f='linux/mm/maccess.c' l='23' ll='24' type='long probe_kernel_read(void * dst, const void * src, size_t size)'/>
<dec f='linux/mm/maccess.c' l='40' type='long probe_kernel_read(void * , const void * , size_t )'/>
<use f='linux/mm/maccess.c' l='40' c='probe_kernel_read'/>
<use f='linux/mm/maccess.c' l='40' u='a'/>
<use f='linux/mm/maccess.c' l='40' u='a'/>
<doc f='linux/mm/maccess.c' l='8'>/**
 * probe_kernel_read(): safely attempt to read from a location
 * @dst: pointer to the buffer that shall take the data
 * @src: address to read from
 * @size: size of the data chunk
 *
 * Safely read from address @src to the buffer at @dst.  If a kernel fault
 * happens, handle that and return -EFAULT.
 *
 * We ensure that the copy_from_user is executed in atomic context so that
 * do_page_fault() doesn&apos;t attempt to take mmap_sem.  This makes
 * probe_kernel_read() suitable for use within regions where the caller
 * already holds mmap_sem, or other locks which nest inside mmap_sem.
 */</doc>
<use f='linux/mm/slub.c' l='287' u='c' c='get_freepointer_safe'/>
