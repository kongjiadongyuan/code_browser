<dec f='linux/include/sound/control.h' l='123' type='struct snd_kcontrol * snd_ctl_new1(const struct snd_kcontrol_new * kcontrolnew, void * private_data)'/>
<def f='linux/sound/core/control.c' l='246' ll='296' type='struct snd_kcontrol * snd_ctl_new1(const struct snd_kcontrol_new * ncontrol, void * private_data)'/>
<dec f='linux/sound/core/control.c' l='297' type='struct snd_kcontrol * snd_ctl_new1(const struct snd_kcontrol_new * , void * )'/>
<use f='linux/sound/core/control.c' l='297' c='snd_ctl_new1'/>
<use f='linux/sound/core/control.c' l='297' u='a'/>
<use f='linux/sound/core/control.c' l='297' u='a'/>
<doc f='linux/sound/core/control.c' l='235'>/**
 * snd_ctl_new1 - create a control instance from the template
 * @ncontrol: the initialization record
 * @private_data: the private data to set
 *
 * Allocates a new struct snd_kcontrol instance and initialize from the given 
 * template.  When the access field of ncontrol is 0, it&apos;s assumed as
 * READWRITE access. When the count field is 0, it&apos;s assumes as one.
 *
 * Return: The pointer of the newly generated instance, or %NULL on failure.
 */</doc>
<use f='linux/sound/core/ctljack.c' l='71' u='c' c='snd_kctl_jack_new'/>
<use f='linux/sound/core/pcm_lib.c' l='2454' u='c' c='snd_pcm_add_chmap_ctls'/>
<use f='linux/sound/core/vmaster.c' l='409' u='c' c='snd_ctl_make_virtual_master'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2027' u='c' c='snd_hda_add_vmaster_hook'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2436' u='c' c='snd_hda_create_dig_out_ctls'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2557' u='c' c='snd_hda_create_spdif_share_sw'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2658' u='c' c='snd_hda_create_spdif_in_ctls'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='3271' u='c' c='snd_hda_add_new_ctls'/>
