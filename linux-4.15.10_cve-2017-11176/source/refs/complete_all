<dec f='linux/include/linux/completion.h' l='119' type='void complete_all(struct completion * )'/>
<use f='linux/crypto/algapi.c' l='327' u='c' c='crypto_alg_tested'/>
<use f='linux/crypto/algboss.c' l='89' u='c' c='cryptomgr_probe'/>
<use f='linux/crypto/api.c' l='166' u='c' c='crypto_larval_kill'/>
<use f='linux/drivers/base/firmware_class.c' l='150' u='c' c='__fw_state_set'/>
<use f='linux/drivers/base/power/main.c' l='100' u='c' c='device_pm_sleep_init'/>
<use f='linux/drivers/base/power/main.c' l='147' u='c' c='device_pm_remove'/>
<use f='linux/drivers/base/power/main.c' l='592' u='c' c='device_resume_noirq'/>
<use f='linux/drivers/base/power/main.c' l='735' u='c' c='device_resume_early'/>
<use f='linux/drivers/base/power/main.c' l='896' u='c' c='device_resume'/>
<use f='linux/drivers/base/power/main.c' l='1149' u='c' c='__device_suspend_noirq'/>
<use f='linux/drivers/base/power/main.c' l='1311' u='c' c='__device_suspend_late'/>
<use f='linux/drivers/base/power/main.c' l='1569' u='c' c='__device_suspend'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1759' u='c' c='drm_atomic_helper_setup_commit'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1765' u='c' c='drm_atomic_helper_setup_commit'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1953' u='c' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1957' u='c' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1958' u='c' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1986' u='c' c='drm_atomic_helper_commit_cleanup_done'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1995' u='c' c='drm_atomic_helper_commit_cleanup_done'/>
<use f='linux/drivers/gpu/drm/drm_file.c' l='704' u='c' c='drm_send_event_locked'/>
<use f='linux/fs/autofs4/expire.c' l='580' u='c' c='autofs4_expire_run'/>
<use f='linux/fs/autofs4/expire.c' l='610' u='c' c='autofs4_do_expire_multi'/>
<def f='linux/kernel/sched/completion.c' l='60' ll='68' type='void complete_all(struct completion * x)'/>
<dec f='linux/kernel/sched/completion.c' l='69' type='void complete_all(struct completion * )'/>
<use f='linux/kernel/sched/completion.c' l='69' c='complete_all'/>
<use f='linux/kernel/sched/completion.c' l='69' u='a'/>
<use f='linux/kernel/sched/completion.c' l='69' u='a'/>
<doc f='linux/kernel/sched/completion.c' l='44'>/**
 * complete_all: - signals all threads waiting on this completion
 * @x:  holds the state of this particular completion
 *
 * This will wake up all threads waiting on this particular completion event.
 *
 * It may be assumed that this function implies a write memory barrier before
 * changing the task state if and only if any tasks are woken up.
 *
 * Since complete_all() sets the completion of @x permanently to done
 * to allow multiple waiters to finish, a call to reinit_completion()
 * must be used on @x if @x is to be used again. The code must make
 * sure that all waiters have woken and finished before reinitializing
 * @x. Also note that the function completion_done() can not be used
 * to know if there are still waiters after complete_all() has been called.
 */</doc>
<use f='linux/sound/pci/hda/hda_intel.c' l='1349' u='c' c='azx_free'/>
<use f='linux/sound/pci/hda/hda_intel.c' l='2181' u='c' c='azx_probe'/>
<use f='linux/sound/pci/hda/hda_intel.c' l='2327' u='c' c='azx_probe_continue'/>
