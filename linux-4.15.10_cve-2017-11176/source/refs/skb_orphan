<def f='linux/include/linux/skbuff.h' l='2518' ll='2527' type='void skb_orphan(struct sk_buff * skb)'/>
<doc f='linux/include/linux/skbuff.h' l='2510'>/**
 *	skb_orphan - orphan a buffer
 *	@skb: buffer to orphan
 *
 *	If a buffer currently has an owner then we call the owner&apos;s
 *	destructor function and make the @skb unowned. The buffer continues
 *	to exist but is no longer charged to its former owner.
 */</doc>
<use f='linux/include/net/sock.h' l='2034' u='c' c='skb_set_owner_r'/>
<use f='linux/drivers/net/loopback.c' l='78' u='c' c='loopback_xmit'/>
<use f='linux/net/core/datagram.c' l='347' u='c' c='__skb_free_datagram_locked'/>
<use f='linux/net/core/skbuff.c' l='4165' u='c' c='sock_queue_err_skb'/>
<use f='linux/net/core/skbuff.c' l='4873' u='c' c='skb_scrub_packet'/>
<use f='linux/net/core/sock.c' l='1827' u='c' c='skb_set_owner_w'/>
<use f='linux/net/core/sock.c' l='1870' u='c' c='skb_orphan_partial'/>
<use f='linux/net/ipv4/ip_fragment.c' l='673' u='c' c='ip_defrag'/>
<use f='linux/net/ipv4/ip_input.c' l='491' u='c' c='ip_rcv'/>
<use f='linux/net/ipv4/tcp_output.c' l='1098' u='c' c='tcp_transmit_skb'/>
<use f='linux/net/ipv6/ip6_input.c' l='206' u='c' c='ipv6_rcv'/>
<use f='linux/net/ipv6/netfilter/nf_conntrack_reasm.c' l='593' u='c' c='nf_ct_frag6_gather'/>
<use f='linux/net/mac80211/status.c' l='872' u='c' c='__ieee80211_tx_status'/>
<use f='linux/net/netlink/af_netlink.c' l='1407' u='c' c='do_one_broadcast'/>
