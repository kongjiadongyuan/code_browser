<def f='linux/include/linux/mm_inline.h' l='21' ll='24' type='int page_is_file_cache(struct page * page)'/>
<use f='linux/include/linux/mm_inline.h' l='78' u='c' c='page_lru_base_type'/>
<doc f='linux/include/linux/mm_inline.h' l='8'>/**
 * page_is_file_cache - should the page be on a file LRU or anon LRU?
 * @page: the page to test
 *
 * Returns 1 if @page is page cache page backed by a regular filesystem,
 * or 0 if @page is anonymous, tmpfs or otherwise ram or swap backed.
 * Used by functions that manipulate the LRU lists, to sort a page
 * onto the right LRU list.
 *
 * We would like to get this info without a page flag, but the state
 * needs to survive until the page is last deleted from the LRU, which
 * could be as far down as __page_cache_release.
 */</doc>
<use f='linux/mm/compaction.c' l='880' u='c' c='isolate_migratepages_block'/>
<use f='linux/mm/mempolicy.c' l='939' u='c' c='migrate_page_add'/>
<use f='linux/mm/migrate.c' l='193' u='c' c='putback_movable_pages'/>
<use f='linux/mm/migrate.c' l='1192' u='c' c='unmap_and_move'/>
<use f='linux/mm/migrate.c' l='1560' u='c' c='do_move_page_to_node_array'/>
<use f='linux/mm/swap.c' l='277' u='c' c='__activate_page'/>
<use f='linux/mm/swap.c' l='393' u='c' c='mark_page_accessed'/>
<use f='linux/mm/swap.c' l='544' u='c' c='lru_deactivate_file_fn'/>
<use f='linux/mm/swap.c' l='889' u='c' c='__pagevec_lru_add_fn'/>
<use f='linux/include/trace/events/vmscan.h' l='31' u='c' c='trace_event_raw_event_mm_vmscan_writepage'/>
<use f='linux/include/trace/events/vmscan.h' l='31' u='c' c='perf_trace_mm_vmscan_writepage'/>
<use f='linux/mm/vmscan.c' l='745' u='c' c='__remove_mapping'/>
<use f='linux/mm/vmscan.c' l='926' u='c' c='page_check_dirty_writeback'/>
<use f='linux/mm/vmscan.c' l='1205' u='c' c='shrink_page_list'/>
<use f='linux/mm/vmscan.c' l='1386' u='c' c='reclaim_clean_pages_from_list'/>
<use f='linux/mm/vmscan.c' l='2041' u='c' c='shrink_active_list'/>
