<dec f='linux/kernel/cgroup/cgroup-internal.h' l='166' type='struct cgroup * cgroup_kn_lock_live(struct kernfs_node * kn, bool drain_offline)'/>
<use f='linux/kernel/cgroup/cgroup-v1.c' l='527' u='c' c='__cgroup1_procs_write'/>
<use f='linux/kernel/cgroup/cgroup-v1.c' l='579' u='c' c='cgroup_release_agent_write'/>
<def f='linux/kernel/cgroup/cgroup.c' l='1513' ll='1542' type='struct cgroup * cgroup_kn_lock_live(struct kernfs_node * kn, bool drain_offline)'/>
<use f='linux/kernel/cgroup/cgroup.c' l='3108' u='c' c='cgroup_subtree_control_write'/>
<use f='linux/kernel/cgroup/cgroup.c' l='3234' u='c' c='cgroup_type_write'/>
<use f='linux/kernel/cgroup/cgroup.c' l='3277' u='c' c='cgroup_max_descendants_write'/>
<use f='linux/kernel/cgroup/cgroup.c' l='3320' u='c' c='cgroup_max_depth_write'/>
<use f='linux/kernel/cgroup/cgroup.c' l='4352' u='c' c='cgroup_procs_write'/>
<use f='linux/kernel/cgroup/cgroup.c' l='4395' u='c' c='cgroup_threads_write'/>
<use f='linux/kernel/cgroup/cgroup.c' l='4891' u='c' c='cgroup_mkdir'/>
<use f='linux/kernel/cgroup/cgroup.c' l='5117' u='c' c='cgroup_rmdir'/>
<doc f='linux/kernel/cgroup/cgroup.c' l='1496'>/**
 * cgroup_kn_lock_live - locking helper for cgroup kernfs methods
 * @kn: the kernfs_node being serviced
 * @drain_offline: perform offline draining on the cgroup
 *
 * This helper is to be used by a cgroup kernfs method currently servicing
 * @kn.  It breaks the active protection, performs cgroup locking and
 * verifies that the associated cgroup is alive.  Returns the cgroup if
 * alive; otherwise, %NULL.  A successful return should be undone by a
 * matching cgroup_kn_unlock() invocation.  If @drain_offline is %true, the
 * cgroup is drained of offlining csses before return.
 *
 * Any cgroup kernfs method implementation which requires locking the
 * associated cgroup should use this helper.  It avoids nesting cgroup
 * locking under kernfs active protection and allows all kernfs operations
 * including self-removal.
 */</doc>
