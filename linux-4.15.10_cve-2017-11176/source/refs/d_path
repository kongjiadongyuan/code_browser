<dec f='linux/include/linux/dcache.h' l='301' type='char * d_path(const struct path * , char * , int )'/>
<def f='linux/fs/dcache.c' l='3273' ll='3302' type='char * d_path(const struct path * path, char * buf, int buflen)'/>
<dec f='linux/fs/dcache.c' l='3303' type='char * d_path(const struct path * , char * , int )'/>
<use f='linux/fs/dcache.c' l='3303' c='d_path'/>
<use f='linux/fs/dcache.c' l='3303' u='a'/>
<use f='linux/fs/dcache.c' l='3303' u='a'/>
<doc f='linux/fs/dcache.c' l='3257'>/**
 * d_path - return the path of a dentry
 * @path: path to report
 * @buf: buffer to return value in
 * @buflen: buffer length
 *
 * Convert a dentry into an ASCII path name. If the entry has been deleted
 * the string &quot; (deleted)&quot; is appended. Note that this is ambiguous.
 *
 * Returns a pointer into the buffer or an error code if the path was
 * too long. Note: Callers should use the returned pointer, not the passed
 * in buffer, to use the name! The implementation often starts at an offset
 * into the buffer, and may leave 0 bytes at the start.
 *
 * &quot;buflen&quot; should be positive.
 */</doc>
<use f='linux/fs/dcookies.c' l='180' u='c' c='SYSC_lookup_dcookie'/>
<use f='linux/fs/ext4/file.c' l='401' u='c' c='ext4_file_open'/>
<use f='linux/fs/open.c' l='847' u='c' c='file_path'/>
<use f='linux/fs/proc/base.c' l='1640' u='c' c='do_proc_readlink'/>
<use f='linux/fs/seq_file.c' l='468' u='c' c='seq_path'/>
<use f='linux/kernel/audit.c' l='1981' u='c' c='audit_log_d_path'/>
<use f='linux/lib/seq_buf.c' l='270' u='c' c='seq_buf_path'/>
