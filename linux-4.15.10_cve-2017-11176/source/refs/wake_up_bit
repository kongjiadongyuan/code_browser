<dec f='linux/include/linux/wait_bit.h' l='34' type='void wake_up_bit(void * word, int bit)'/>
<use f='linux/include/linux/fs.h' l='3036' u='c' c='inode_dio_end'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='1948' u='c' c='i915_reset'/>
<use f='linux/drivers/gpu/drm/i915/i915_irq.c' l='2877' u='c' c='i915_handle_error'/>
<use f='linux/drivers/md/dm.c' l='2585' u='c' c='__dm_internal_resume'/>
<use f='linux/fs/block_dev.c' l='1617' u='c' c='blkdev_get'/>
<use f='linux/fs/buffer.c' l='80' u='c' c='unlock_buffer'/>
<use f='linux/fs/fs-writeback.c' l='1072' u='c' c='inode_sync_complete'/>
<use f='linux/fs/inode.c' l='566' u='c' c='evict'/>
<use f='linux/fs/inode.c' l='961' u='c' c='unlock_new_inode'/>
<use f='linux/fs/jbd2/commit.c' l='47' u='c' c='journal_end_buffer_io_sync'/>
<use f='linux/fs/jbd2/commit.c' l='242' u='c' c='journal_submit_data_buffers'/>
<use f='linux/fs/jbd2/commit.c' l='273' u='c' c='journal_finish_inode_data_buffers'/>
<use f='linux/fs/nfs/inode.c' l='1257' u='c' c='nfs_revalidate_mapping'/>
<use f='linux/fs/nfs/nfs4state.c' l='1195' u='c' c='nfs4_clear_state_manager_bit'/>
<use f='linux/fs/nfs/pagelist.c' l='175' u='c' c='nfs_page_group_unlock'/>
<use f='linux/fs/nfs/pagelist.c' l='366' u='c' c='nfs_unlock_request'/>
<def f='linux/kernel/sched/wait_bit.c' l='145' ll='148' type='void wake_up_bit(void * word, int bit)'/>
<dec f='linux/kernel/sched/wait_bit.c' l='149' type='void wake_up_bit(void * , int )'/>
<use f='linux/kernel/sched/wait_bit.c' l='149' c='wake_up_bit'/>
<use f='linux/kernel/sched/wait_bit.c' l='149' u='a'/>
<use f='linux/kernel/sched/wait_bit.c' l='149' u='a'/>
<doc f='linux/kernel/sched/wait_bit.c' l='128'>/**
 * wake_up_bit - wake up a waiter on a bit
 * @word: the word being waited on, a kernel virtual address
 * @bit: the bit of the word being waited on
 *
 * There is a standard hashed waitqueue table for generic use. This
 * is the part of the hashtable&apos;s accessor API that wakes up waiters
 * on a bit. For instance, if one were to have waiters on a bitflag,
 * one would call wake_up_bit() after clearing the bit.
 *
 * In order for this to function properly, as it uses waitqueue_active()
 * internally, some kind of memory barrier must be done prior to calling
 * this. Typically, this will be smp_mb__after_atomic(), but in some
 * cases where bitflags are manipulated non-atomically under a lock, one
 * may need to use a less regular barrier, such fs/inode.c&apos;s smp_mb(),
 * because spin_unlock() does not guarantee a memory barrier.
 */</doc>
<use f='linux/kernel/signal.c' l='289' u='c' c='task_clear_jobctl_trapping'/>
<use f='linux/net/sunrpc/sched.c' l='344' u='c' c='rpc_make_runnable'/>
<use f='linux/net/sunrpc/xprt.c' l='620' u='c' c='xprt_autoclose'/>
<use f='linux/net/sunrpc/xprt.c' l='748' u='c' c='xprt_unlock_connect'/>
<use f='linux/net/sunrpc/xprt.c' l='872' u='c' c='xprt_unpin_rqst'/>
<use f='linux/security/keys/gc.c' l='318' u='c' c='key_garbage_collector'/>
<use f='linux/security/keys/key.c' l='474' u='c' c='__key_instantiate_and_link'/>
<use f='linux/security/keys/key.c' l='619' u='c' c='key_reject_and_link'/>
