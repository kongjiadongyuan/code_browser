<dec f='linux/include/linux/sunrpc/svc_xprt.h' l='118' type='int svc_reg_xprt_class(struct svc_xprt_class * )'/>
<def f='linux/net/sunrpc/svc_xprt.c' l='75' ll='94' type='int svc_reg_xprt_class(struct svc_xprt_class * xcl)'/>
<dec f='linux/net/sunrpc/svc_xprt.c' l='95' type='int svc_reg_xprt_class(struct svc_xprt_class * )'/>
<use f='linux/net/sunrpc/svc_xprt.c' l='95' c='svc_reg_xprt_class'/>
<use f='linux/net/sunrpc/svc_xprt.c' l='95' u='a'/>
<use f='linux/net/sunrpc/svc_xprt.c' l='95' u='a'/>
<doc f='linux/net/sunrpc/svc_xprt.c' l='45'>/* SMP locking strategy:
 *
 *	svc_pool-&gt;sp_lock protects most of the fields of that pool.
 *	svc_serv-&gt;sv_lock protects sv_tempsocks, sv_permsocks, sv_tmpcnt.
 *	when both need to be taken (rare), svc_serv-&gt;sv_lock is first.
 *	The &quot;service mutex&quot; protects svc_serv-&gt;sv_nrthread.
 *	svc_sock-&gt;sk_lock protects the svc_sock-&gt;sk_deferred list
 *             and the -&gt;sk_info_authunix cache.
 *
 *	The XPT_BUSY bit in xprt-&gt;xpt_flags prevents a transport being
 *	enqueued multiply. During normal transport processing this bit
 *	is set by svc_xprt_enqueue and cleared by svc_xprt_received.
 *	Providers should not manipulate this bit directly.
 *
 *	Some flags can be set to certain values at any time
 *	providing that certain rules are followed:
 *
 *	XPT_CONN, XPT_DATA:
 *		- Can be set or cleared at any time.
 *		- After a set, svc_xprt_enqueue must be called to enqueue
 *		  the transport for processing.
 *		- After a clear, the transport must be read/accepted.
 *		  If this succeeds, it must be set again.
 *	XPT_CLOSE:
 *		- Can set at any time. It is never cleared.
 *      XPT_DEAD:
 *		- Can only be set while XPT_BUSY is held which ensures
 *		  that no other thread will be using the transport or will
 *		  try to set XPT_DEAD.
 */</doc>
<use f='linux/net/sunrpc/svcsock.c' l='1302' u='c' c='svc_init_xprt_sock'/>
<use f='linux/net/sunrpc/svcsock.c' l='1303' u='c' c='svc_init_xprt_sock'/>
