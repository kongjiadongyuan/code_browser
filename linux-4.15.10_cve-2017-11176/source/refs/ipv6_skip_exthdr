<dec f='linux/include/net/ipv6.h' l='987' type='int ipv6_skip_exthdr(const struct sk_buff * , int start, u8 * nexthdrp, __be16 * frag_offp)'/>
<def f='linux/net/ipv6/exthdrs_core.c' l='71' ll='112' type='int ipv6_skip_exthdr(const struct sk_buff * skb, int start, u8 * nexthdrp, __be16 * frag_offp)'/>
<dec f='linux/net/ipv6/exthdrs_core.c' l='113' type='int ipv6_skip_exthdr(const struct sk_buff * , int , u8 * , __be16 * )'/>
<use f='linux/net/ipv6/exthdrs_core.c' l='113' c='ipv6_skip_exthdr'/>
<use f='linux/net/ipv6/exthdrs_core.c' l='113' u='a'/>
<use f='linux/net/ipv6/exthdrs_core.c' l='113' u='a'/>
<doc f='linux/net/ipv6/exthdrs_core.c' l='26'>/*
 * Skip any extension headers. This is used by the ICMP module.
 *
 * Note that strictly speaking this conflicts with RFC 2460 4.0:
 * ...The contents and semantics of each extension header determine whether
 * or not to proceed to the next header.  Therefore, extension headers must
 * be processed strictly in the order they appear in the packet; a
 * receiver must not, for example, scan through a packet looking for a
 * particular kind of extension header and process that header prior to
 * processing all preceding ones.
 *
 * We do exactly this. This is a protocol bug. We can&apos;t decide after a
 * seeing an unknown discard-with-error flavour TLV option if it&apos;s a
 * ICMP error message or not (errors should never be send in reply to
 * ICMP error messages).
 *
 * But I see no other way to do this. This might need to be reexamined
 * when Linux implements ESP (and maybe AUTH) headers.
 * --AK
 *
 * This function parses (probably truncated) exthdr set &quot;hdr&quot;.
 * &quot;nexthdrp&quot; initially points to some place,
 * where type of the first header can be found.
 *
 * It skips all well-known exthdrs, and returns pointer to the start
 * of unparsable area i.e. the first header with unknown type.
 * If it is not NULL *nexthdr is updated by type/protocol of this header.
 *
 * NOTES: - if packet terminated with NEXTHDR_NONE it returns NULL.
 *        - it may return pointer pointing beyond end of packet,
 *	    if the last recognized header is truncated in the middle.
 *        - if packet is truncated, so that all parsed headers are skipped,
 *	    it returns NULL.
 *	  - First fragment header is skipped, not-first ones
 *	    are considered as unparsable.
 *	  - Reports the offset field of the final fragment header so it is
 *	    possible to tell whether this is a first fragment, later fragment,
 *	    or not fragmented.
 *	  - ESP is unparsable for now and considered like
 *	    normal payload protocol.
 *	  - Note also special handling of AUTH header. Thanks to IPsec wizards.
 *
 * --ANK (980726)
 */</doc>
<use f='linux/net/ipv6/icmp.c' l='155' u='c' c='is_ineligible'/>
<use f='linux/net/ipv6/icmp.c' l='765' u='c' c='icmpv6_notify'/>
<use f='linux/net/ipv6/ip6_output.c' l='323' u='c' c='ip6_forward_proxy_check'/>
<use f='linux/net/ipv6/mcast_snoop.c' l='61' u='c' c='ipv6_mc_check_exthdrs'/>
<use f='linux/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c' l='83' u='c' c='ipv6_get_l4proto'/>
<use f='linux/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c' l='124' u='c' c='ipv6_helper'/>
<use f='linux/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c' l='148' u='c' c='ipv6_confirm'/>
<use f='linux/net/ipv6/netfilter/nf_reject_ipv6.c' l='28' u='c' c='nf_reject_ip6_tcphdr_get'/>
<use f='linux/net/ipv6/netfilter/nf_reject_ipv6.c' l='227' u='c' c='reject6_csum_ok'/>
<use f='linux/net/netfilter/xt_TCPMSS.c' l='234' u='c' c='tcpmss_tg6'/>
<use f='linux/security/lsm_audit.c' l='130' u='c' c='ipv6_skb_to_auditdata'/>
<use f='linux/security/selinux/hooks.c' l='4166' u='c' c='selinux_parse_skb_ipv6'/>
