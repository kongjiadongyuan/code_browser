<dec f='linux/drivers/gpu/drm/i915/i915_drv.h' l='3447' type='int i915_gem_mmap_gtt_ioctl(struct drm_device * dev, void * data, struct drm_file * file_priv)'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2752'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2752'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2752'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2752'/>
<def f='linux/drivers/gpu/drm/i915/i915_gem.c' l='2179' ll='2186' type='int i915_gem_mmap_gtt_ioctl(struct drm_device * dev, void * data, struct drm_file * file)'/>
<doc f='linux/drivers/gpu/drm/i915/i915_gem.c' l='2164'>/**
 * i915_gem_mmap_gtt_ioctl - prepare an object for GTT mmap&apos;ing
 * @dev: DRM device
 * @data: GTT mapping ioctl data
 * @file: GEM object info
 *
 * Simply returns the fake offset to userspace so it can mmap it.
 * The mmap call will end up in drm_gem_mmap(), which will set things
 * up so we can get faults in the handler above.
 *
 * The fault handler will take care of binding the object into the GTT
 * (since it may have been evicted to make room for something), allocating
 * a fence register, and mapping the appropriate aperture address into
 * userspace.
 */</doc>
