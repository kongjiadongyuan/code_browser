<def f='linux/drivers/edac/edac_device.h' l='74' ll='77'/>
<use f='linux/drivers/edac/edac_device.h' l='121'/>
<use f='linux/drivers/edac/edac_device.h' l='137'/>
<use f='linux/drivers/edac/edac_device.h' l='221'/>
<size>8</size>
<doc f='linux/drivers/edac/edac_device.h' l='35'>/*
 * The following are the structures to provide for a generic
 * or abstract &apos;edac_device&apos;. This set of structures and the
 * code that implements the APIs for the same, provide for
 * registering EDAC type devices which are NOT standard memory.
 *
 * CPU caches (L1 and L2)
 * DMA engines
 * Core CPU switches
 * Fabric switch units
 * PCIe interface controllers
 * other EDAC/ECC type devices that can be monitored for
 * errors, etc.
 *
 * It allows for a 2 level set of hierarchy. For example:
 *
 * cache could be composed of L1, L2 and L3 levels of cache.
 * Each CPU core would have its own L1 cache, while sharing
 * L2 and maybe L3 caches.
 *
 * View them arranged, via the sysfs presentation:
 * /sys/devices/system/edac/..
 *
 *	mc/		&lt;existing memory device directory&gt;
 *	cpu/cpu0/..	&lt;L1 and L2 block directory&gt;
 *		/L1-cache/ce_count
 *			 /ue_count
 *		/L2-cache/ce_count
 *			 /ue_count
 *	cpu/cpu1/..	&lt;L1 and L2 block directory&gt;
 *		/L1-cache/ce_count
 *			 /ue_count
 *		/L2-cache/ce_count
 *			 /ue_count
 *	...
 *
 *	the L1 and L2 directories would be &quot;edac_device_block&apos;s&quot;
 */</doc>
<mbr r='edac_device_counter::ue_count' o='0' t='u32'/>
<mbr r='edac_device_counter::ce_count' o='32' t='u32'/>
