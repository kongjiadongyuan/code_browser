<use f='linux/include/linux/dm-region-hash.h' l='35' c='dm_region_hash_create'/>
<use f='linux/include/linux/dm-region-hash.h' l='43' c='dm_region_hash_destroy'/>
<use f='linux/include/linux/dm-region-hash.h' l='45' c='dm_rh_dirty_log'/>
<use f='linux/include/linux/dm-region-hash.h' l='50' c='dm_rh_bio_to_region'/>
<use f='linux/include/linux/dm-region-hash.h' l='51' c='dm_rh_region_to_sector'/>
<use f='linux/include/linux/dm-region-hash.h' l='57' c='dm_rh_get_region_size'/>
<use f='linux/include/linux/dm-region-hash.h' l='64' c='dm_rh_get_state'/>
<use f='linux/include/linux/dm-region-hash.h' l='65' c='dm_rh_set_state'/>
<use f='linux/include/linux/dm-region-hash.h' l='69' c='dm_rh_update_states'/>
<use f='linux/include/linux/dm-region-hash.h' l='72' c='dm_rh_flush'/>
<use f='linux/include/linux/dm-region-hash.h' l='75' c='dm_rh_inc_pending'/>
<use f='linux/include/linux/dm-region-hash.h' l='76' c='dm_rh_dec'/>
<use f='linux/include/linux/dm-region-hash.h' l='79' c='dm_rh_delay'/>
<use f='linux/include/linux/dm-region-hash.h' l='81' c='dm_rh_mark_nosync'/>
<use f='linux/include/linux/dm-region-hash.h' l='88' c='dm_rh_recovery_prepare'/>
<use f='linux/include/linux/dm-region-hash.h' l='91' c='dm_rh_recovery_start'/>
<use f='linux/include/linux/dm-region-hash.h' l='97' c='dm_rh_recovery_in_flight'/>
<use f='linux/include/linux/dm-region-hash.h' l='100' c='dm_rh_start_recovery'/>
<use f='linux/include/linux/dm-region-hash.h' l='101' c='dm_rh_stop_recovery'/>
<use f='linux/drivers/md/dm-raid1.c' l='63'/>
<def f='linux/drivers/md/dm-region-hash.c' l='57' ll='99'/>
<use f='linux/drivers/md/dm-region-hash.c' l='102'/>
<use f='linux/drivers/md/dm-region-hash.c' l='116' c='dm_rh_sector_to_region'/>
<use f='linux/drivers/md/dm-region-hash.c' l='121' c='dm_rh_region_to_sector'/>
<use f='linux/drivers/md/dm-region-hash.c' l='127' c='dm_rh_bio_to_region'/>
<use f='linux/drivers/md/dm-region-hash.c' l='146' c='dm_rh_get_region_size'/>
<use f='linux/drivers/md/dm-region-hash.c' l='160' c='dm_region_hash_create'/>
<use f='linux/drivers/md/dm-region-hash.c' l='169' c='dm_region_hash_create'/>
<use f='linux/drivers/md/dm-region-hash.c' l='235' c='dm_region_hash_destroy'/>
<use f='linux/drivers/md/dm-region-hash.c' l='258' c='dm_rh_dirty_log'/>
<use f='linux/drivers/md/dm-region-hash.c' l='264' c='rh_hash'/>
<use f='linux/drivers/md/dm-region-hash.c' l='269' c='__rh_lookup'/>
<use f='linux/drivers/md/dm-region-hash.c' l='281' c='__rh_insert'/>
<use f='linux/drivers/md/dm-region-hash.c' l='286' c='__rh_alloc'/>
<use f='linux/drivers/md/dm-region-hash.c' l='322' c='__rh_find'/>
<use f='linux/drivers/md/dm-region-hash.c' l='336' c='dm_rh_get_state'/>
<use f='linux/drivers/md/dm-region-hash.c' l='364' c='complete_resync_work'/>
<use f='linux/drivers/md/dm-region-hash.c' l='393' c='dm_rh_mark_nosync'/>
<use f='linux/drivers/md/dm-region-hash.c' l='438' c='dm_rh_update_states'/>
<use f='linux/drivers/md/dm-region-hash.c' l='501' c='rh_inc'/>
<use f='linux/drivers/md/dm-region-hash.c' l='524' c='dm_rh_inc_pending'/>
<use f='linux/drivers/md/dm-region-hash.c' l='536' c='dm_rh_dec'/>
<use f='linux/drivers/md/dm-region-hash.c' l='585' c='__rh_recovery_prepare'/>
<use f='linux/drivers/md/dm-region-hash.c' l='620' c='dm_rh_recovery_prepare'/>
<use f='linux/drivers/md/dm-region-hash.c' l='643' c='dm_rh_recovery_start'/>
<use f='linux/drivers/md/dm-region-hash.c' l='661' c='dm_rh_recovery_end'/>
<use f='linux/drivers/md/dm-region-hash.c' l='676' c='dm_rh_recovery_in_flight'/>
<use f='linux/drivers/md/dm-region-hash.c' l='682' c='dm_rh_flush'/>
<use f='linux/drivers/md/dm-region-hash.c' l='688' c='dm_rh_delay'/>
<use f='linux/drivers/md/dm-region-hash.c' l='699' c='dm_rh_stop_recovery'/>
<use f='linux/drivers/md/dm-region-hash.c' l='709' c='dm_rh_start_recovery'/>
<size>208</size>
<doc f='linux/drivers/md/dm-region-hash.c' l='21'>/*-----------------------------------------------------------------
 * Region hash
 *
 * The mirror splits itself up into discrete regions.  Each
 * region can be in one of three states: clean, dirty,
 * nosync.  There is no need to put clean regions in the hash.
 *
 * In addition to being present in the hash table a region _may_
 * be present on one of three lists.
 *
 *   clean_regions: Regions on this list have no io pending to
 *   them, they are in sync, we are no longer interested in them,
 *   they are dull.  dm_rh_update_states() will remove them from the
 *   hash table.
 *
 *   quiesced_regions: These regions have been spun down, ready
 *   for recovery.  rh_recovery_start() will remove regions from
 *   this list and hand them to kmirrord, which will schedule the
 *   recovery io with kcopyd.
 *
 *   recovered_regions: Regions that kcopyd has successfully
 *   recovered.  dm_rh_update_states() will now schedule any delayed
 *   io, up the recovery_count, and remove the region from the
 *   hash.
 *
 * There are 2 locks:
 *   A rw spin lock &apos;hash_lock&apos; protects just the hash table,
 *   this is never held in write mode from interrupt context,
 *   which I believe means that we only have to disable irqs when
 *   doing a write lock.
 *
 *   An ordinary spin lock &apos;region_lock&apos; that protects the three
 *   lists in the region_hash, with the &apos;state&apos;, &apos;list&apos; and
 *   &apos;delayed_bios&apos; fields of the regions.  This is used from irq
 *   context, so all other uses will have to suspend local irqs.
 *---------------------------------------------------------------*/</doc>
<mbr r='dm_region_hash::region_size' o='0' t='uint32_t'/>
<mbr r='dm_region_hash::region_shift' o='32' t='unsigned int'/>
<mbr r='dm_region_hash::log' o='64' t='struct dm_dirty_log *'/>
<mbr r='dm_region_hash::hash_lock' o='128' t='rwlock_t'/>
<mbr r='dm_region_hash::region_pool' o='192' t='mempool_t *'/>
<mbr r='dm_region_hash::mask' o='256' t='unsigned int'/>
<mbr r='dm_region_hash::nr_buckets' o='288' t='unsigned int'/>
<mbr r='dm_region_hash::prime' o='320' t='unsigned int'/>
<mbr r='dm_region_hash::shift' o='352' t='unsigned int'/>
<mbr r='dm_region_hash::buckets' o='384' t='struct list_head *'/>
<mbr r='dm_region_hash::max_recovery' o='448' t='unsigned int'/>
<mbr r='dm_region_hash::region_lock' o='480' t='spinlock_t'/>
<mbr r='dm_region_hash::recovery_in_flight' o='512' t='atomic_t'/>
<mbr r='dm_region_hash::recovery_count' o='576' t='struct semaphore'/>
<mbr r='dm_region_hash::clean_regions' o='768' t='struct list_head'/>
<mbr r='dm_region_hash::quiesced_regions' o='896' t='struct list_head'/>
<mbr r='dm_region_hash::recovered_regions' o='1024' t='struct list_head'/>
<mbr r='dm_region_hash::failed_recovered_regions' o='1152' t='struct list_head'/>
<mbr r='dm_region_hash::flush_failure' o='1280' t='int'/>
<mbr r='dm_region_hash::context' o='1344' t='void *'/>
<mbr r='dm_region_hash::target_begin' o='1408' t='sector_t'/>
<mbr r='dm_region_hash::dispatch_bios' o='1472' t='void (*)(void *, struct bio_list *)'/>
<mbr r='dm_region_hash::wakeup_workers' o='1536' t='void (*)(void *)'/>
<mbr r='dm_region_hash::wakeup_all_recovery_waiters' o='1600' t='void (*)(void *)'/>
