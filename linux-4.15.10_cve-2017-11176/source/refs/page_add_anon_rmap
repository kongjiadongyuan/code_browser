<dec f='linux/include/linux/rmap.h' l='173' type='void page_add_anon_rmap(struct page * , struct vm_area_struct * , unsigned long , bool )'/>
<use f='linux/mm/migrate.c' l='270' u='c' c='remove_migration_pte'/>
<def f='linux/mm/rmap.c' l='1086' ll='1090' type='void page_add_anon_rmap(struct page * page, struct vm_area_struct * vma, unsigned long address, bool compound)'/>
<doc f='linux/mm/rmap.c' l='1074'>/**
 * page_add_anon_rmap - add pte mapping to an anonymous page
 * @page:	the page to add the mapping to
 * @vma:	the vm area in which the mapping is added
 * @address:	the user virtual address mapped
 * @compound:	charge the page as compound or small page
 *
 * The caller needs to hold the pte lock, and the page must be locked in
 * the anon_vma case: to serialize mapping,index checking after setting,
 * and to ensure that PageAnon is not being upgraded racily to PageKsm
 * (but PageKsm is never downgraded to PageAnon).
 */</doc>
<use f='linux/mm/swapfile.c' l='1806' u='c' c='unuse_pte'/>
