<dec f='linux/drivers/gpu/drm/i915/i915_drv.h' l='1627' type='unsigned long'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.h' l='3723' c='i915_reset_count'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.h' l='3723' u='a' c='i915_reset_count'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.h' l='3723' u='r' c='i915_reset_count'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.h' l='3723' u='a' c='i915_reset_count'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.h' l='3723' u='r' c='i915_reset_count'/>
<offset>960</offset>
<doc f='linux/drivers/gpu/drm/i915/i915_drv.h' l='1605'>/**
	 * State variable controlling the reset flow and count
	 *
	 * This is a counter which gets incremented when reset is triggered,
	 *
	 * Before the reset commences, the I915_RESET_BACKOFF bit is set
	 * meaning that any waiters holding onto the struct_mutex should
	 * relinquish the lock immediately in order for the reset to start.
	 *
	 * If reset is not completed succesfully, the I915_WEDGE bit is
	 * set meaning that hardware is terminally sour and there is no
	 * recovery. All waiters on the reset_queue will be woken when
	 * that happens.
	 *
	 * This counter is used by the wait_seqno code to notice that reset
	 * event happened and it needs to restart the entire ioctl (since most
	 * likely the seqno it waited for won&apos;t ever signal anytime soon).
	 *
	 * This is important for lock-free wait paths, where no contended lock
	 * naturally enforces the correct ordering between the bail-out of the
	 * waiter and the gpu reset work code.
	 */</doc>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='1892' u='w' c='i915_reset'/>
