<dec f='glibc/sysdeps/generic/ldsodefs.h' l='983' type='void _dl_debug_state()'/>
<doc f='glibc/sysdeps/generic/ldsodefs.h' l='979'>/* The dynamic linker calls this function before and having changing
   any shared object mappings.  The `r_state&apos; member of `struct r_debug&apos;
   says what change is taking place.  This function&apos;s address is
   the value of the `r_brk&apos; member.  */</doc>
<use f='glibc/elf/dl-close.c' l='492' u='c' c='_dl_close_worker'/>
<use f='glibc/elf/dl-close.c' l='793' u='c' c='_dl_close_worker'/>
<use f='glibc/elf/dl-debug.c' l='60' u='a' c='_dl_debug_initialize'/>
<def f='glibc/elf/dl-debug.c' l='71' ll='74' type='void _dl_debug_state()'/>
<doc f='glibc/elf/dl-debug.c' l='67'>/* This function exists solely to have a breakpoint set on it by the
   debugger.  The debugger is supposed to find this function&apos;s address by
   examining the r_brk member of struct r_debug, but GDB 4.15 in fact looks
   for this particular symbol name in the PT_INTERP file.  */</doc>
<use f='glibc/elf/dl-load.c' l='847' u='c' c='lose'/>
<use f='glibc/elf/dl-load.c' l='993' u='c' c='_dl_map_object_from_fd'/>
<use f='glibc/elf/dl-open.c' l='292' u='c' c='dl_open_worker'/>
