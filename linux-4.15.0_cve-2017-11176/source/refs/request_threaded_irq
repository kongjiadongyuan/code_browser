<dec f='linux/include/linux/interrupt.h' l='141' type='int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long flags, const char * name, void * dev)'/>
<use f='linux/include/linux/interrupt.h' l='149' u='c' c='request_irq'/>
<use f='linux/drivers/base/power/wakeirq.c' l='200' u='c' c='dev_pm_set_dedicated_wake_irq'/>
<use f='linux/drivers/iommu/amd_iommu_init.c' l='1888' u='c' c='iommu_setup_msi'/>
<use f='linux/drivers/net/phy/phy.c' l='693' u='c' c='phy_start_interrupts'/>
<use f='linux/drivers/pci/irq.c' l='95' u='c' c='pci_request_irq'/>
<use f='linux/kernel/irq/devres.c' l='66' u='c' c='devm_request_threaded_irq'/>
<def f='linux/kernel/irq/manage.c' l='1741' ll='1824' type='int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char * devname, void * dev_id)'/>
<dec f='linux/kernel/irq/manage.c' l='1825' type='int request_threaded_irq(unsigned int , irq_handler_t , irq_handler_t , unsigned long , const char * , void * )'/>
<use f='linux/kernel/irq/manage.c' l='1825' c='request_threaded_irq'/>
<use f='linux/kernel/irq/manage.c' l='1825' u='a'/>
<use f='linux/kernel/irq/manage.c' l='1825' u='a'/>
<use f='linux/kernel/irq/manage.c' l='1858' u='c' c='request_any_context_irq'/>
<doc f='linux/kernel/irq/manage.c' l='1699'>/**
 *	request_threaded_irq - allocate an interrupt line
 *	@irq: Interrupt line to allocate
 *	@handler: Function to be called when the IRQ occurs.
 *		  Primary handler for threaded interrupts
 *		  If NULL and thread_fn != NULL the default
 *		  primary handler is installed
 *	@thread_fn: Function called from the irq handler thread
 *		    If NULL, no irq thread is created
 *	@irqflags: Interrupt type flags
 *	@devname: An ascii name for the claiming device
 *	@dev_id: A cookie passed back to the handler function
 *
 *	This call allocates interrupt resources and enables the
 *	interrupt line and IRQ handling. From the point this
 *	call is made your handler function may be invoked. Since
 *	your handler function must clear any interrupt the board
 *	raises, you must take care both to initialise your hardware
 *	and to set up the interrupt handler in the right order.
 *
 *	If you want to set up a threaded irq handler for your device
 *	then you need to supply @handler and @thread_fn. @handler is
 *	still called in hard interrupt context and has to check
 *	whether the interrupt originates from the device. If yes it
 *	needs to disable the interrupt on the device and return
 *	IRQ_WAKE_THREAD which will wake up the handler thread and run
 *	@thread_fn. This split handler design is necessary to support
 *	shared interrupts.
 *
 *	Dev_id must be globally unique. Normally the address of the
 *	device data structure is used as the cookie. Since the handler
 *	receives this value it makes sense to use it.
 *
 *	If your interrupt is shared you must pass a non NULL dev_id
 *	as this is required when freeing the interrupt.
 *
 *	Flags:
 *
 *	IRQF_SHARED		Interrupt is shared
 *	IRQF_TRIGGER_*		Specify active edge(s) or level
 *
 */</doc>
