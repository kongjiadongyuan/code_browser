<dec f='linux/drivers/cpufreq/cpufreq_governor.h' l='182' type='ssize_t store_sampling_rate(struct gov_attr_set * attr_set, const char * buf, size_t count)'/>
<def f='linux/drivers/cpufreq/cpufreq_governor.c' l='47' ll='85' type='ssize_t store_sampling_rate(struct gov_attr_set * attr_set, const char * buf, size_t count)'/>
<dec f='linux/drivers/cpufreq/cpufreq_governor.c' l='86' type='ssize_t store_sampling_rate(struct gov_attr_set * , const char * , size_t )'/>
<use f='linux/drivers/cpufreq/cpufreq_governor.c' l='86' c='store_sampling_rate'/>
<use f='linux/drivers/cpufreq/cpufreq_governor.c' l='86' u='a'/>
<use f='linux/drivers/cpufreq/cpufreq_governor.c' l='86' u='a'/>
<doc f='linux/drivers/cpufreq/cpufreq_governor.c' l='32'>/**
 * store_sampling_rate - update sampling rate effective immediately if needed.
 *
 * If new rate is smaller than the old, simply updating
 * dbs.sampling_rate might not be appropriate. For example, if the
 * original sampling_rate was 1 second and the requested new sampling rate is 10
 * ms because the user needs immediate reaction from ondemand governor, but not
 * sure if higher frequency will be required or not, then, the governor may
 * change the sampling rate too late; up to 1 second later. Thus, if we are
 * reducing the sampling rate, we need to make the new value effective
 * immediately.
 *
 * This must be called with dbs_data-&gt;mutex held, otherwise traversing
 * policy_dbs_list isn&apos;t safe.
 */</doc>
<use f='linux/drivers/cpufreq/cpufreq_ondemand.c' l='325' macro='1' u='r'/>
<use f='linux/drivers/cpufreq/cpufreq_ondemand.c' l='325' macro='1' u='r'/>
