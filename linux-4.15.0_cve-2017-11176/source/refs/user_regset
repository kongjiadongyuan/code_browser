<use f='linux/include/linux/regset.h' l='40'/>
<use f='linux/include/linux/regset.h' l='59'/>
<use f='linux/include/linux/regset.h' l='80'/>
<use f='linux/include/linux/regset.h' l='106'/>
<use f='linux/include/linux/regset.h' l='129'/>
<def f='linux/include/linux/regset.h' l='190' ll='201'/>
<use f='linux/include/linux/regset.h' l='223'/>
<use f='linux/include/linux/regset.h' l='374' c='copy_regset_to_user'/>
<use f='linux/include/linux/regset.h' l='400' c='copy_regset_from_user'/>
<use f='linux/include/linux/regset.h' l='420' c='regset_size'/>
<size>64</size>
<doc f='linux/include/linux/regset.h' l='131'>/**
 * struct user_regset - accessible thread CPU state
 * @n:			Number of slots (registers).
 * @size:		Size in bytes of a slot (register).
 * @align:		Required alignment, in bytes.
 * @bias:		Bias from natural indexing.
 * @core_note_type:	ELF note @n_type value used in core dumps.
 * @get:		Function to fetch values.
 * @set:		Function to store values.
 * @active:		Function to report if regset is active, or %NULL.
 * @writeback:		Function to write data back to user memory, or %NULL.
 * @get_size:		Function to return the regset&apos;s size, or %NULL.
 *
 * This data structure describes a machine resource we call a register set.
 * This is part of the state of an individual thread, not necessarily
 * actual CPU registers per se.  A register set consists of a number of
 * similar slots, given by @n.  Each slot is @size bytes, and aligned to
 * @align bytes (which is at least @size).  For dynamically-sized
 * regsets, @n must contain the maximum possible number of slots for the
 * regset, and @get_size must point to a function that returns the
 * current regset size.
 *
 * Callers that need to know only the current size of the regset and do
 * not care about its internal structure should call regset_size()
 * instead of inspecting @n or calling @get_size.
 *
 * For backward compatibility, the @get and @set methods must pad to, or
 * accept, @n * @size bytes, even if the current regset size is smaller.
 * The precise semantics of these operations depend on the regset being
 * accessed.
 *
 * The functions to which &amp;struct user_regset members point must be
 * called only on the current thread or on a thread that is in
 * %TASK_STOPPED or %TASK_TRACED state, that we are guaranteed will not
 * be woken up and return to user mode, and that we have called
 * wait_task_inactive() on.  (The target thread always might wake up for
 * SIGKILL while these functions are working, in which case that
 * thread&apos;s user_regset state might be scrambled.)
 *
 * The @pos argument must be aligned according to @align; the @count
 * argument must be a multiple of @size.  These functions are not
 * responsible for checking for invalid arguments.
 *
 * When there is a natural value to use as an index, @bias gives the
 * difference between the natural index and the slot index for the
 * register set.  For example, x86 GDT segment descriptors form a regset;
 * the segment selector produces a natural index, but only a subset of
 * that index space is available as a regset (the TLS slots); subtracting
 * @bias from a segment selector index value computes the regset slot.
 *
 * If nonzero, @core_note_type gives the n_type field (NT_* value)
 * of the core file note in which this regset&apos;s data appears.
 * NT_PRSTATUS is a special case in that the regset data starts at
 * offsetof(struct elf_prstatus, pr_reg) into the note data; that is
 * part of the per-machine ELF formats userland knows about.  In
 * other cases, the core file note contains exactly the whole regset
 * (@n * @size) and nothing else.  The core file note is normally
 * omitted when there is an @active function and it returns zero.
 */</doc>
<mbr r='user_regset::get' o='0' t='user_regset_get_fn *'/>
<mbr r='user_regset::set' o='64' t='user_regset_set_fn *'/>
<mbr r='user_regset::active' o='128' t='user_regset_active_fn *'/>
<mbr r='user_regset::writeback' o='192' t='user_regset_writeback_fn *'/>
<mbr r='user_regset::get_size' o='256' t='user_regset_get_size_fn *'/>
<mbr r='user_regset::n' o='320' t='unsigned int'/>
<mbr r='user_regset::size' o='352' t='unsigned int'/>
<mbr r='user_regset::align' o='384' t='unsigned int'/>
<mbr r='user_regset::bias' o='416' t='unsigned int'/>
<mbr r='user_regset::core_note_type' o='448' t='unsigned int'/>
<use f='linux/arch/x86/kernel/fpu/regset.c' l='16' c='regset_fpregs_active'/>
<use f='linux/arch/x86/kernel/fpu/regset.c' l='23' c='regset_xregset_fpregs_active'/>
<use f='linux/arch/x86/kernel/fpu/regset.c' l='33' c='xfpregs_get'/>
<use f='linux/arch/x86/kernel/fpu/regset.c' l='49' c='xfpregs_set'/>
<use f='linux/arch/x86/kernel/fpu/regset.c' l='80' c='xstateregs_get'/>
<use f='linux/arch/x86/kernel/fpu/regset.c' l='117' c='xstateregs_set'/>
<use f='linux/arch/x86/kernel/fpu/regset.c' l='300' c='fpregs_get'/>
<use f='linux/arch/x86/kernel/fpu/regset.c' l='329' c='fpregs_set'/>
<size>64</size>
<use f='linux/arch/x86/kernel/ptrace.c' l='458' c='genregs_get'/>
<use f='linux/arch/x86/kernel/ptrace.c' l='483' c='genregs_set'/>
<use f='linux/arch/x86/kernel/ptrace.c' l='732' c='ioperm_active'/>
<use f='linux/arch/x86/kernel/ptrace.c' l='738' c='ioperm_get'/>
<use f='linux/arch/x86/kernel/ptrace.c' l='1027' c='genregs32_get'/>
<use f='linux/arch/x86/kernel/ptrace.c' l='1054' c='genregs32_set'/>
<use f='linux/arch/x86/kernel/ptrace.c' l='1254'/>
<use f='linux/arch/x86/kernel/ptrace.c' l='1295'/>
<size>64</size>
<use f='linux/arch/x86/kernel/tls.c' l='244' c='regset_tls_active'/>
<use f='linux/arch/x86/kernel/tls.c' l='253' c='regset_tls_get'/>
<use f='linux/arch/x86/kernel/tls.c' l='287' c='regset_tls_set'/>
<size>64</size>
<use f='linux/fs/binfmt_elf.c' l='1694' c='do_thread_regset_writeback'/>
<use f='linux/fs/binfmt_elf.c' l='1737' c='fill_thread_core_info'/>
<size>64</size>
<use f='linux/kernel/ptrace.c' l='838' c='find_regset'/>
<use f='linux/kernel/ptrace.c' l='841' c='find_regset'/>
<use f='linux/kernel/ptrace.c' l='857' c='ptrace_regset'/>
<size>64</size>
