<dec f='linux/drivers/usb/core/usb.h' l='85' type='int usb_port_resume(struct usb_device * dev, pm_message_t msg)'/>
<use f='linux/drivers/usb/core/generic.c' l='234' u='c' c='generic_resume'/>
<def f='linux/drivers/usb/core/hub.c' l='3397' ll='3482' type='int usb_port_resume(struct usb_device * udev, pm_message_t msg)'/>
<doc f='linux/drivers/usb/core/hub.c' l='3363'>/*
 * usb_port_resume - re-activate a suspended usb device&apos;s upstream port
 * @udev: device to re-activate, not a root hub
 * Context: must be able to sleep; device not locked; pm locks held
 *
 * This will re-activate the suspended device, increasing power usage
 * while letting drivers communicate again with its endpoints.
 * USB resume explicitly guarantees that the power session between
 * the host and the device is the same as it was when the device
 * suspended.
 *
 * If @udev-&gt;reset_resume is set then this routine won&apos;t check that the
 * port is still enabled.  Furthermore, finish_port_resume() above will
 * reset @udev.  The end result is that a broken power session can be
 * recovered and @udev will appear to persist across a loss of VBUS power.
 *
 * For example, if a host controller doesn&apos;t maintain VBUS suspend current
 * during a system sleep or is reset when the system wakes up, all the USB
 * power sessions below it will be broken.  This is especially troublesome
 * for mass-storage devices containing mounted filesystems, since the
 * device will appear to have disconnected and all the memory mappings
 * to it will be lost.  Using the USB_PERSIST facility, the device can be
 * made to appear as if it had not disconnected.
 *
 * This facility can be dangerous.  Although usb_reset_and_verify_device() makes
 * every effort to insure that the same device is present after the
 * reset as before, it cannot provide a 100% guarantee.  Furthermore it&apos;s
 * quite possible for a device to remain unaltered but its media to be
 * changed.  If the user replaces a flash memory card while the system is
 * asleep, he will have only himself to blame when the filesystem on the
 * new card is corrupted and the system crashes.
 *
 * Returns 0 on success, else negative errno.
 */</doc>
