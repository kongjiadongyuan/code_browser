<dec f='linux/include/linux/usb.h' l='1688' type='void usb_kill_urb(struct urb * urb)'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='748' u='c' c='usbhid_close'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='776' u='c' c='usbhid_init_reports'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='778' u='c' c='usbhid_init_reports'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='1202' u='c' c='usbhid_stop'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='1203' u='c' c='usbhid_stop'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='1204' u='c' c='usbhid_stop'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='1419' u='c' c='hid_cease_io'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='1420' u='c' c='hid_cease_io'/>
<use f='linux/drivers/hid/usbhid/hid-core.c' l='1421' u='c' c='hid_cease_io'/>
<use f='linux/drivers/usb/core/devio.c' l='642' u='c' c='destroy_async'/>
<use f='linux/drivers/usb/core/devio.c' l='1821' u='c' c='proc_unlinkurb'/>
<use f='linux/drivers/usb/core/hcd.c' l='1931' u='c' c='usb_hcd_flush_endpoint'/>
<use f='linux/drivers/usb/core/hub.c' l='1260' u='c' c='hub_quiesce'/>
<use f='linux/drivers/usb/core/message.c' l='62' u='c' c='usb_start_wait_urb'/>
<def f='linux/drivers/usb/core/urb.c' l='683' ll='694' type='void usb_kill_urb(struct urb * urb)'/>
<dec f='linux/drivers/usb/core/urb.c' l='695' type='void usb_kill_urb(struct urb * )'/>
<use f='linux/drivers/usb/core/urb.c' l='695' c='usb_kill_urb'/>
<use f='linux/drivers/usb/core/urb.c' l='695' u='a'/>
<use f='linux/drivers/usb/core/urb.c' l='695' u='a'/>
<use f='linux/drivers/usb/core/urb.c' l='791' u='c' c='usb_kill_anchored_urbs'/>
<doc f='linux/drivers/usb/core/urb.c' l='656'>/**
 * usb_kill_urb - cancel a transfer request and wait for it to finish
 * @urb: pointer to URB describing a previously submitted request,
 *	may be NULL
 *
 * This routine cancels an in-progress request.  It is guaranteed that
 * upon return all completion handlers will have finished and the URB
 * will be totally idle and available for reuse.  These features make
 * this an ideal way to stop I/O in a disconnect() callback or close()
 * function.  If the request has not already finished or been unlinked
 * the completion handler will see urb-&gt;status == -ENOENT.
 *
 * While the routine is running, attempts to resubmit the URB will fail
 * with error -EPERM.  Thus even if the URB&apos;s completion handler always
 * tries to resubmit, it will not succeed and the URB will become idle.
 *
 * The URB must not be deallocated while this routine is running.  In
 * particular, when a driver calls this routine, it must insure that the
 * completion handler cannot deallocate the URB.
 *
 * This routine may not be used in an interrupt context (such as a bottom
 * half or a completion handler), or when holding a spinlock, or in other
 * situations where the caller can&apos;t schedule().
 *
 * This routine should not be called by a driver after its disconnect
 * method has returned.
 */</doc>
<use f='linux/drivers/usb/storage/transport.c' l='177' u='c' c='usb_stor_msg_common'/>
