<dec f='linux/arch/x86/include/asm/text-patching.h' l='21' type='void * text_poke_early(void * addr, const void * opcode, size_t len)'/>
<dec f='linux/arch/x86/kernel/alternative.c' l='262' type='void * text_poke_early(void * addr, const void * opcode, size_t len)'/>
<use f='linux/arch/x86/kernel/alternative.c' l='427' u='c' c='apply_alternatives'/>
<def f='linux/arch/x86/kernel/alternative.c' l='664' ll='674' type='void * text_poke_early(void * addr, const void * opcode, size_t len)'/>
<doc f='linux/arch/x86/kernel/alternative.c' l='652'>/**
 * text_poke_early - Update instructions on a live kernel at boot time
 * @addr: address to modify
 * @opcode: source of the copy
 * @len: length to copy
 *
 * When you use this code to patch more than one byte of an instruction
 * you need to make sure that other CPUs cannot execute this code in parallel.
 * Also no thread must be currently preempted in the middle of these
 * instructions. And on the local CPU you need to be protected again NMI or MCE
 * handlers seeing an inconsistent instruction while you patch.
 */</doc>
<use f='linux/arch/x86/kernel/jump_label.c' l='140' u='r' c='arch_jump_label_transform_static'/>
