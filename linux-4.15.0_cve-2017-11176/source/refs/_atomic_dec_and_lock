<dec f='linux/include/linux/spinlock.h' l='408' type='int _atomic_dec_and_lock(atomic_t * atomic, spinlock_t * lock)'/>
<doc f='linux/include/linux/spinlock.h' l='400'>/**
 * atomic_dec_and_lock - lock on reaching reference count zero
 * @atomic: the atomic counter
 * @lock: the spinlock in question
 *
 * Decrements @atomic by 1.  If the result is 0, returns true and locks
 * @lock.  Returns false for all other cases.
 */</doc>
<use f='linux/drivers/md/md.c' l='515' macro='1' u='c' c='mddev_put'/>
<use f='linux/fs/inode.c' l='1533' macro='1' u='c' c='iput'/>
<use f='linux/fs/lockd/clntproc.c' l='57' macro='1' u='c' c='nlm_put_lockowner'/>
<use f='linux/fs/lockd/mon.c' l='407' macro='1' u='c' c='nsm_release'/>
<use f='linux/fs/nfs/nfs4state.c' l='610' macro='1' u='c' c='nfs4_put_state_owner'/>
<use f='linux/fs/nfs/nfs4state.c' l='740' macro='1' u='c' c='nfs4_put_open_state'/>
<use f='linux/kernel/user.c' l='172' macro='1' u='c' c='free_uid'/>
<def f='linux/lib/dec_and_lock.c' l='21' ll='33' type='int _atomic_dec_and_lock(atomic_t * atomic, spinlock_t * lock)'/>
<dec f='linux/lib/dec_and_lock.c' l='35' type='int _atomic_dec_and_lock(atomic_t * , spinlock_t * )'/>
<use f='linux/lib/dec_and_lock.c' l='35' c='_atomic_dec_and_lock'/>
<use f='linux/lib/dec_and_lock.c' l='35' u='a'/>
<use f='linux/lib/dec_and_lock.c' l='35' u='a'/>
<doc f='linux/lib/dec_and_lock.c' l='6'>/*
 * This is an implementation of the notion of &quot;decrement a
 * reference count, and return locked if it decremented to zero&quot;.
 *
 * NOTE NOTE NOTE! This is _not_ equivalent to
 *
 *	if (atomic_dec_and_test(&amp;atomic)) {
 *		spin_lock(&amp;lock);
 *		return 1;
 *	}
 *	return 0;
 *
 * because the spin-lock and the decrement must be
 * &quot;atomic&quot;.
 */</doc>
<use f='linux/net/sunrpc/auth.c' l='723' macro='1' u='c' c='put_rpccred'/>
<use f='linux/net/sunrpc/auth_gss/auth_gss.c' l='321' macro='1' u='c' c='put_pipe_version'/>
