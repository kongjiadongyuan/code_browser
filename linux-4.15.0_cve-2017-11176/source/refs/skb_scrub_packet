<dec f='linux/include/linux/skbuff.h' l='3282' type='void skb_scrub_packet(struct sk_buff * skb, bool xnet)'/>
<use f='linux/include/linux/netdevice.h' l='3350' u='c' c='____dev_forward_skb'/>
<use f='linux/include/net/dst.h' l='369' u='c' c='__skb_tunnel_rx'/>
<def f='linux/net/core/skbuff.c' l='4858' ll='4875' type='void skb_scrub_packet(struct sk_buff * skb, bool xnet)'/>
<dec f='linux/net/core/skbuff.c' l='4876' type='void skb_scrub_packet(struct sk_buff * , bool )'/>
<use f='linux/net/core/skbuff.c' l='4876' c='skb_scrub_packet'/>
<use f='linux/net/core/skbuff.c' l='4876' u='a'/>
<use f='linux/net/core/skbuff.c' l='4876' u='a'/>
<doc f='linux/net/core/skbuff.c' l='4845'>/**
 * skb_scrub_packet - scrub an skb
 *
 * @skb: buffer to clean
 * @xnet: packet is crossing netns
 *
 * skb_scrub_packet can be used after encapsulating or decapsulting a packet
 * into/from a tunnel. Some information have to be cleared during these
 * operations.
 * skb_scrub_packet can also be used to clean a skb before injecting it in
 * another namespace (@xnet == true). We have to clear all information in the
 * skb that could impact namespace isolation.
 */</doc>
<use f='linux/net/ipv4/ip_tunnel.c' l='433' u='c' c='ip_tunnel_rcv'/>
<use f='linux/net/ipv4/ip_tunnel_core.c' l='69' u='c' c='iptunnel_xmit'/>
<use f='linux/net/ipv4/ip_tunnel_core.c' l='125' u='c' c='__iptunnel_pull_header'/>
