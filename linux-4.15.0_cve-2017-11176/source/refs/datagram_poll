<dec f='linux/include/linux/skbuff.h' l='3244' type='unsigned int datagram_poll(struct file * file, struct socket * sock, struct poll_table_struct * wait)'/>
<def f='linux/net/core/datagram.c' l='836' ll='875' type='unsigned int datagram_poll(struct file * file, struct socket * sock, poll_table * wait)'/>
<dec f='linux/net/core/datagram.c' l='876' type='unsigned int datagram_poll(struct file * , struct socket * , struct poll_table_struct * )'/>
<use f='linux/net/core/datagram.c' l='876' c='datagram_poll'/>
<use f='linux/net/core/datagram.c' l='876' u='a'/>
<use f='linux/net/core/datagram.c' l='876' u='a'/>
<doc f='linux/net/core/datagram.c' l='822'>/**
 * 	datagram_poll - generic datagram poll
 *	@file: file struct
 *	@sock: socket
 *	@wait: poll table
 *
 *	Datagram poll: Again totally generic. This also handles
 *	sequenced packet sockets providing the socket receive queue
 *	is only ever holding data ready to receive.
 *
 *	Note: when you *don&apos;t* use this routine for this protocol,
 *	and you use a different write policy from sock_writeable()
 *	then please supply your own write_space callback.
 */</doc>
<use f='linux/net/ipv4/af_inet.c' l='1001'/>
<use f='linux/net/ipv4/af_inet.c' l='1001'/>
<use f='linux/net/ipv4/udp.c' l='2512' u='c' c='udp_poll'/>
<use f='linux/net/ipv6/raw.c' l='1357'/>
<use f='linux/net/ipv6/raw.c' l='1357'/>
<use f='linux/net/netlink/af_netlink.c' l='2639'/>
<use f='linux/net/netlink/af_netlink.c' l='2639'/>
<use f='linux/net/packet/af_packet.c' l='4081' u='c' c='packet_poll'/>
<use f='linux/net/packet/af_packet.c' l='4426'/>
<use f='linux/net/packet/af_packet.c' l='4426'/>
