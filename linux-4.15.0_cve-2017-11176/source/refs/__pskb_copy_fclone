<dec f='linux/include/linux/skbuff.h' l='1032' type='struct sk_buff * __pskb_copy_fclone(struct sk_buff * skb, int headroom, gfp_t gfp_mask, bool fclone)'/>
<use f='linux/include/linux/skbuff.h' l='1037' u='c' c='__pskb_copy'/>
<use f='linux/include/linux/skbuff.h' l='2848' u='c' c='pskb_copy_for_clone'/>
<def f='linux/net/core/skbuff.c' l='1377' ll='1422' type='struct sk_buff * __pskb_copy_fclone(struct sk_buff * skb, int headroom, gfp_t gfp_mask, bool fclone)'/>
<dec f='linux/net/core/skbuff.c' l='1423' type='struct sk_buff * __pskb_copy_fclone(struct sk_buff * , int , gfp_t , bool )'/>
<use f='linux/net/core/skbuff.c' l='1423' c='__pskb_copy_fclone'/>
<use f='linux/net/core/skbuff.c' l='1423' u='a'/>
<use f='linux/net/core/skbuff.c' l='1423' u='a'/>
<doc f='linux/net/core/skbuff.c' l='1360'>/**
 *	__pskb_copy_fclone	-  create copy of an sk_buff with private head.
 *	@skb: buffer to copy
 *	@headroom: headroom of new skb
 *	@gfp_mask: allocation priority
 *	@fclone: if true allocate the copy of the skb from the fclone
 *	cache instead of the head cache; it is recommended to set this
 *	to true for the cases where the copy will likely be cloned
 *
 *	Make a copy of both an &amp;sk_buff and part of its data, located
 *	in header. Fragmented data remain shared. This is used when
 *	the caller wishes to modify only header of &amp;sk_buff and needs
 *	private copy of the header to alter. Returns %NULL on failure
 *	or the pointer to the buffer on success.
 *	The returned buffer has a reference count of 1.
 */</doc>
