<dec f='linux/drivers/usb/core/usb.h' l='88' type='int usb_autoresume_device(struct usb_device * udev)'/>
<use f='linux/drivers/usb/core/devio.c' l='1001' u='c' c='usbdev_open'/>
<use f='linux/drivers/usb/core/driver.c' l='263' u='c' c='usb_probe_device'/>
<use f='linux/drivers/usb/core/driver.c' l='316' u='c' c='usb_probe_interface'/>
<use f='linux/drivers/usb/core/driver.c' l='406' u='c' c='usb_unbind_interface'/>
<def f='linux/drivers/usb/core/driver.c' l='1603' ll='1616' type='int usb_autoresume_device(struct usb_device * udev)'/>
<doc f='linux/drivers/usb/core/driver.c' l='1583'>/**
 * usb_autoresume_device - immediately autoresume a USB device and its interfaces
 * @udev: the usb_device to autoresume
 *
 * This routine should be called when a core subsystem wants to use @udev
 * and needs to guarantee that it is not suspended.  No autosuspend will
 * occur until usb_autosuspend_device() is called.  (Note that this will
 * not prevent suspend events originating in the PM core.)  Examples would
 * be when @udev&apos;s device file in usbfs is opened or when a remote-wakeup
 * request is received.
 *
 * @udev&apos;s usage counter is incremented to prevent subsequent autosuspends.
 * However if the autoresume fails then the usage counter is re-decremented.
 *
 * The caller must hold @udev&apos;s device lock.
 *
 * This routine can run only in process context.
 *
 * Return: 0 on success. A negative error code otherwise.
 */</doc>
<use f='linux/drivers/usb/core/hub.c' l='2533' u='c' c='usb_authorize_device'/>
<use f='linux/drivers/usb/core/hub.c' l='3491' u='c' c='usb_remote_wakeup'/>
<use f='linux/drivers/usb/core/hub.c' l='5661' u='c' c='usb_reset_device'/>
<use f='linux/drivers/usb/core/message.c' l='1824' u='c' c='usb_set_configuration'/>
