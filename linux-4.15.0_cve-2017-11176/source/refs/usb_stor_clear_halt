<dec f='linux/drivers/usb/storage/transport.h' l='78' type='int usb_stor_clear_halt(struct us_data * us, unsigned int pipe)'/>
<def f='linux/drivers/usb/storage/transport.c' l='230' ll='248' type='int usb_stor_clear_halt(struct us_data * us, unsigned int pipe)'/>
<dec f='linux/drivers/usb/storage/transport.c' l='249' type='int usb_stor_clear_halt(struct us_data * , unsigned int )'/>
<use f='linux/drivers/usb/storage/transport.c' l='249' c='usb_stor_clear_halt'/>
<use f='linux/drivers/usb/storage/transport.c' l='249' u='a'/>
<use f='linux/drivers/usb/storage/transport.c' l='249' u='a'/>
<use f='linux/drivers/usb/storage/transport.c' l='290' u='c' c='interpret_urb_result'/>
<use f='linux/drivers/usb/storage/transport.c' l='1056' u='c' c='usb_stor_CB_transport'/>
<use f='linux/drivers/usb/storage/transport.c' l='1372' u='c' c='usb_stor_reset_common'/>
<use f='linux/drivers/usb/storage/transport.c' l='1375' u='c' c='usb_stor_reset_common'/>
<doc f='linux/drivers/usb/storage/transport.c' l='217'>/*
 * This is a version of usb_clear_halt() that allows early termination and
 * doesn&apos;t read the status from the device -- this is because some devices
 * crash their internal firmware when the status is requested after a halt.
 *
 * A definitive list of these &apos;bad&apos; devices is too difficult to maintain or
 * make complete enough to be useful.  This problem was first observed on the
 * Hagiwara FlashGate DUAL unit.  However, bus traces reveal that neither
 * MacOS nor Windows checks the status after clearing a halt.
 *
 * Since many vendors in this space limit their testing to interoperability
 * with these two OSes, specification violations like this one are common.
 */</doc>
