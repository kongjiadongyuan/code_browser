<dec f='linux/include/linux/fs.h' l='3039' type='void inode_set_flags(struct inode * inode, unsigned int flags, unsigned int mask)'/>
<use f='linux/fs/efivarfs/file.c' l='152' u='c' c='efivarfs_ioc_setxflags'/>
<use f='linux/fs/ext4/inode.c' l='4670' u='c' c='ext4_set_inode_flags'/>
<use f='linux/fs/ext4/super.c' l='5479' u='c' c='ext4_quota_on'/>
<use f='linux/fs/ext4/super.c' l='5586' u='c' c='ext4_quota_off'/>
<def f='linux/fs/inode.c' l='2086' ll='2097' type='void inode_set_flags(struct inode * inode, unsigned int flags, unsigned int mask)'/>
<dec f='linux/fs/inode.c' l='2098' type='void inode_set_flags(struct inode * , unsigned int , unsigned int )'/>
<use f='linux/fs/inode.c' l='2098' c='inode_set_flags'/>
<use f='linux/fs/inode.c' l='2098' u='a'/>
<use f='linux/fs/inode.c' l='2098' u='a'/>
<doc f='linux/fs/inode.c' l='2070'>/*
 * inode_set_flags - atomically set some inode flags
 *
 * Note: the caller should be holding i_mutex, or else be sure that
 * they have exclusive access to the inode structure (i.e., while the
 * inode is being instantiated).  The reason for the cmpxchg() loop
 * --- which wouldn&apos;t be necessary if all code paths which modify
 * i_flags actually followed this rule, is that there is at least one
 * code path which doesn&apos;t today so we use cmpxchg() out of an abundance
 * of caution.
 *
 * In the long run, i_mutex is overkill, and we should probably look
 * at using the i_lock spinlock to protect i_flags, and then make sure
 * it is so documented in include/linux/fs.h and that all code follows
 * the locking convention!!
 */</doc>
