<dec f='linux/include/linux/time.h' l='21' type='time64_t mktime64(const unsigned int year, const unsigned int mon, const unsigned int day, const unsigned int hour, const unsigned int min, const unsigned int sec)'/>
<use f='linux/include/linux/time32.h' l='182' u='c' c='mktime'/>
<use f='linux/crypto/asymmetric_keys/x509_cert_parser.c' l='545' u='c' c='x509_decode_time'/>
<use f='linux/drivers/rtc/rtc-lib.c' l='121' u='c' c='rtc_tm_to_time64'/>
<use f='linux/fs/isofs/util.c' l='36' u='c' c='iso_date'/>
<def f='linux/kernel/time/time.c' l='389' ll='407' type='time64_t mktime64(const unsigned int year0, const unsigned int mon0, const unsigned int day, const unsigned int hour, const unsigned int min, const unsigned int sec)'/>
<dec f='linux/kernel/time/time.c' l='408' type='time64_t mktime64(const unsigned int , const unsigned int , const unsigned int , const unsigned int , const unsigned int , const unsigned int )'/>
<use f='linux/kernel/time/time.c' l='408' c='mktime64'/>
<use f='linux/kernel/time/time.c' l='408' u='a'/>
<use f='linux/kernel/time/time.c' l='408' u='a'/>
<doc f='linux/kernel/time/time.c' l='369'>/*
 * mktime64 - Converts date to seconds.
 * Converts Gregorian date to seconds since 1970-01-01 00:00:00.
 * Assumes input in normal date format, i.e. 1980-12-31 23:59:59
 * =&gt; year=1980, mon=12, day=31, hour=23, min=59, sec=59.
 *
 * [For the Julian calendar (which was used in Russia before 1917,
 * Britain &amp; colonies before 1752, anywhere else before 1582,
 * and is still in use by some communities) leave out the
 * -year/100+year/400 terms, and add 10.]
 *
 * This algorithm was first published by Gauss (I think).
 *
 * A leap second can be indicated by calling this function with sec as
 * 60 (allowable under ISO 8601).  The leap second is treated the same
 * as the following second since they don&apos;t exist in UNIX time.
 *
 * An encoding of midnight at the end of the day as 24:00:00 - ie. midnight
 * tomorrow - (allowable under ISO 8601) is supported.
 */</doc>
