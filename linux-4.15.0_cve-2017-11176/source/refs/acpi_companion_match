<dec f='linux/drivers/acpi/internal.h' l='123' type='struct acpi_device * acpi_companion_match(const struct device * dev)'/>
<doc f='linux/drivers/acpi/internal.h' l='120'>/* --------------------------------------------------------------------------
                     Device Matching and Notification
   -------------------------------------------------------------------------- */</doc>
<def f='linux/drivers/acpi/bus.c' l='638' ll='650' type='struct acpi_device * acpi_companion_match(const struct device * dev)'/>
<use f='linux/drivers/acpi/bus.c' l='811' u='c' c='acpi_match_device'/>
<use f='linux/drivers/acpi/bus.c' l='829' u='c' c='acpi_driver_match_device'/>
<doc f='linux/drivers/acpi/bus.c' l='617'>/*
 * acpi_companion_match() - Can we match via ACPI companion device
 * @dev: Device in question
 *
 * Check if the given device has an ACPI companion and if that companion has
 * a valid list of PNP IDs, and if the device is the first (primary) physical
 * device associated with it.  Return the companion pointer if that&apos;s the case
 * or NULL otherwise.
 *
 * If multiple physical devices are attached to a single ACPI companion, we need
 * to be careful.  The usage scenario for this kind of relationship is that all
 * of the physical devices in question use resources provided by the ACPI
 * companion.  A typical case is an MFD device where all the sub-devices share
 * the parent&apos;s ACPI companion.  In such cases we can only allow the primary
 * (first) physical device to be matched with the help of the companion&apos;s PNP
 * IDs.
 *
 * Additional physical devices sharing the ACPI companion can still use
 * resources available from it but they will be matched normally using functions
 * provided by their bus types (and analogously for their modalias).
 */</doc>
<use f='linux/drivers/acpi/device_sysfs.c' l='290' u='c' c='acpi_device_uevent_modalias'/>
<use f='linux/drivers/acpi/device_sysfs.c' l='335' u='c' c='acpi_device_modalias'/>
