<dec f='linux/include/linux/idr.h' l='251' type='int ida_get_new_above(struct ida * ida, int starting_id, int * p_id)'/>
<use f='linux/include/linux/idr.h' l='273' u='c' c='ida_get_new'/>
<use f='linux/fs/namespace.c' l='109' u='c' c='mnt_alloc_id'/>
<use f='linux/fs/namespace.c' l='141' u='c' c='mnt_alloc_group_id'/>
<use f='linux/fs/super.c' l='947' u='c' c='get_anon_bdev'/>
<def f='linux/lib/idr.c' l='258' ll='344' type='int ida_get_new_above(struct ida * ida, int start, int * id)'/>
<dec f='linux/lib/idr.c' l='345' type='int ida_get_new_above(struct ida * , int , int * )'/>
<use f='linux/lib/idr.c' l='345' c='ida_get_new_above'/>
<use f='linux/lib/idr.c' l='345' u='a'/>
<use f='linux/lib/idr.c' l='345' u='a'/>
<use f='linux/lib/idr.c' l='455' u='c' c='ida_simple_get'/>
<doc f='linux/lib/idr.c' l='240'>/**
 * ida_get_new_above - allocate new ID above or equal to a start id
 * @ida: ida handle
 * @start: id to start search at
 * @id: pointer to the allocated handle
 *
 * Allocate new ID above or equal to @start.  It should be called
 * with any required locks to ensure that concurrent calls to
 * ida_get_new_above() / ida_get_new() / ida_remove() are not allowed.
 * Consider using ida_simple_get() if you do not have complex locking
 * requirements.
 *
 * If memory is required, it will return %-EAGAIN, you should unlock
 * and go back to the ida_pre_get() call.  If the ida is full, it will
 * return %-ENOSPC.  On success, it will return 0.
 *
 * @id returns a value in the range @start ... %0x7fffffff.
 */</doc>
<use f='linux/net/core/net_namespace.c' l='944' u='c' c='register_pernet_operations'/>
