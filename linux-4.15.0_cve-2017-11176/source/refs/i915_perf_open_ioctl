<dec f='linux/drivers/gpu/drm/i915/i915_drv.h' l='3837' type='int i915_perf_open_ioctl(struct drm_device * dev, void * data, struct drm_file * file)'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2772'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2772'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2772'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2772'/>
<def f='linux/drivers/gpu/drm/i915/i915_perf.c' l='2833' ll='2867' type='int i915_perf_open_ioctl(struct drm_device * dev, void * data, struct drm_file * file)'/>
<doc f='linux/drivers/gpu/drm/i915/i915_perf.c' l='2809'>/**
 * i915_perf_open_ioctl - DRM ioctl() for userspace to open a stream FD
 * @dev: drm device
 * @data: ioctl data copied from userspace (unvalidated)
 * @file: drm file
 *
 * Validates the stream open parameters given by userspace including flags
 * and an array of u64 key, value pair properties.
 *
 * Very little is assumed up front about the nature of the stream being
 * opened (for instance we don&apos;t assume it&apos;s for periodic OA unit metrics). An
 * i915-perf stream is expected to be a suitable interface for other forms of
 * buffered data written by the GPU besides periodic OA metrics.
 *
 * Note we copy the properties from userspace outside of the i915 perf
 * mutex to avoid an awkward lockdep with mmap_sem.
 *
 * Most of the implementation details are handled by
 * i915_perf_open_ioctl_locked() after taking the &amp;drm_i915_private-&gt;perf.lock
 * mutex for serializing with any non-file-operation driver hooks.
 *
 * Return: A newly opened i915 Perf stream file descriptor or negative
 * error code on failure.
 */</doc>
