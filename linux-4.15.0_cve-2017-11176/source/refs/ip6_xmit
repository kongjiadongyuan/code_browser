<dec f='linux/include/net/ipv6.h' l='920' type='int ip6_xmit(const struct sock * sk, struct sk_buff * skb, struct flowi6 * fl6, __u32 mark, struct ipv6_txoptions * opt, int tclass)'/>
<doc f='linux/include/net/ipv6.h' l='917'>/*
 *	upper-layer output functions
 */</doc>
<use f='linux/net/ipv6/inet6_connection_sock.c' l='139' u='c' c='inet6_csk_xmit'/>
<def f='linux/net/ipv6/ip6_output.c' l='183' ll='283' type='int ip6_xmit(const struct sock * sk, struct sk_buff * skb, struct flowi6 * fl6, __u32 mark, struct ipv6_txoptions * opt, int tclass)'/>
<dec f='linux/net/ipv6/ip6_output.c' l='284' type='int ip6_xmit(const struct sock * , struct sk_buff * , struct flowi6 * , __u32 , struct ipv6_txoptions * , int )'/>
<use f='linux/net/ipv6/ip6_output.c' l='284' c='ip6_xmit'/>
<use f='linux/net/ipv6/ip6_output.c' l='284' u='a'/>
<use f='linux/net/ipv6/ip6_output.c' l='284' u='a'/>
<doc f='linux/net/ipv6/ip6_output.c' l='177'>/*
 * xmit an sk_buff (used by TCP, SCTP and DCCP)
 * Note : socket lock is not held for SYNACK packets, but might be modified
 * by calls to skb_set_owner_w() and ipv6_local_error(),
 * which are using proper atomic operations or spinlocks.
 */</doc>
<use f='linux/net/ipv6/tcp_ipv6.c' l='491' u='c' c='tcp_v6_send_synack'/>
<use f='linux/net/ipv6/tcp_ipv6.c' l='873' u='c' c='tcp_v6_send_response'/>
