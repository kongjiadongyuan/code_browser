<dec f='linux/lib/mpi/mpi-internal.h' l='224' type='mpi_limb_t mpihelp_divrem(mpi_ptr_t qp, mpi_size_t qextra_limbs, mpi_ptr_t np, mpi_size_t nsize, mpi_ptr_t dp, mpi_size_t dsize)'/>
<use f='linux/lib/mpi/mpi-pow.c' l='103' u='c' c='mpi_powm'/>
<use f='linux/lib/mpi/mpi-pow.c' l='220' u='c' c='mpi_powm'/>
<use f='linux/lib/mpi/mpi-pow.c' l='247' u='c' c='mpi_powm'/>
<use f='linux/lib/mpi/mpi-pow.c' l='290' u='c' c='mpi_powm'/>
<def f='linux/lib/mpi/mpih-div.c' l='57' ll='236' type='mpi_limb_t mpihelp_divrem(mpi_ptr_t qp, mpi_size_t qextra_limbs, mpi_ptr_t np, mpi_size_t nsize, mpi_ptr_t dp, mpi_size_t dsize)'/>
<doc f='linux/lib/mpi/mpih-div.c' l='40'>/* Divide num (NP/NSIZE) by den (DP/DSIZE) and write
 * the NSIZE-DSIZE least significant quotient limbs at QP
 * and the DSIZE long remainder at NP.	If QEXTRA_LIMBS is
 * non-zero, generate that many fraction bits and append them after the
 * other quotient limbs.
 * Return the most significant limb of the quotient, this is always 0 or 1.
 *
 * Preconditions:
 * 0. NSIZE &gt;= DSIZE.
 * 1. The most significant bit of the divisor must be set.
 * 2. QP must either not overlap with the input operands at all, or
 *    QP + DSIZE &gt;= NP must hold true.	(This means that it&apos;s
 *    possible to put the quotient in the high part of NUM, right after the
 *    remainder in NUM.
 * 3. NSIZE &gt;= DSIZE, even if QEXTRA_LIMBS is non-zero.
 */</doc>
