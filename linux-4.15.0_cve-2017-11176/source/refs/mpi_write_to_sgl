<dec f='linux/include/linux/mpi.h' l='83' type='int mpi_write_to_sgl(MPI a, struct scatterlist * sg, unsigned int nbytes, int * sign)'/>
<use f='linux/crypto/rsa.c' l='111' u='c' c='rsa_enc'/>
<use f='linux/crypto/rsa.c' l='150' u='c' c='rsa_dec'/>
<use f='linux/crypto/rsa.c' l='188' u='c' c='rsa_sign'/>
<use f='linux/crypto/rsa.c' l='229' u='c' c='rsa_verify'/>
<def f='linux/lib/mpi/mpicoder.c' l='247' ll='314' type='int mpi_write_to_sgl(MPI a, struct scatterlist * sgl, unsigned int nbytes, int * sign)'/>
<dec f='linux/lib/mpi/mpicoder.c' l='315' type='int mpi_write_to_sgl(MPI , struct scatterlist * , unsigned int , int * )'/>
<use f='linux/lib/mpi/mpicoder.c' l='315' c='mpi_write_to_sgl'/>
<use f='linux/lib/mpi/mpicoder.c' l='315' u='a'/>
<use f='linux/lib/mpi/mpicoder.c' l='315' u='a'/>
<doc f='linux/lib/mpi/mpicoder.c' l='232'>/**
 * mpi_write_to_sgl() - Funnction exports MPI to an sgl (msb first)
 *
 * This function works in the same way as the mpi_read_buffer, but it
 * takes an sgl instead of u8 * buf.
 *
 * @a:		a multi precision integer
 * @sgl:	scatterlist to write to. Needs to be at least
 *		mpi_get_size(a) long.
 * @nbytes:	the number of bytes to write.  Leading bytes will be
 *		filled with zero.
 * @sign:	if not NULL, it will be set to the sign of a.
 *
 * Return:	0 on success or error code in case of error
 */</doc>
