<dec f='linux/include/linux/dma-fence.h' l='445' type='long dma_fence_wait_any_timeout(struct dma_fence ** fences, uint32_t count, bool intr, long timeout, uint32_t * idx)'/>
<def f='linux/drivers/dma-buf/dma-fence.c' l='467' ll='538' type='long dma_fence_wait_any_timeout(struct dma_fence ** fences, uint32_t count, bool intr, long timeout, uint32_t * idx)'/>
<dec f='linux/drivers/dma-buf/dma-fence.c' l='539' type='long dma_fence_wait_any_timeout(struct dma_fence ** , uint32_t , bool , long , uint32_t * )'/>
<use f='linux/drivers/dma-buf/dma-fence.c' l='539' c='dma_fence_wait_any_timeout'/>
<use f='linux/drivers/dma-buf/dma-fence.c' l='539' u='a'/>
<use f='linux/drivers/dma-buf/dma-fence.c' l='539' u='a'/>
<doc f='linux/drivers/dma-buf/dma-fence.c' l='449'>/**
 * dma_fence_wait_any_timeout - sleep until any fence gets signaled
 * or until timeout elapses
 * @fences:	[in]	array of fences to wait on
 * @count:	[in]	number of fences to wait on
 * @intr:	[in]	if true, do an interruptible wait
 * @timeout:	[in]	timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT
 * @idx:       [out]	the first signaled fence index, meaningful only on
 *			positive return
 *
 * Returns -EINVAL on custom fence wait implementation, -ERESTARTSYS if
 * interrupted, 0 if the wait timed out, or the remaining timeout in jiffies
 * on success.
 *
 * Synchronous waits for the first fence in the array to be signaled. The
 * caller needs to hold a reference to all fences in the array, otherwise a
 * fence might be freed before return, resulting in undefined behavior.
 */</doc>
