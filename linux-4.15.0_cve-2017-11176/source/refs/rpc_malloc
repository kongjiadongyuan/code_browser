<dec f='linux/include/linux/sunrpc/sched.h' l='245' type='int rpc_malloc(struct rpc_task * )'/>
<def f='linux/net/sunrpc/sched.c' l='870' ll='895' type='int rpc_malloc(struct rpc_task * task)'/>
<dec f='linux/net/sunrpc/sched.c' l='896' type='int rpc_malloc(struct rpc_task * )'/>
<use f='linux/net/sunrpc/sched.c' l='896' c='rpc_malloc'/>
<use f='linux/net/sunrpc/sched.c' l='896' u='a'/>
<use f='linux/net/sunrpc/sched.c' l='896' u='a'/>
<doc f='linux/net/sunrpc/sched.c' l='850'>/**
 * rpc_malloc - allocate RPC buffer resources
 * @task: RPC task
 *
 * A single memory region is allocated, which is split between the
 * RPC call and RPC reply that this task is being used for. When
 * this RPC is retired, the memory is released by calling rpc_free.
 *
 * To prevent rpciod from hanging, this allocator never sleeps,
 * returning -ENOMEM and suppressing warning if the request cannot
 * be serviced immediately. The caller can arrange to sleep in a
 * way that is safe for rpciod.
 *
 * Most requests are &apos;small&apos; (under 2KiB) and can be serviced from a
 * mempool, ensuring that NFS reads and writes can always proceed,
 * and that there is good locality of reference for these buffers.
 *
 * In order to avoid memory starvation triggering more writebacks of
 * NFS requests, we avoid using GFP_KERNEL.
 */</doc>
<use f='linux/net/sunrpc/xprtsock.c' l='2745'/>
<use f='linux/net/sunrpc/xprtsock.c' l='2745'/>
<use f='linux/net/sunrpc/xprtsock.c' l='2764'/>
<use f='linux/net/sunrpc/xprtsock.c' l='2764'/>
<use f='linux/net/sunrpc/xprtsock.c' l='2785'/>
<use f='linux/net/sunrpc/xprtsock.c' l='2785'/>
