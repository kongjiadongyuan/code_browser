<dec f='linux/drivers/base/power/power.h' l='38' type='void dev_pm_enable_wake_irq_check(struct device * dev, bool can_change_status)'/>
<use f='linux/drivers/base/power/runtime.c' l='596' u='c' c='rpm_suspend'/>
<use f='linux/drivers/base/power/runtime.c' l='823' u='c' c='rpm_resume'/>
<def f='linux/drivers/base/power/wakeirq.c' l='274' ll='293' type='void dev_pm_enable_wake_irq_check(struct device * dev, bool can_change_status)'/>
<doc f='linux/drivers/base/power/wakeirq.c' l='260'>/**
 * dev_pm_enable_wake_irq_check - Checks and enables wake-up interrupt
 * @dev: Device
 * @can_change_status: Can change wake-up interrupt status
 *
 * Enables wakeirq conditionally. We need to enable wake-up interrupt
 * lazily on the first rpm_suspend(). This is needed as the consumer device
 * starts in RPM_SUSPENDED state, and the the first pm_runtime_get() would
 * otherwise try to disable already disabled wakeirq. The wake-up interrupt
 * starts disabled with IRQ_NOAUTOEN set.
 *
 * Should be only called from rpm_suspend() and rpm_resume() path.
 * Caller must hold &amp;dev-&gt;power.lock to change wirq-&gt;status
 */</doc>
