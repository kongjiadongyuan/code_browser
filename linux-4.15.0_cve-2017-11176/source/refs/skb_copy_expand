<dec f='linux/include/linux/skbuff.h' l='1043' type='struct sk_buff * skb_copy_expand(const struct sk_buff * skb, int newheadroom, int newtailroom, gfp_t priority)'/>
<use f='linux/drivers/net/ethernet/broadcom/tg3.c' l='7800' u='c' c='tigon3_dma_hwbug_workaround'/>
<def f='linux/net/core/skbuff.c' l='1567' ll='1604' type='struct sk_buff * skb_copy_expand(const struct sk_buff * skb, int newheadroom, int newtailroom, gfp_t gfp_mask)'/>
<dec f='linux/net/core/skbuff.c' l='1605' type='struct sk_buff * skb_copy_expand(const struct sk_buff * , int , int , gfp_t )'/>
<use f='linux/net/core/skbuff.c' l='1605' c='skb_copy_expand'/>
<use f='linux/net/core/skbuff.c' l='1605' u='a'/>
<use f='linux/net/core/skbuff.c' l='1605' u='a'/>
<use f='linux/net/core/skbuff.c' l='4113' u='c' c='skb_cow_data'/>
<doc f='linux/net/core/skbuff.c' l='1549'>/**
 *	skb_copy_expand	-	copy and expand sk_buff
 *	@skb: buffer to copy
 *	@newheadroom: new free bytes at head
 *	@newtailroom: new free bytes at tail
 *	@gfp_mask: allocation priority
 *
 *	Make a copy of both an &amp;sk_buff and its data and while doing so
 *	allocate additional space.
 *
 *	This is used when the caller wishes to modify the data and needs a
 *	private copy of the data to alter as well as more space for new fields.
 *	Returns %NULL on failure or the pointer to the buffer
 *	on success. The returned buffer has a reference count of 1.
 *
 *	You must pass %GFP_ATOMIC as the allocation priority if this function
 *	is called from an interrupt.
 */</doc>
<use f='linux/net/mac80211/rx.c' l='576' u='c' c='ieee80211_make_monitor_skb'/>
<use f='linux/net/mac80211/rx.c' l='3176' u='c' c='ieee80211_rx_h_action_return'/>
