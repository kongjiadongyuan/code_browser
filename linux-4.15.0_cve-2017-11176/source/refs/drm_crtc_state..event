<dec f='linux/include/drm/drm_crtc.h' l='254' type='struct drm_pending_vblank_event *'/>
<offset>4096</offset>
<doc f='linux/include/drm/drm_crtc.h' l='206'>/**
	 * @event:
	 *
	 * Optional pointer to a DRM event to signal upon completion of the
	 * state update. The driver must send out the event when the atomic
	 * commit operation completes. There are two cases:
	 *
	 *  - The event is for a CRTC which is being disabled through this
	 *    atomic commit. In that case the event can be send out any time
	 *    after the hardware has stopped scanning out the current
	 *    framebuffers. It should contain the timestamp and counter for the
	 *    last vblank before the display pipeline was shut off. The simplest
	 *    way to achieve that is calling drm_crtc_send_vblank_event()
	 *    somewhen after drm_crtc_vblank_off() has been called.
	 *
	 *  - For a CRTC which is enabled at the end of the commit (even when it
	 *    undergoes an full modeset) the vblank timestamp and counter must
	 *    be for the vblank right before the first frame that scans out the
	 *    new set of buffers. Again the event can only be sent out after the
	 *    hardware has stopped scanning out the old buffers.
	 *
	 *  - Events for disabled CRTCs are not allowed, and drivers can ignore
	 *    that case.
	 *
	 * This can be handled by the drm_crtc_send_vblank_event() function,
	 * which the driver should call on the provided event upon completion of
	 * the atomic commit. Note that if the driver supports vblank signalling
	 * and timestamping the vblank counters and timestamps must agree with
	 * the ones returned from page flip events. With the current vblank
	 * helper infrastructure this can be achieved by holding a vblank
	 * reference while the page flip is pending, acquired through
	 * drm_crtc_vblank_get() and released with drm_crtc_vblank_put().
	 * Drivers are free to implement their own vblank counter and timestamp
	 * tracking though, e.g. if they have accurate timestamp registers in
	 * hardware.
	 *
	 * For hardware which supports some means to synchronize vblank
	 * interrupt delivery with committing display state there&apos;s also
	 * drm_crtc_arm_vblank_event(). See the documentation of that function
	 * for a detailed discussion of the constraints it needs to be used
	 * safely.
	 *
	 * If the device can&apos;t notify of flip completion in a race-free way
	 * at all, then the event should be armed just after the page flip is
	 * committed. In the worst case the driver will send the event to
	 * userspace one frame too late. This doesn&apos;t allow for a real atomic
	 * update, but it should avoid tearing.
	 */</doc>
<use f='linux/drivers/gpu/drm/drm_atomic.c' l='606' u='r' c='drm_atomic_crtc_check'/>
<use f='linux/drivers/gpu/drm/drm_atomic.c' l='2084' u='w' c='prepare_crtc_signaling'/>
<use f='linux/drivers/gpu/drm/drm_atomic.c' l='2088' u='r' c='prepare_crtc_signaling'/>
<use f='linux/drivers/gpu/drm/drm_atomic.c' l='2097' u='w' c='prepare_crtc_signaling'/>
<use f='linux/drivers/gpu/drm/drm_atomic.c' l='2126' u='r' c='prepare_crtc_signaling'/>
<use f='linux/drivers/gpu/drm/drm_atomic.c' l='2162' u='r' c='complete_crtc_signaling'/>
<use f='linux/drivers/gpu/drm/drm_atomic.c' l='2170' u='w' c='complete_crtc_signaling'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1769' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1775' u='w' c='drm_atomic_helper_setup_commit'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1778' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1779' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='1952' u='r' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='3088' u='w' c='page_flip_common'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='3293' u='w' c='__drm_atomic_helper_crtc_duplicate_state'/>
<use f='linux/drivers/gpu/drm/drm_atomic_helper.c' l='3341' u='r' c='__drm_atomic_helper_crtc_destroy_state'/>
<use f='linux/drivers/gpu/drm/i915/intel_display.c' l='12352' u='r' c='intel_atomic_commit_tail'/>
<use f='linux/drivers/gpu/drm/i915/intel_display.c' l='12354' u='r' c='intel_atomic_commit_tail'/>
<use f='linux/drivers/gpu/drm/i915/intel_display.c' l='12357' u='w' c='intel_atomic_commit_tail'/>
<use f='linux/drivers/gpu/drm/i915/intel_sprite.c' l='199' u='r' c='intel_pipe_update_end'/>
<use f='linux/drivers/gpu/drm/i915/intel_sprite.c' l='203' u='r' c='intel_pipe_update_end'/>
<use f='linux/drivers/gpu/drm/i915/intel_sprite.c' l='206' u='w' c='intel_pipe_update_end'/>
