<dec f='linux/include/sound/hda_i915.h' l='16' type='int snd_hdac_acomp_get_eld(struct hdac_device * codec, hda_nid_t nid, int dev_id, bool * audio_enabled, char * buffer, int max_bytes)'/>
<def f='linux/sound/hda/hdac_i915.c' l='243' ll='260' type='int snd_hdac_acomp_get_eld(struct hdac_device * codec, hda_nid_t nid, int dev_id, bool * audio_enabled, char * buffer, int max_bytes)'/>
<dec f='linux/sound/hda/hdac_i915.c' l='261' type='int snd_hdac_acomp_get_eld(struct hdac_device * , hda_nid_t , int , bool * , char * , int )'/>
<use f='linux/sound/hda/hdac_i915.c' l='261' c='snd_hdac_acomp_get_eld'/>
<use f='linux/sound/hda/hdac_i915.c' l='261' u='a'/>
<use f='linux/sound/hda/hdac_i915.c' l='261' u='a'/>
<doc f='linux/sound/hda/hdac_i915.c' l='222'>/**
 * snd_hdac_acomp_get_eld - Get the audio state and ELD via component
 * @codec: HDA codec
 * @nid: the pin widget NID
 * @dev_id: device identifier
 * @audio_enabled: the pointer to store the current audio state
 * @buffer: the buffer pointer to store ELD bytes
 * @max_bytes: the max bytes to be stored on @buffer
 *
 * This function is supposed to be used only by a HD-audio controller
 * driver that needs the interaction with i915 graphics.
 *
 * This function queries the current state of the audio on the given
 * digital port and fetches the ELD bytes onto the given buffer.
 * It returns the number of bytes for the total ELD data, zero for
 * invalid ELD, or a negative error code.
 *
 * The return size is the total bytes required for the whole ELD bytes,
 * thus it may be over @max_bytes.  If it&apos;s over @max_bytes, it implies
 * that only a part of ELD bytes have been fetched.
 */</doc>
