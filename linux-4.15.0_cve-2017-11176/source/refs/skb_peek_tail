<def f='linux/include/linux/skbuff.h' l='1607' ll='1615' type='struct sk_buff * skb_peek_tail(const struct sk_buff_head * list_)'/>
<use f='linux/include/linux/skbuff.h' l='1867' u='c' c='__skb_dequeue_tail'/>
<doc f='linux/include/linux/skbuff.h' l='1594'>/**
 *	skb_peek_tail - peek at the tail of an &amp;sk_buff_head
 *	@list_: list to peek at
 *
 *	Peek an &amp;sk_buff. Unlike most other operations you _MUST_
 *	be careful with this one. A peek leaves the buffer on the
 *	list and someone else may run off with it. You must hold
 *	the appropriate locks or have a private queue to do this.
 *
 *	Returns %NULL for an empty list or a pointer to the tail element.
 *	The reference count is not incremented and the reference is therefore
 *	volatile. Use with caution.
 */</doc>
<use f='linux/include/net/tcp.h' l='1596' u='c' c='tcp_write_queue_tail'/>
<use f='linux/net/core/neighbour.c' l='893' u='c' c='neigh_probe'/>
<use f='linux/net/core/skbuff.c' l='1064' u='c' c='sock_zerocopy_callback'/>
<use f='linux/net/core/sock.c' l='2303' u='c' c='sk_wait_data'/>
<use f='linux/net/core/sock.c' l='2303' u='c' c='sk_wait_data'/>
<use f='linux/net/ipv4/ip_output.c' l='881' u='c' c='__ip_append_data'/>
<use f='linux/net/ipv4/ip_output.c' l='1219' u='c' c='ip_append_page'/>
<use f='linux/net/ipv4/tcp.c' l='1855' u='c' c='tcp_recvmsg'/>
<use f='linux/net/ipv4/tcp_input.c' l='4326' u='c' c='tcp_ofo_queue'/>
<use f='linux/net/ipv4/tcp_input.c' l='4505' u='c' c='tcp_queue_rcv'/>
<use f='linux/net/ipv6/ip6_output.c' l='1254' u='c' c='__ip6_append_data'/>
<use f='linux/net/mac80211/rx.c' l='911' u='c' c='ieee80211_rx_reorder_ready'/>
<use f='linux/net/mac80211/tx.c' l='3193' u='c' c='ieee80211_amsdu_aggregate'/>
<use f='linux/net/unix/af_unix.c' l='1989' u='c' c='unix_stream_sendpage'/>
<use f='linux/net/unix/af_unix.c' l='2205' u='c' c='unix_stream_data_wait'/>
