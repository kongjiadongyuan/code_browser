<dec f='linux/drivers/gpu/drm/i915/intel_drv.h' l='1862' type='void intel_update_watermarks(struct intel_crtc * crtc)'/>
<use f='linux/drivers/gpu/drm/i915/intel_display.c' l='5009' u='c' c='intel_post_plane_update'/>
<use f='linux/drivers/gpu/drm/i915/intel_display.c' l='5103' u='c' c='intel_pre_plane_update'/>
<use f='linux/drivers/gpu/drm/i915/intel_display.c' l='5788' u='c' c='i9xx_crtc_enable'/>
<use f='linux/drivers/gpu/drm/i915/intel_display.c' l='5854' u='c' c='i9xx_crtc_disable'/>
<use f='linux/drivers/gpu/drm/i915/intel_display.c' l='5918' u='c' c='intel_crtc_disable_noatomic'/>
<def f='linux/drivers/gpu/drm/i915/intel_pm.c' l='5830' ll='5836' type='void intel_update_watermarks(struct intel_crtc * crtc)'/>
<doc f='linux/drivers/gpu/drm/i915/intel_pm.c' l='5798'>/**
 * intel_update_watermarks - update FIFO watermark values based on current modes
 *
 * Calculate watermark values for the various WM regs based on current mode
 * and plane configuration.
 *
 * There are several cases to deal with here:
 *   - normal (i.e. non-self-refresh)
 *   - self-refresh (SR) mode
 *   - lines are large relative to FIFO size (buffer can hold up to 2)
 *   - lines are small relative to FIFO size (buffer can hold more than 2
 *     lines), so need to account for TLB latency
 *
 *   The normal calculation is:
 *     watermark = dotclock * bytes per pixel * latency
 *   where latency is platform &amp; configuration dependent (we assume pessimal
 *   values here).
 *
 *   The SR calculation is:
 *     watermark = (trunc(latency/line time)+1) * surface width *
 *       bytes per pixel
 *   where
 *     line time = htotal / dotclock
 *     surface width = hdisplay for normal plane and 64 for cursor
 *   and latency is assumed to be high, as above.
 *
 * The final value programmed to the register should always be rounded up,
 * and include an extra 2 entries to account for clock crossings.
 *
 * We don&apos;t use the sprite, so we can ignore that.  And on Crestline we have
 * to set the non-SR watermarks to 8.
 */</doc>
