<dec f='linux/include/linux/filter.h' l='672' type='int sk_filter_trim_cap(struct sock * sk, struct sk_buff * skb, unsigned int cap)'/>
<use f='linux/include/linux/filter.h' l='675' u='c' c='sk_filter'/>
<def f='linux/net/core/filter.c' l='74' ll='110' type='int sk_filter_trim_cap(struct sock * sk, struct sk_buff * skb, unsigned int cap)'/>
<dec f='linux/net/core/filter.c' l='111' type='int sk_filter_trim_cap(struct sock * , struct sk_buff * , unsigned int )'/>
<use f='linux/net/core/filter.c' l='111' c='sk_filter_trim_cap'/>
<use f='linux/net/core/filter.c' l='111' u='a'/>
<use f='linux/net/core/filter.c' l='111' u='a'/>
<doc f='linux/net/core/filter.c' l='61'>/**
 *	sk_filter_trim_cap - run a packet through a socket filter
 *	@sk: sock associated with &amp;sk_buff
 *	@skb: buffer to filter
 *	@cap: limit on how short the eBPF program may trim the packet
 *
 * Run the eBPF program and then cut skb-&gt;data to correct size returned by
 * the program. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller
 * than pkt_len we keep whole skb-&gt;data. This is the socket level
 * wrapper to BPF_PROG_RUN. It returns 0 if the packet should
 * be accepted or -EPERM if the packet should be tossed.
 *
 */</doc>
<use f='linux/net/core/sock.c' l='492' u='c' c='__sk_receive_skb'/>
<use f='linux/net/ipv4/tcp_ipv4.c' l='1586' u='c' c='tcp_filter'/>
<use f='linux/net/ipv4/udp.c' l='1914' u='c' c='udp_queue_rcv_skb'/>
<use f='linux/net/ipv6/udp.c' l='651' u='c' c='udpv6_queue_rcv_skb'/>
