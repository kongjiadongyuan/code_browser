<dec f='linux/drivers/gpu/drm/i915/i915_drv.h' l='3477' type='int i915_gem_wait_ioctl(struct drm_device * dev, void * data, struct drm_file * file_priv)'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2764'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2764'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2764'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2764'/>
<def f='linux/drivers/gpu/drm/i915/i915_gem.c' l='3409' ll='3453' type='int i915_gem_wait_ioctl(struct drm_device * dev, void * data, struct drm_file * file)'/>
<doc f='linux/drivers/gpu/drm/i915/i915_gem.c' l='3385'>/**
 * i915_gem_wait_ioctl - implements DRM_IOCTL_I915_GEM_WAIT
 * @dev: drm device pointer
 * @data: ioctl data blob
 * @file: drm file pointer
 *
 * Returns 0 if successful, else an error is returned with the remaining time in
 * the timeout parameter.
 *  -ETIME: object is still busy after timeout
 *  -ERESTARTSYS: signal interrupted the wait
 *  -ENONENT: object doesn&apos;t exist
 * Also possible, but rare:
 *  -EAGAIN: incomplete, restart syscall
 *  -ENOMEM: damn
 *  -ENODEV: Internal IRQ fail
 *  -E?: The add request failed
 *
 * The wait ioctl with a timeout of 0 reimplements the busy ioctl. With any
 * non-zero timeout parameter the wait ioctl will wait for the given number of
 * nanoseconds on an object becoming unbusy. Since the wait itself does so
 * without holding struct_mutex the object may become re-busied before this
 * function completes. A similar but shorter * race condition exists in the busy
 * ioctl
 */</doc>
