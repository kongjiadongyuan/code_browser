<dec f='linux/include/linux/acpi.h' l='871' type='int acpi_dev_pm_attach(struct device * dev, bool power_on)'/>
<def f='linux/drivers/acpi/device_pm.c' l='1225' ll='1252' type='int acpi_dev_pm_attach(struct device * dev, bool power_on)'/>
<dec f='linux/drivers/acpi/device_pm.c' l='1253' type='int acpi_dev_pm_attach(struct device * , bool )'/>
<use f='linux/drivers/acpi/device_pm.c' l='1253' c='acpi_dev_pm_attach'/>
<use f='linux/drivers/acpi/device_pm.c' l='1253' u='a'/>
<use f='linux/drivers/acpi/device_pm.c' l='1253' u='a'/>
<doc f='linux/drivers/acpi/device_pm.c' l='1209'>/**
 * acpi_dev_pm_attach - Prepare device for ACPI power management.
 * @dev: Device to prepare.
 * @power_on: Whether or not to power on the device.
 *
 * If @dev has a valid ACPI handle that has a valid struct acpi_device object
 * attached to it, install a wakeup notification handler for the device and
 * add it to the general ACPI PM domain.  If @power_on is set, the device will
 * be put into the ACPI D0 state before the function returns.
 *
 * This assumes that the @dev&apos;s bus type uses generic power management callbacks
 * (or doesn&apos;t use any power management callbacks at all).
 *
 * Callers must ensure proper synchronization of this function with power
 * management callbacks.
 */</doc>
<use f='linux/drivers/base/power/common.c' l='107' u='c' c='dev_pm_domain_attach'/>
