<def f='linux/include/linux/usb.h' l='1829' ll='1847'/>
<use f='linux/include/linux/usb.h' l='1850' c='usb_sg_init'/>
<use f='linux/include/linux/usb.h' l='1859' c='usb_sg_cancel'/>
<use f='linux/include/linux/usb.h' l='1860' c='usb_sg_wait'/>
<size>88</size>
<doc f='linux/include/linux/usb.h' l='1813'>/**
 * struct usb_sg_request - support for scatter/gather I/O
 * @status: zero indicates success, else negative errno
 * @bytes: counts bytes transferred.
 *
 * These requests are initialized using usb_sg_init(), and then are used
 * as request handles passed to usb_sg_wait() or usb_sg_cancel().  Most
 * members of the request object aren&apos;t for driver access.
 *
 * The status and bytecount values are valid only after usb_sg_wait()
 * returns.  If the status is zero, then the bytecount matches the total
 * from the request.
 *
 * After an error completion, drivers may need to clear a halt condition
 * on the endpoint.
 */</doc>
<mbr r='usb_sg_request::status' o='0' t='int'/>
<mbr r='usb_sg_request::bytes' o='64' t='size_t'/>
<mbr r='usb_sg_request::lock' o='128' t='spinlock_t'/>
<mbr r='usb_sg_request::dev' o='192' t='struct usb_device *'/>
<mbr r='usb_sg_request::pipe' o='256' t='int'/>
<mbr r='usb_sg_request::entries' o='288' t='int'/>
<mbr r='usb_sg_request::urbs' o='320' t='struct urb **'/>
<mbr r='usb_sg_request::count' o='384' t='int'/>
<mbr r='usb_sg_request::complete' o='448' t='struct completion'/>
<use f='linux/drivers/usb/core/message.c' l='254' c='sg_clean'/>
<use f='linux/drivers/usb/core/message.c' l='267' c='sg_complete'/>
<use f='linux/drivers/usb/core/message.c' l='361' c='usb_sg_init'/>
<use f='linux/drivers/usb/core/message.c' l='509' c='usb_sg_wait'/>
<use f='linux/drivers/usb/core/message.c' l='579' c='usb_sg_cancel'/>
<size>88</size>
<use f='linux/drivers/usb/storage/usb.h' l='132'/>
<size>88</size>
