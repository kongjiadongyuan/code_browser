<dec f='linux/include/linux/sched.h' l='1483' type='void kick_process(struct task_struct * tsk)'/>
<use f='linux/include/linux/tracehook.h' l='165' u='c' c='set_notify_resume'/>
<def f='linux/kernel/sched/core.c' l='1440' ll='1449' type='void kick_process(struct task_struct * p)'/>
<dec f='linux/kernel/sched/core.c' l='1450' type='void kick_process(struct task_struct * )'/>
<use f='linux/kernel/sched/core.c' l='1450' c='kick_process'/>
<use f='linux/kernel/sched/core.c' l='1450' u='a'/>
<use f='linux/kernel/sched/core.c' l='1450' u='a'/>
<doc f='linux/kernel/sched/core.c' l='1427'>/***
 * kick_process - kick a running thread to enter/exit the kernel
 * @p: the to-be-kicked thread
 *
 * Cause a process which is running on another CPU to enter
 * kernel-mode, without any delay. (to get signals handled.)
 *
 * NOTE: this function doesn&apos;t have to take the runqueue lock,
 * because all it wants to ensure is that the remote task enters
 * the kernel. If the IPI races and the task has been migrated
 * to another CPU then no harm is done and the purpose has been
 * achieved as well.
 */</doc>
<use f='linux/kernel/signal.c' l='672' u='c' c='signal_wake_up_state'/>
