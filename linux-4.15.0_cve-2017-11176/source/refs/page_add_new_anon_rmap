<dec f='linux/include/linux/rmap.h' l='177' type='void page_add_new_anon_rmap(struct page * , struct vm_area_struct * , unsigned long , bool )'/>
<use f='linux/kernel/events/uprobes.c' l='188' u='c' c='__replace_page'/>
<use f='linux/mm/memory.c' l='2511' u='c' c='wp_page_copy'/>
<use f='linux/mm/memory.c' l='3024' u='c' c='do_swap_page'/>
<use f='linux/mm/memory.c' l='3171' u='c' c='do_anonymous_page'/>
<use f='linux/mm/memory.c' l='3422' u='c' c='alloc_set_pte'/>
<def f='linux/mm/rmap.c' l='1149' ll='1169' type='void page_add_new_anon_rmap(struct page * page, struct vm_area_struct * vma, unsigned long address, bool compound)'/>
<doc f='linux/mm/rmap.c' l='1138'>/**
 * page_add_new_anon_rmap - add pte mapping to a new anonymous page
 * @page:	the page to add the mapping to
 * @vma:	the vm area in which the mapping is added
 * @address:	the user virtual address mapped
 * @compound:	charge the page as compound or small page
 *
 * Same as page_add_anon_rmap but must only be called on *new* pages.
 * This means the inc-and-test can be bypassed.
 * Page does not have to be locked.
 */</doc>
<use f='linux/mm/swapfile.c' l='1809' u='c' c='unuse_pte'/>
