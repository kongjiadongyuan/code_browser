<def f='linux/include/linux/reciprocal_div.h' l='23' ll='26'/>
<dec f='linux/include/linux/reciprocal_div.h' l='28' type='struct reciprocal_value reciprocal_value(u32 d)'/>
<use f='linux/include/linux/reciprocal_div.h' l='28' c='reciprocal_value'/>
<use f='linux/include/linux/reciprocal_div.h' l='30' c='reciprocal_divide'/>
<use f='linux/include/linux/flex_array.h' l='27'/>
<size>8</size>
<doc f='linux/include/linux/reciprocal_div.h' l='7'>/*
 * This algorithm is based on the paper &quot;Division by Invariant
 * Integers Using Multiplication&quot; by Torbj√∂rn Granlund and Peter
 * L. Montgomery.
 *
 * The assembler implementation from Agner Fog, which this code is
 * based on, can be found here:
 * http://www.agner.org/optimize/asmlib.zip
 *
 * This optimization for A/B is helpful if the divisor B is mostly
 * runtime invariant. The reciprocal of B is calculated in the
 * slow-path with reciprocal_value(). The fast-path can then just use
 * a much faster multiplication operation with a variable dividend A
 * to calculate the division A/B.
 */</doc>
<mbr r='reciprocal_value::m' o='0' t='u32'/>
<mbr r='reciprocal_value::sh1' o='32' t='u8'/>
<mbr r='reciprocal_value::sh2' o='40' t='u8'/>
<use f='linux/lib/flex_array.c' l='94' c='flex_array_alloc'/>
<use f='linux/lib/flex_array.c' l='98' u='c' c='flex_array_alloc'/>
<size>8</size>
<def f='linux/lib/reciprocal_div.c' l='12' ll='27' type='struct reciprocal_value reciprocal_value(u32 d)'/>
<use f='linux/lib/reciprocal_div.c' l='12' c='reciprocal_value'/>
<use f='linux/lib/reciprocal_div.c' l='14' c='reciprocal_value'/>
<dec f='linux/lib/reciprocal_div.c' l='28' type='struct reciprocal_value reciprocal_value(u32 )'/>
<use f='linux/lib/reciprocal_div.c' l='28' c='reciprocal_value'/>
<use f='linux/lib/reciprocal_div.c' l='28' u='a'/>
<use f='linux/lib/reciprocal_div.c' l='28' u='a'/>
<size>8</size>
<doc f='linux/lib/reciprocal_div.c' l='7'>/*
 * For a description of the algorithm please have a look at
 * include/linux/reciprocal_div.h
 */</doc>
