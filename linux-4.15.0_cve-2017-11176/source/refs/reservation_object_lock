<def f='linux/include/linux/reservation.h' l='162' ll='167' type='int reservation_object_lock(struct reservation_object * obj, struct ww_acquire_ctx * ctx)'/>
<doc f='linux/include/linux/reservation.h' l='147'>/**
 * reservation_object_lock - lock the reservation object
 * @obj: the reservation object
 * @ctx: the locking context
 *
 * Locks the reservation object for exclusive access and modification. Note,
 * that the lock is only against other writers, readers will run concurrently
 * with a writer under RCU. The seqlock is used to notify readers if they
 * overlap with a writer.
 *
 * As the reservation object may be locked by multiple parties in an
 * undefined order, a #ww_acquire_ctx is passed to unwind if a cycle
 * is detected. See ww_mutex_lock() and ww_acquire_init(). A reservation
 * object may be locked by itself by passing NULL as @ctx.
 */</doc>
<use f='linux/drivers/gpu/drm/i915/i915_gem_object.h' l='344' u='c' c='i915_gem_object_lock'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_batch_pool.c' l='134' u='c' c='i915_gem_batch_pool_get'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_clflush.c' l='172' u='c' c='i915_gem_clflush_object'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_execbuffer.c' l='1132' u='c' c='__reloc_gpu_alloc'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_execbuffer.c' l='1138' u='c' c='__reloc_gpu_alloc'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_execbuffer.c' l='1748' u='c' c='eb_export_fence'/>
