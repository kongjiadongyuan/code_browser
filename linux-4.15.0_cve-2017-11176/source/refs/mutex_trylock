<dec f='linux/include/linux/mutex.h' l='195' type='int mutex_trylock(struct mutex * lock)'/>
<use f='linux/include/linux/mutex.h' l='228' u='c' c='mutex_trylock_recursive'/>
<doc f='linux/include/linux/mutex.h' l='189'>/*
 * NOTE: mutex_trylock() follows the spin_trylock() convention,
 *       not the down_trylock() convention!
 *
 * Returns 1 if the mutex has been acquired successfully, and 0 on contention.
 */</doc>
<use f='linux/include/linux/device.h' l='1099' u='c' c='device_trylock'/>
<use f='linux/drivers/base/core.c' l='637' u='c' c='lock_device_hotplug_sysfs'/>
<use f='linux/drivers/clk/clk.c' l='115' u='c' c='clk_prepare_lock'/>
<use f='linux/include/linux/ww_mutex.h' l='334' u='c' c='ww_mutex_trylock'/>
<use f='linux/drivers/gpu/drm/drm_dp_helper.c' l='974' u='c' c='trylock_bus'/>
<use f='linux/drivers/gpu/drm/drm_probe_helper.c' l='586' u='c' c='output_poll_execute'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem.c' l='3257' u='c' c='i915_gem_retire_work_handler'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem.c' l='3296' u='c' c='i915_gem_idle_work_handler'/>
<use f='linux/drivers/gpu/drm/i915/i915_gem_shrinker.c' l='50' u='c' c='shrinker_lock'/>
<use f='linux/drivers/gpu/drm/i915/i915_irq.c' l='2782' u='c' c='i915_reset_device'/>
<use f='linux/drivers/gpu/drm/i915/intel_i2c.c' l='642' u='c' c='gmbus_trylock_bus'/>
<use f='linux/drivers/md/md.h' l='505' u='c' c='mddev_trylock'/>
<use f='linux/drivers/tty/n_tty.c' l='2128' u='c' c='n_tty_read'/>
<use f='linux/drivers/tty/tty_io.c' l='875' u='c' c='tty_write_lock'/>
<use f='linux/fs/aio.c' l='398' u='c' c='aio_migratepage'/>
<use f='linux/fs/dcache.c' l='2936' u='c' c='__d_unalias'/>
<use f='linux/kernel/kexec.c' l='230' u='c' c='SYSC_kexec_load'/>
<use f='linux/kernel/kexec_core.c' l='937' u='c' c='__crash_kexec'/>
<use f='linux/kernel/kexec_core.c' l='1112' u='c' c='kernel_kexec'/>
<def f='linux/kernel/locking/mutex.c' l='1177' ll='1185' type='int mutex_trylock(struct mutex * lock)'/>
<dec f='linux/kernel/locking/mutex.c' l='1186' type='int mutex_trylock(struct mutex * )'/>
<use f='linux/kernel/locking/mutex.c' l='1186' c='mutex_trylock'/>
<use f='linux/kernel/locking/mutex.c' l='1186' u='a'/>
<use f='linux/kernel/locking/mutex.c' l='1186' u='a'/>
<doc f='linux/kernel/locking/mutex.c' l='1163'>/**
 * mutex_trylock - try to acquire the mutex, without waiting
 * @lock: the mutex to be acquired
 *
 * Try to acquire the mutex atomically. Returns 1 if the mutex
 * has been acquired successfully, and 0 on contention.
 *
 * NOTE: this function follows the spin_trylock() convention, so
 * it is negated from the down_trylock() return values! Be careful
 * about this when converting semaphore users to mutexes.
 *
 * This function must not be used in interrupt context. The
 * mutex must be released by the same task that acquired it.
 */</doc>
<use f='linux/kernel/power/suspend.c' l='554' u='c' c='enter_state'/>
<use f='linux/kernel/power/user.c' l='214' u='c' c='snapshot_ioctl'/>
<use f='linux/kernel/rcu/tree_exp.h' l='272' u='c' c='exp_funnel_lock'/>
<use f='linux/kernel/stop_machine.c' l='438' u='c' c='try_stop_cpus'/>
<use f='linux/kernel/stop_machine.c' l='638' u='c' c='stop_machine_from_inactive_cpu'/>
<use f='linux/mm/oom_kill.c' l='1108' u='c' c='pagefault_out_of_memory'/>
<use f='linux/mm/page_alloc.c' l='2520' u='c' c='drain_all_pages'/>
<use f='linux/mm/page_alloc.c' l='3347' u='c' c='__alloc_pages_may_oom'/>
<use f='linux/mm/slab_common.c' l='1295' u='c' c='dump_unreclaimable_slab'/>
<use f='linux/mm/vmalloc.c' l='716' u='c' c='try_purge_vmap_area_lazy'/>
<use f='linux/net/core/rtnetlink.c' l='112' u='c' c='rtnl_trylock'/>
<use f='linux/net/sunrpc/xprtsock.c' l='2699' u='c' c='bc_send_request'/>
<use f='linux/net/sunrpc/xprtsock.c' l='2701' u='c' c='bc_send_request'/>
<use f='linux/sound/core/pcm_native.c' l='1105' u='c' c='snd_pcm_action'/>
