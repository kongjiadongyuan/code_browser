<dec f='linux/drivers/edac/edac_mc.h' l='125' type='struct mem_ctl_info * edac_mc_alloc(unsigned int mc_num, unsigned int n_layers, struct edac_mc_layer * layers, unsigned int sz_pvt)'/>
<doc f='linux/drivers/edac/edac_mc.h' l='98'>/**
 * edac_mc_alloc() - Allocate and partially fill a struct &amp;mem_ctl_info.
 *
 * @mc_num:		Memory controller number
 * @n_layers:		Number of MC hierarchy layers
 * @layers:		Describes each layer as seen by the Memory Controller
 * @sz_pvt:		size of private storage needed
 *
 *
 * Everything is kmalloc&apos;ed as one big chunk - more efficient.
 * Only can be used if all structures have the same lifetime - otherwise
 * you have to allocate and initialize your own structures.
 *
 * Use edac_mc_free() to free mc structures allocated by this function.
 *
 * .. note::
 *
 *   drivers handle multi-rank memories in different ways: in some
 *   drivers, one multi-rank memory stick is mapped as one entry, while, in
 *   others, a single multi-rank memory stick would be mapped into several
 *   entries. Currently, this function will allocate multiple struct dimm_info
 *   on such scenarios, as grouping the multiple ranks require drivers change.
 *
 * Returns:
 *	On success, return a pointer to struct mem_ctl_info pointer;
 *	%NULL otherwise
 */</doc>
<def f='linux/drivers/edac/edac_mc.c' l='306' ll='500' type='struct mem_ctl_info * edac_mc_alloc(unsigned int mc_num, unsigned int n_layers, struct edac_mc_layer * layers, unsigned int sz_pvt)'/>
<dec f='linux/drivers/edac/edac_mc.c' l='501' type='struct mem_ctl_info * edac_mc_alloc(unsigned int , unsigned int , struct edac_mc_layer * , unsigned int )'/>
<use f='linux/drivers/edac/edac_mc.c' l='501' c='edac_mc_alloc'/>
<use f='linux/drivers/edac/edac_mc.c' l='501' u='a'/>
<use f='linux/drivers/edac/edac_mc.c' l='501' u='a'/>
