<dec f='linux/include/linux/ring_buffer.h' l='126' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * buffer, int cpu)'/>
<def f='linux/kernel/trace/ring_buffer.c' l='3997' ll='4018' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * buffer, int cpu)'/>
<dec f='linux/kernel/trace/ring_buffer.c' l='4019' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * , int )'/>
<use f='linux/kernel/trace/ring_buffer.c' l='4019' c='ring_buffer_read_prepare'/>
<use f='linux/kernel/trace/ring_buffer.c' l='4019' u='a'/>
<use f='linux/kernel/trace/ring_buffer.c' l='4019' u='a'/>
<doc f='linux/kernel/trace/ring_buffer.c' l='3977'>/**
 * ring_buffer_read_prepare - Prepare for a non consuming read of the buffer
 * @buffer: The ring buffer to read from
 * @cpu: The cpu buffer to iterate over
 *
 * This performs the initial preparations necessary to iterate
 * through the buffer.  Memory is allocated, buffer recording
 * is disabled, and the iterator pointer is returned to the caller.
 *
 * Disabling buffer recordng prevents the reading from being
 * corrupted. This is not a consuming read, so a producer is not
 * expected.
 *
 * After a sequence of ring_buffer_read_prepare calls, the user is
 * expected to make at least one call to ring_buffer_read_prepare_sync.
 * Afterwards, ring_buffer_read_start is invoked to get things going
 * for real.
 *
 * This overall must be paired with ring_buffer_read_finish.
 */</doc>
<use f='linux/kernel/trace/trace.c' l='3897' u='c' c='__tracing_open'/>
<use f='linux/kernel/trace/trace.c' l='3907' u='c' c='__tracing_open'/>
