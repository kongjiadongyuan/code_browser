<dec f='linux/include/net/tcp.h' l='426' type='int tcp_v4_do_rcv(struct sock * sk, struct sk_buff * skb)'/>
<def f='linux/net/ipv4/tcp_ipv4.c' l='1453' ll='1512' type='int tcp_v4_do_rcv(struct sock * sk, struct sk_buff * skb)'/>
<dec f='linux/net/ipv4/tcp_ipv4.c' l='1513' type='int tcp_v4_do_rcv(struct sock * , struct sk_buff * )'/>
<use f='linux/net/ipv4/tcp_ipv4.c' l='1513' c='tcp_v4_do_rcv'/>
<use f='linux/net/ipv4/tcp_ipv4.c' l='1513' u='a'/>
<use f='linux/net/ipv4/tcp_ipv4.c' l='1513' u='a'/>
<use f='linux/net/ipv4/tcp_ipv4.c' l='1736' u='c' c='tcp_v4_rcv'/>
<use f='linux/net/ipv4/tcp_ipv4.c' l='1746' u='c' c='tcp_v4_rcv'/>
<use f='linux/net/ipv4/tcp_ipv4.c' l='2421'/>
<use f='linux/net/ipv4/tcp_ipv4.c' l='2421'/>
<doc f='linux/net/ipv4/tcp_ipv4.c' l='1445'>/* The socket must have it&apos;s spinlock held when we get
 * here, unless it is a TCP_LISTEN socket.
 *
 * We have a potential double-lock case here, so even when
 * doing backlog processing we use the BH locking scheme.
 * This is because we cannot sleep with the original spinlock
 * held.
 */</doc>
<use f='linux/net/ipv6/tcp_ipv6.c' l='219' u='r' c='tcp_v6_connect'/>
<use f='linux/net/ipv6/tcp_ipv6.c' l='1082' u='r' c='tcp_v6_syn_recv_sock'/>
<use f='linux/net/ipv6/tcp_ipv6.c' l='1271' u='c' c='tcp_v6_do_rcv'/>
