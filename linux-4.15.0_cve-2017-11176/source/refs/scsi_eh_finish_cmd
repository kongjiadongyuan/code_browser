<dec f='linux/include/scsi/scsi_eh.h' l='12' type='void scsi_eh_finish_cmd(struct scsi_cmnd * scmd, struct list_head * done_q)'/>
<use f='linux/drivers/ata/libata-eh.c' l='689' u='c' c='ata_scsi_cmd_error_handler'/>
<use f='linux/drivers/ata/libata-eh.c' l='1301' u='c' c='__ata_eh_qc_complete'/>
<def f='linux/drivers/scsi/scsi_error.c' l='1142' ll='1145' type='void scsi_eh_finish_cmd(struct scsi_cmnd * scmd, struct list_head * done_q)'/>
<dec f='linux/drivers/scsi/scsi_error.c' l='1146' type='void scsi_eh_finish_cmd(struct scsi_cmnd * , struct list_head * )'/>
<use f='linux/drivers/scsi/scsi_error.c' l='1146' c='scsi_eh_finish_cmd'/>
<use f='linux/drivers/scsi/scsi_error.c' l='1146' u='a'/>
<use f='linux/drivers/scsi/scsi_error.c' l='1146' u='a'/>
<use f='linux/drivers/scsi/scsi_error.c' l='1227' u='c' c='scsi_eh_get_sense'/>
<use f='linux/drivers/scsi/scsi_error.c' l='1312' u='c' c='scsi_eh_test_devices'/>
<use f='linux/drivers/scsi/scsi_error.c' l='1392' u='c' c='scsi_eh_stu'/>
<use f='linux/drivers/scsi/scsi_error.c' l='1457' u='c' c='scsi_eh_bus_device_reset'/>
<use f='linux/drivers/scsi/scsi_error.c' l='1526' u='c' c='scsi_eh_target_reset'/>
<use f='linux/drivers/scsi/scsi_error.c' l='1591' u='c' c='scsi_eh_bus_reset'/>
<use f='linux/drivers/scsi/scsi_error.c' l='1636' u='c' c='scsi_eh_host_reset'/>
<use f='linux/drivers/scsi/scsi_error.c' l='1668' u='c' c='scsi_eh_offline_sdevs'/>
<doc f='linux/drivers/scsi/scsi_error.c' l='1130'>/**
 * scsi_eh_finish_cmd - Handle a cmd that eh is finished with.
 * @scmd:	Original SCSI cmd that eh has finished.
 * @done_q:	Queue for processed commands.
 *
 * Notes:
 *    We don&apos;t want to use the normal command completion while we are are
 *    still handling errors - it may cause other commands to be queued,
 *    and that would disturb what we are doing.  Thus we really want to
 *    keep a list of pending commands for final completion, and once we
 *    are ready to leave error handling we handle completion for real.
 */</doc>
