<dec f='linux/include/linux/quota.h' l='80' type='qid_t from_kqid_munged(struct user_namespace * to, struct kqid qid)'/>
<def f='linux/fs/quota/kqid.c' l='101' ll='113' type='qid_t from_kqid_munged(struct user_namespace * targ, struct kqid kqid)'/>
<dec f='linux/fs/quota/kqid.c' l='114' type='qid_t from_kqid_munged(struct user_namespace * , struct kqid )'/>
<use f='linux/fs/quota/kqid.c' l='114' c='from_kqid_munged'/>
<use f='linux/fs/quota/kqid.c' l='114' u='a'/>
<use f='linux/fs/quota/kqid.c' l='114' u='a'/>
<doc f='linux/fs/quota/kqid.c' l='83'>/**
 *	from_kqid_munged - Create a qid from a kqid user-namespace pair.
 *	@targ: The user namespace we want a qid in.
 *	@kqid: The kernel internal quota identifier to start with.
 *
 *	Map @kqid into the user-namespace specified by @targ and
 *	return the resulting qid.
 *
 *	There is always a mapping into the initial user_namespace.
 *
 *	Unlike from_kqid from_kqid_munged never fails and always
 *	returns a valid projid.  This makes from_kqid_munged
 *	appropriate for use in places where failing to provide
 *	a qid_t is not a good option.
 *
 *	If @kqid has no mapping in @targ the kqid.type specific
 *	overflow identifier is returned.
 */</doc>
<use f='linux/fs/quota/netlink.c' l='67' u='c' c='quota_send_warning'/>
