<dec f='linux/include/linux/pm_runtime.h' l='37' type='int pm_runtime_force_resume(struct device * dev)'/>
<def f='linux/drivers/base/power/runtime.c' l='1682' ll='1722' type='int pm_runtime_force_resume(struct device * dev)'/>
<dec f='linux/drivers/base/power/runtime.c' l='1723' type='int pm_runtime_force_resume(struct device * )'/>
<use f='linux/drivers/base/power/runtime.c' l='1723' c='pm_runtime_force_resume'/>
<use f='linux/drivers/base/power/runtime.c' l='1723' u='a'/>
<use f='linux/drivers/base/power/runtime.c' l='1723' u='a'/>
<doc f='linux/drivers/base/power/runtime.c' l='1666'>/**
 * pm_runtime_force_resume - Force a device into resume state if needed.
 * @dev: Device to resume.
 *
 * Prior invoking this function we expect the user to have brought the device
 * into low power state by a call to pm_runtime_force_suspend(). Here we reverse
 * those actions and brings the device into full power, if it is expected to be
 * used on system resume. To distinguish that, we check whether the runtime PM
 * usage count is greater than 1 (the PM core increases the usage count in the
 * system PM prepare phase), as that indicates a real user (such as a subsystem,
 * driver, userspace, etc.) is using it. If that is the case, the device is
 * expected to be used on system resume as well, so then we resume it. In the
 * other case, we defer the resume to be managed via runtime PM.
 *
 * Typically this function may be invoked from a system resume callback.
 */</doc>
<use f='linux/sound/pci/hda/hda_codec.c' l='2938'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2938'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2938'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2938'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2938'/>
<use f='linux/sound/pci/hda/hda_codec.c' l='2938'/>
