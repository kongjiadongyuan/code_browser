<def f='linux/arch/x86/platform/efi/quirks.c' l='242' ll='293' type='void efi_arch_mem_reserve(phys_addr_t addr, u64 size)'/>
<doc f='linux/arch/x86/platform/efi/quirks.c' l='222'>/*
 * The UEFI specification makes it clear that the operating system is
 * free to do whatever it wants with boot services code after
 * ExitBootServices() has been called. Ignoring this recommendation a
 * significant bunch of EFI implementations continue calling into boot
 * services code (SetVirtualAddressMap). In order to work around such
 * buggy implementations we reserve boot services region during EFI
 * init and make sure it stays executable. Then, after
 * SetVirtualAddressMap(), it is discarded.
 *
 * However, some boot services regions contain data that is required
 * by drivers, so we need to track which memory ranges can never be
 * freed. This is done by tagging those regions with the
 * EFI_MEMORY_RUNTIME attribute.
 *
 * Any driver that wants to mark a region as reserved must use
 * efi_mem_reserve() which will insert a new EFI memory descriptor
 * into efi.memmap (splitting existing regions if necessary) and tag
 * it with EFI_MEMORY_RUNTIME.
 */</doc>
<def f='linux/drivers/firmware/efi/efi.c' l='425' type='void efi_arch_mem_reserve(phys_addr_t addr, u64 size)'/>
<use f='linux/drivers/firmware/efi/efi.c' l='451' u='c' c='efi_mem_reserve'/>
