<def f='linux/include/uapi/linux/pps.h' l='54' ll='58'/>
<use f='linux/include/uapi/linux/pps.h' l='70'/>
<use f='linux/include/uapi/linux/pps.h' l='71'/>
<use f='linux/include/uapi/linux/pps.h' l='86'/>
<use f='linux/include/uapi/linux/pps.h' l='87'/>
<use f='linux/include/uapi/linux/pps.h' l='129'/>
<use f='linux/include/linux/pps_kernel.h' l='63'/>
<use f='linux/include/linux/pps_kernel.h' l='64'/>
<use f='linux/include/linux/pps_kernel.h' l='106' c='timespec_to_pps_ktime'/>
<size>16</size>
<doc f='linux/include/uapi/linux/pps.h' l='43'>/* 32-bit vs. 64-bit compatibility.
 *
 * 0n i386, the alignment of a uint64_t is only 4 bytes, while on most other
 * architectures it&apos;s 8 bytes. On i386, there will be no padding between the
 * two consecutive &apos;struct pps_ktime&apos; members of struct pps_kinfo and struct
 * pps_kparams. But on most platforms there will be padding to ensure correct
 * alignment.
 *
 * The simple fix is probably to add an explicit padding.
 *					 		[David Woodhouse]
 */</doc>
<mbr r='pps_ktime::sec' o='0' t='__s64'/>
<mbr r='pps_ktime::nsec' o='64' t='__s32'/>
<mbr r='pps_ktime::flags' o='96' t='__u32'/>
<use f='linux/drivers/pps/kapi.c' l='41' c='pps_add_offset'/>
<use f='linux/drivers/pps/kapi.c' l='41' c='pps_add_offset'/>
<use f='linux/drivers/pps/kapi.c' l='177' c='pps_event'/>
<size>16</size>
