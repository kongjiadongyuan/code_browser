<dec f='linux/include/linux/mm.h' l='2278' type='int filemap_fault(struct vm_fault * vmf)'/>
<doc f='linux/include/linux/mm.h' l='2277'>/* generic vm_area_ops exported for stackable file systems */</doc>
<use f='linux/fs/aio.c' l='350'/>
<use f='linux/fs/aio.c' l='350'/>
<use f='linux/fs/ext4/inode.c' l='6172' u='c' c='ext4_filemap_fault'/>
<use f='linux/fs/nfs/file.c' l='581'/>
<use f='linux/fs/nfs/file.c' l='581'/>
<def f='linux/mm/filemap.c' l='2495' ll='2613' type='int filemap_fault(struct vm_fault * vmf)'/>
<dec f='linux/mm/filemap.c' l='2614' type='int filemap_fault(struct vm_fault * )'/>
<use f='linux/mm/filemap.c' l='2614' c='filemap_fault'/>
<use f='linux/mm/filemap.c' l='2614' u='a'/>
<use f='linux/mm/filemap.c' l='2614' u='a'/>
<use f='linux/mm/filemap.c' l='2728'/>
<use f='linux/mm/filemap.c' l='2728'/>
<doc f='linux/mm/filemap.c' l='2472'>/**
 * filemap_fault - read in file data for page fault handling
 * @vmf:	struct vm_fault containing details of the fault
 *
 * filemap_fault() is invoked via the vma operations vector for a
 * mapped memory region to read in file data during a page fault.
 *
 * The goto&apos;s are kind of ugly, but this streamlines the normal case of having
 * it in the page cache, and handles the special cases reasonably without
 * having a lot of duplicated code.
 *
 * vma-&gt;vm_mm-&gt;mmap_sem must be held on entry.
 *
 * If our return value has VM_FAULT_RETRY set, it&apos;s because
 * lock_page_or_retry() returned 0.
 * The mmap_sem has usually been released in this case.
 * See __lock_page_or_retry() for the exception.
 *
 * If our return value does not have VM_FAULT_RETRY set, the mmap_sem
 * has not been released.
 *
 * We never return with VM_FAULT_RETRY and a bit from VM_FAULT_ERROR set.
 */</doc>
