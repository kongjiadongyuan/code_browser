<def f='linux/include/linux/workqueue.h' l='574' ll='577' type='void flush_scheduled_work()'/>
<doc f='linux/include/linux/workqueue.h' l='550'>/**
 * flush_scheduled_work - ensure that any scheduled work has run to completion.
 *
 * Forces execution of the kernel-global workqueue and blocks until its
 * completion.
 *
 * Think twice before calling this function!  It&apos;s very easy to get into
 * trouble if you don&apos;t take great care.  Either of the following situations
 * will lead to deadlock:
 *
 *	One of the work items currently on the workqueue needs to acquire
 *	a lock held by your code or its caller.
 *
 *	Your code is running in the context of a work routine.
 *
 * They will be detected by lockdep when they occur, but the first might not
 * occur very often.  It depends on what work items are on the workqueue and
 * what locks they need, which you have no control over.
 *
 * In most situations flushing the entire workqueue is overkill; you merely
 * need to know that a particular work item isn&apos;t queued and isn&apos;t running.
 * In such cases you should use cancel_delayed_work_sync() or
 * cancel_work_sync() instead.
 */</doc>
<use f='linux/drivers/acpi/ec.c' l='550' u='c' c='acpi_ec_flush_work'/>
<use f='linux/drivers/gpu/drm/i915/intel_display.c' l='15283' u='c' c='intel_modeset_cleanup'/>
<use f='linux/drivers/input/mouse/psmouse-smbus.c' l='301' u='c' c='psmouse_smbus_module_exit'/>
<use f='linux/drivers/md/dm.c' l='223' u='c' c='local_exit'/>
