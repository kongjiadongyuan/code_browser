<use f='linux/include/linux/dmaengine.h' l='266'/>
<def f='linux/include/linux/dmaengine.h' l='727' ll='808'/>
<use f='linux/include/linux/dmaengine.h' l='1047' c='is_dma_copy_aligned'/>
<use f='linux/include/linux/dmaengine.h' l='1053' c='is_dma_xor_aligned'/>
<use f='linux/include/linux/dmaengine.h' l='1059' c='is_dma_pq_aligned'/>
<use f='linux/include/linux/dmaengine.h' l='1065' c='is_dma_fill_aligned'/>
<use f='linux/include/linux/dmaengine.h' l='1072' c='dma_set_maxpq'/>
<use f='linux/include/linux/dmaengine.h' l='1091' c='dma_dev_has_pq_continue'/>
<use f='linux/include/linux/dmaengine.h' l='1096' c='dma_dev_to_maxpq'/>
<use f='linux/include/linux/dmaengine.h' l='1114' c='dma_maxpq'/>
<use f='linux/include/linux/dmaengine.h' l='1401' c='dma_async_device_register'/>
<use f='linux/include/linux/dmaengine.h' l='1402' c='dma_async_device_unregister'/>
<use f='linux/include/linux/dmaengine.h' l='1405' c='dma_get_any_slave_channel'/>
<size>296</size>
<doc f='linux/include/linux/dmaengine.h' l='666'>/**
 * struct dma_device - info on the entity supplying DMA services
 * @chancnt: how many DMA channels are supported
 * @privatecnt: how many DMA channels are requested by dma_request_channel
 * @channels: the list of struct dma_chan
 * @global_node: list_head for global dma_device_list
 * @filter: information for device/slave to filter function/param mapping
 * @cap_mask: one or more dma_capability flags
 * @max_xor: maximum number of xor sources, 0 if no capability
 * @max_pq: maximum number of PQ sources and PQ-continue capability
 * @copy_align: alignment shift for memcpy operations
 * @xor_align: alignment shift for xor operations
 * @pq_align: alignment shift for pq operations
 * @fill_align: alignment shift for memset operations
 * @dev_id: unique device ID
 * @dev: struct device reference for dma mapping api
 * @src_addr_widths: bit mask of src addr widths the device supports
 *	Width is specified in bytes, e.g. for a device supporting
 *	a width of 4 the mask should have BIT(4) set.
 * @dst_addr_widths: bit mask of dst addr widths the device supports
 * @directions: bit mask of slave directions the device supports.
 *	Since the enum dma_transfer_direction is not defined as bit flag for
 *	each type, the dma controller should set BIT(&lt;TYPE&gt;) and same
 *	should be checked by controller as well
 * @max_burst: max burst capability per-transfer
 * @residue_granularity: granularity of the transfer residue reported
 *	by tx_status
 * @device_alloc_chan_resources: allocate resources and return the
 *	number of allocated descriptors
 * @device_free_chan_resources: release DMA channel&apos;s resources
 * @device_prep_dma_memcpy: prepares a memcpy operation
 * @device_prep_dma_xor: prepares a xor operation
 * @device_prep_dma_xor_val: prepares a xor validation operation
 * @device_prep_dma_pq: prepares a pq operation
 * @device_prep_dma_pq_val: prepares a pqzero_sum operation
 * @device_prep_dma_memset: prepares a memset operation
 * @device_prep_dma_memset_sg: prepares a memset operation over a scatter list
 * @device_prep_dma_interrupt: prepares an end of chain interrupt operation
 * @device_prep_slave_sg: prepares a slave dma operation
 * @device_prep_dma_cyclic: prepare a cyclic dma operation suitable for audio.
 *	The function takes a buffer of size buf_len. The callback function will
 *	be called after period_len bytes have been transferred.
 * @device_prep_interleaved_dma: Transfer expression in a generic way.
 * @device_prep_dma_imm_data: DMA&apos;s 8 byte immediate data to the dst address
 * @device_config: Pushes a new configuration to a channel, return 0 or an error
 *	code
 * @device_pause: Pauses any transfer happening on a channel. Returns
 *	0 or an error code
 * @device_resume: Resumes any transfer on a channel previously
 *	paused. Returns 0 or an error code
 * @device_terminate_all: Aborts all transfers on a channel. Returns 0
 *	or an error code
 * @device_synchronize: Synchronizes the termination of a transfers to the
 *  current context.
 * @device_tx_status: poll for transaction completion, the optional
 *	txstate parameter can be supplied with a pointer to get a
 *	struct with auxiliary transfer status information, otherwise the call
 *	will just return a simple status code
 * @device_issue_pending: push pending transactions to hardware
 * @descriptor_reuse: a submitted transfer can be resubmitted after completion
 */</doc>
<mbr r='dma_device::chancnt' o='0' t='unsigned int'/>
<mbr r='dma_device::privatecnt' o='32' t='unsigned int'/>
<mbr r='dma_device::channels' o='64' t='struct list_head'/>
<mbr r='dma_device::global_node' o='192' t='struct list_head'/>
<mbr r='dma_device::filter' o='320' t='struct dma_filter'/>
<mbr r='dma_device::cap_mask' o='512' t='dma_cap_mask_t'/>
<mbr r='dma_device::max_xor' o='576' t='unsigned short'/>
<mbr r='dma_device::max_pq' o='592' t='unsigned short'/>
<mbr r='dma_device::copy_align' o='608' t='enum dmaengine_alignment'/>
<mbr r='dma_device::xor_align' o='640' t='enum dmaengine_alignment'/>
<mbr r='dma_device::pq_align' o='672' t='enum dmaengine_alignment'/>
<mbr r='dma_device::fill_align' o='704' t='enum dmaengine_alignment'/>
<mbr r='dma_device::dev_id' o='736' t='int'/>
<mbr r='dma_device::dev' o='768' t='struct device *'/>
<mbr r='dma_device::src_addr_widths' o='832' t='u32'/>
<mbr r='dma_device::dst_addr_widths' o='864' t='u32'/>
<mbr r='dma_device::directions' o='896' t='u32'/>
<mbr r='dma_device::max_burst' o='928' t='u32'/>
<mbr r='dma_device::descriptor_reuse' o='960' t='bool'/>
<mbr r='dma_device::residue_granularity' o='992' t='enum dma_residue_granularity'/>
<mbr r='dma_device::device_alloc_chan_resources' o='1024' t='int (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_free_chan_resources' o='1088' t='void (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_prep_dma_memcpy' o='1152' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t, dma_addr_t, size_t, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_xor' o='1216' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t, dma_addr_t *, unsigned int, size_t, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_xor_val' o='1280' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_pq' o='1344' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_pq_val' o='1408' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_memset' o='1472' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t, int, size_t, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_memset_sg' o='1536' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, struct scatterlist *, unsigned int, int, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_interrupt' o='1600' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, unsigned long)'/>
<mbr r='dma_device::device_prep_slave_sg' o='1664' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, struct scatterlist *, unsigned int, enum dma_transfer_direction, unsigned long, void *)'/>
<mbr r='dma_device::device_prep_dma_cyclic' o='1728' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, unsigned long)'/>
<mbr r='dma_device::device_prep_interleaved_dma' o='1792' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, struct dma_interleaved_template *, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_imm_data' o='1856' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t, u64, unsigned long)'/>
<mbr r='dma_device::device_config' o='1920' t='int (*)(struct dma_chan *, struct dma_slave_config *)'/>
<mbr r='dma_device::device_pause' o='1984' t='int (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_resume' o='2048' t='int (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_terminate_all' o='2112' t='int (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_synchronize' o='2176' t='void (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_tx_status' o='2240' t='enum dma_status (*)(struct dma_chan *, dma_cookie_t, struct dma_tx_state *)'/>
<mbr r='dma_device::device_issue_pending' o='2304' t='void (*)(struct dma_chan *)'/>
<use f='linux/drivers/dma/dmaengine.c' l='183' c='__dma_device_satisfies_mask'/>
<use f='linux/drivers/dma/dmaengine.c' l='370' c='dma_issue_pending_all'/>
<use f='linux/drivers/dma/dmaengine.c' l='406' c='min_chan'/>
<use f='linux/drivers/dma/dmaengine.c' l='447' c='dma_channel_rebalance'/>
<use f='linux/drivers/dma/dmaengine.c' l='477' c='dma_get_slave_caps'/>
<use f='linux/drivers/dma/dmaengine.c' l='516' c='private_candidate'/>
<use f='linux/drivers/dma/dmaengine.c' l='552' c='find_candidate'/>
<use f='linux/drivers/dma/dmaengine.c' l='601' c='dma_get_slave_channel'/>
<use f='linux/drivers/dma/dmaengine.c' l='624' c='dma_get_any_slave_channel'/>
<use f='linux/drivers/dma/dmaengine.c' l='654' c='__dma_request_channel'/>
<use f='linux/drivers/dma/dmaengine.c' l='654' c='__dma_request_channel'/>
<use f='linux/drivers/dma/dmaengine.c' l='677' c='dma_filter_match'/>
<use f='linux/drivers/dma/dmaengine.c' l='706' c='dma_request_chan'/>
<use f='linux/drivers/dma/dmaengine.c' l='706' c='dma_request_chan'/>
<use f='linux/drivers/dma/dmaengine.c' l='802' c='dmaengine_get'/>
<use f='linux/drivers/dma/dmaengine.c' l='802' c='dmaengine_get'/>
<use f='linux/drivers/dma/dmaengine.c' l='841' c='dmaengine_put'/>
<use f='linux/drivers/dma/dmaengine.c' l='858' c='device_has_all_tx_types'/>
<use f='linux/drivers/dma/dmaengine.c' l='897' c='get_dma_id'/>
<use f='linux/drivers/dma/dmaengine.c' l='916' c='dma_async_device_register'/>
<use f='linux/drivers/dma/dmaengine.c' l='1120' c='dma_async_device_unregister'/>
<size>296</size>
<use f='linux/drivers/dma/dw/regs.h' l='300'/>
<use f='linux/drivers/dma/dw/regs.h' l='335' c='to_dw_dma'/>
<size>296</size>
<use f='linux/drivers/dma/virt-dma.h' l='46' c='vchan_init'/>
<use f='linux/drivers/dma/hsu/hsu.h' l='114'/>
<use f='linux/drivers/dma/hsu/hsu.h' l='121' c='to_hsu_dma'/>
<size>296</size>
<use f='linux/drivers/dma/virt-dma.c' l='135' c='vchan_init'/>
<size>296</size>
