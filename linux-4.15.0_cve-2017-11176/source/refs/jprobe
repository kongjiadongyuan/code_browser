<def f='linux/include/linux/kprobes.h' l='167' ll='170'/>
<use f='linux/include/linux/kprobes.h' l='471' c='register_jprobe'/>
<use f='linux/include/linux/kprobes.h' l='475' c='register_jprobes'/>
<use f='linux/include/linux/kprobes.h' l='479' c='unregister_jprobe'/>
<use f='linux/include/linux/kprobes.h' l='482' c='unregister_jprobes'/>
<use f='linux/include/linux/kprobes.h' l='493' c='disable_jprobe'/>
<use f='linux/include/linux/kprobes.h' l='497' c='enable_jprobe'/>
<size>136</size>
<doc f='linux/include/linux/kprobes.h' l='157'>/*
 * Special probe type that uses setjmp-longjmp type tricks to resume
 * execution at a specified entry with a matching prototype corresponding
 * to the probed function - a trick to enable arguments to become
 * accessible seamlessly by probe handling logic.
 * Note:
 * Because of the way compilers allocate stack space for local variables
 * etc upfront, regardless of sub-scopes within a function, this mirroring
 * principle currently works only for probes placed on function entry points.
 */</doc>
<mbr r='jprobe::kp' o='0' t='struct kprobe'/>
<mbr r='jprobe::entry' o='1024' t='void *'/>
<use f='linux/arch/x86/kernel/kprobes/core.c' l='1084' c='setjmp_pre_handler'/>
<use f='linux/arch/x86/kernel/kprobes/core.c' l='1084' c='setjmp_pre_handler'/>
<use f='linux/arch/x86/kernel/kprobes/core.c' l='1084' c='setjmp_pre_handler'/>
<use f='linux/arch/x86/kernel/kprobes/core.c' l='1084' c='setjmp_pre_handler'/>
<use f='linux/arch/x86/kernel/kprobes/core.c' l='1142' c='longjmp_break_handler'/>
<use f='linux/arch/x86/kernel/kprobes/core.c' l='1142' c='longjmp_break_handler'/>
<use f='linux/arch/x86/kernel/kprobes/core.c' l='1142' c='longjmp_break_handler'/>
<use f='linux/arch/x86/kernel/kprobes/core.c' l='1142' c='longjmp_break_handler'/>
<size>136</size>
