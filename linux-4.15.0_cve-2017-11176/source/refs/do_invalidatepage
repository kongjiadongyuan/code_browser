<dec f='linux/include/linux/mm.h' l='1448' type='void do_invalidatepage(struct page * page, unsigned int offset, unsigned int length)'/>
<use f='linux/fs/buffer.c' l='2960' u='c' c='block_write_full_page'/>
<use f='linux/mm/readahead.c' l='51' u='c' c='read_cache_pages_invalidate_page'/>
<def f='linux/mm/truncate.c' l='154' ll='166' type='void do_invalidatepage(struct page * page, unsigned int offset, unsigned int length)'/>
<use f='linux/mm/truncate.c' l='191' u='c' c='truncate_cleanup_page'/>
<use f='linux/mm/truncate.c' l='393' u='c' c='truncate_inode_pages_range'/>
<use f='linux/mm/truncate.c' l='406' u='c' c='truncate_inode_pages_range'/>
<doc f='linux/mm/truncate.c' l='139'>/**
 * do_invalidatepage - invalidate part or all of a page
 * @page: the page which is affected
 * @offset: start of the range to invalidate
 * @length: length of the range to invalidate
 *
 * do_invalidatepage() is called when all or part of the page has become
 * invalidated by a truncate operation.
 *
 * do_invalidatepage() does not have to release all buffers, but it must
 * ensure that no dirty buffer is left outside @offset and that no I/O
 * is underway against any of the blocks which are outside the truncation
 * point.  Because the caller is about to free (and possibly reuse) those
 * blocks on-disk.
 */</doc>
