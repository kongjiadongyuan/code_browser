<dec f='linux/include/linux/sunrpc/xdr.h' l='226' type='void xdr_init_encode(struct xdr_stream * xdr, struct xdr_buf * buf, __be32 * p)'/>
<use f='linux/fs/nfs/callback_xdr.c' l='899' u='c' c='nfs4_callback_compound'/>
<use f='linux/net/sunrpc/auth.c' l='776' u='c' c='rpcauth_wrap_req_encode'/>
<use f='linux/net/sunrpc/auth_gss/auth_gss.c' l='1679' u='c' c='gss_wrap_req_encode'/>
<def f='linux/net/sunrpc/xdr.c' l='460' ll='482' type='void xdr_init_encode(struct xdr_stream * xdr, struct xdr_buf * buf, __be32 * p)'/>
<dec f='linux/net/sunrpc/xdr.c' l='483' type='void xdr_init_encode(struct xdr_stream * , struct xdr_buf * , __be32 * )'/>
<use f='linux/net/sunrpc/xdr.c' l='483' c='xdr_init_encode'/>
<use f='linux/net/sunrpc/xdr.c' l='483' u='a'/>
<use f='linux/net/sunrpc/xdr.c' l='483' u='a'/>
<doc f='linux/net/sunrpc/xdr.c' l='447'>/**
 * xdr_init_encode - Initialize a struct xdr_stream for sending data.
 * @xdr: pointer to xdr_stream struct
 * @buf: pointer to XDR buffer in which to encode data
 * @p: current pointer inside XDR buffer
 *
 * Note: at the moment the RPC client only passes the length of our
 *	 scratch buffer in the xdr_buf&apos;s header kvec. Previously this
 *	 meant we needed to call xdr_adjust_iovec() after encoding the
 *	 data. With the new scheme, the xdr_stream manages the details
 *	 of the buffer length, and takes care of adjusting the kvec
 *	 length for us.
 */</doc>
