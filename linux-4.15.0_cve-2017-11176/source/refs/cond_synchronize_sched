<dec f='linux/include/linux/rcutree.h' l='80' type='void cond_synchronize_sched(unsigned long oldstate)'/>
<def f='linux/kernel/rcu/tree.c' l='3412' ll='3423' type='void cond_synchronize_sched(unsigned long oldstate)'/>
<dec f='linux/kernel/rcu/tree.c' l='3424' type='void cond_synchronize_sched(unsigned long )'/>
<use f='linux/kernel/rcu/tree.c' l='3424' c='cond_synchronize_sched'/>
<use f='linux/kernel/rcu/tree.c' l='3424' u='a'/>
<use f='linux/kernel/rcu/tree.c' l='3424' u='a'/>
<doc f='linux/kernel/rcu/tree.c' l='3398'>/**
 * cond_synchronize_sched - Conditionally wait for an RCU-sched grace period
 *
 * @oldstate: return value from earlier call to get_state_synchronize_sched()
 *
 * If a full RCU-sched grace period has elapsed since the earlier call to
 * get_state_synchronize_sched(), just return.  Otherwise, invoke
 * synchronize_sched() to wait for a full grace period.
 *
 * Yes, this function does not take counter wrap into account.  But
 * counter wrap is harmless.  If the counter wraps, we have waited for
 * more than 2 billion grace periods (and way more on a 64-bit system!),
 * so waiting for one additional grace period should be just fine.
 */</doc>
