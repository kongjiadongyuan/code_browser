<dec f='linux/include/linux/completion.h' l='118' type='void complete(struct completion * )'/>
<use f='linux/arch/x86/kernel/hpet.c' l='706' u='c' c='hpet_work'/>
<use f='linux/block/bio.c' l='925' u='c' c='submit_bio_wait_endio'/>
<use f='linux/block/blk-exec.c' l='29' u='c' c='blk_end_sync_rq'/>
<use f='linux/crypto/api.c' l='607' u='c' c='crypto_req_done'/>
<use f='linux/drivers/acpi/device_sysfs.c' l='84' u='c' c='acpi_data_node_release'/>
<use f='linux/drivers/ata/libata-core.c' l='1538' u='c' c='ata_qc_complete_internal'/>
<use f='linux/drivers/ata/libata-scsi.c' l='255' u='c' c='ata_scsi_park_store'/>
<use f='linux/drivers/base/devtmpfs.c' l='390' u='c' c='devtmpfsd'/>
<use f='linux/drivers/base/devtmpfs.c' l='401' u='c' c='devtmpfsd'/>
<use f='linux/drivers/base/devtmpfs.c' l='412' u='c' c='devtmpfsd'/>
<use f='linux/drivers/char/hw_random/core.c' l='83' u='c' c='cleanup_rng'/>
<use f='linux/drivers/char/hw_random/core.c' l='471' u='c' c='hwrng_register'/>
<use f='linux/drivers/cpufreq/cpufreq.c' l='949' u='c' c='cpufreq_sysfs_release'/>
<use f='linux/drivers/cpuidle/sysfs.c' l='229' u='c' c='cpuidle_sysfs_release'/>
<use f='linux/drivers/cpuidle/sysfs.c' l='375' u='c' c='cpuidle_state_sysfs_release'/>
<doc f='linux/include/linux/dmaengine.h' l='483'>/**
 * struct dma_async_tx_descriptor - async transaction descriptor
 * ---dma generic offload fields---
 * @cookie: tracking cookie for this transaction, set to -EBUSY if
 *	this tx is sitting on a dependency list
 * @flags: flags to augment operation preparation, control completion, and
 * 	communicate status
 * @phys: physical address of the descriptor
 * @chan: target channel for this operation
 * @tx_submit: accept the descriptor, assign ordered cookie and mark the
 * descriptor pending. To be pushed on .issue_pending() call
 * @callback: routine to call after this operation is complete
 * @callback_param: general parameter to pass to the callback routine
 * ---async_tx api specific fields---
 * @next: at completion submit this descriptor
 * @parent: pointer to the next level up in the dependency chain
 * @lock: protect the parent and next pointers
 */</doc>
<use f='linux/drivers/i2c/i2c-core-base.c' l='936' u='c' c='i2c_adapter_dev_release'/>
<use f='linux/drivers/input/serio/i8042.c' l='744' u='c' c='i8042_aux_test_irq'/>
<use f='linux/drivers/mailbox/mailbox.c' l='114' u='c' c='tx_tick'/>
<use f='linux/drivers/md/dm-builtin.c' l='46' u='c' c='dm_kobject_release'/>
<use f='linux/drivers/md/dm-io.c' l='429' u='c' c='sync_io_complete'/>
<use f='linux/drivers/pcmcia/cs.c' l='97' u='c' c='pcmcia_release_socket'/>
<use f='linux/drivers/pcmcia/cs.c' l='606' u='c' c='pccardd'/>
<use f='linux/drivers/pcmcia/cs.c' l='613' u='c' c='pccardd'/>
<use f='linux/drivers/pcmcia/cs.c' l='830' u='c' c='pcmcia_release_socket_class'/>
<use f='linux/drivers/scsi/scsi_error.c' l='754' u='c' c='scsi_eh_done'/>
<use f='linux/drivers/scsi/scsi_scan.c' l='167' u='c' c='scsi_complete_async_scans'/>
<use f='linux/drivers/scsi/scsi_scan.c' l='1752' u='c' c='scsi_prep_async_scan'/>
<use f='linux/drivers/scsi/scsi_scan.c' l='1805' u='c' c='scsi_finish_async_scan'/>
<use f='linux/drivers/usb/core/message.c' l='37' u='c' c='usb_api_blocking_completion'/>
<use f='linux/drivers/usb/core/message.c' l='328' u='c' c='sg_complete'/>
<use f='linux/drivers/usb/core/message.c' l='558' u='c' c='usb_sg_wait'/>
<use f='linux/drivers/usb/storage/scsiglue.c' l='385' u='c' c='queuecommand_lck'/>
<use f='linux/drivers/usb/storage/transport.c' l='108' u='c' c='usb_stor_blocking_completion'/>
<use f='linux/drivers/usb/storage/usb.c' l='405' u='c' c='usb_stor_control_thread'/>
<use f='linux/drivers/usb/storage/usb.c' l='813' u='c' c='usb_stor_release_resources'/>
<use f='linux/fs/aio.c' l='610' u='c' c='free_ioctx_reqs'/>
<use f='linux/fs/debugfs/file.c' l='135' u='c' c='debugfs_file_put'/>
<use f='linux/fs/ext4/sysfs.c' l='329' u='c' c='ext4_sb_release'/>
<use f='linux/fs/nfs/direct.c' l='390' u='c' c='nfs_direct_complete'/>
<use f='linux/fs/nfs/nfs4session.c' l='64' u='c' c='nfs4_slot_tbl_drain_complete'/>
<use f='linux/fs/proc/inode.c' l='137' u='c' c='unuse_pde'/>
<use f='linux/fs/proc/inode.c' l='170' u='c' c='close_pdeo'/>
<use f='linux/fs/proc/proc_sysctl.c' l='262' u='c' c='unuse_table'/>
<use f='linux/init/main.c' l='428' u='c' c='rest_init'/>
<use f='linux/kernel/acct.c' l='190' u='c' c='close_work'/>
<use f='linux/kernel/cpu.c' l='251' u='c' c='complete_ap_thread'/>
<use f='linux/kernel/exit.c' l='524' u='c' c='exit_mm'/>
<use f='linux/kernel/exit.c' l='929' u='c' c='complete_and_exit'/>
<use f='linux/kernel/fork.c' l='1091' u='c' c='complete_vfork_done'/>
<use f='linux/kernel/kthread.c' l='183' u='c' c='__kthread_parkme'/>
<use f='linux/kernel/kthread.c' l='219' u='c' c='kthread'/>
<use f='linux/kernel/kthread.c' l='231' u='c' c='kthread'/>
<use f='linux/kernel/kthread.c' l='271' u='c' c='create_kthread'/>
<use f='linux/kernel/kthread.c' l='912' u='c' c='kthread_flush_work_fn'/>
<use f='linux/kernel/params.c' l='932' u='c' c='module_kobj_release'/>
<use f='linux/kernel/rcu/srcutree.c' l='991' u='c' c='srcu_barrier_cb'/>
<use f='linux/kernel/rcu/srcutree.c' l='1041' u='c' c='srcu_barrier'/>
<use f='linux/kernel/rcu/tree.c' l='3557' u='c' c='rcu_barrier_callback'/>
<use f='linux/kernel/rcu/tree.c' l='3658' u='c' c='_rcu_barrier'/>
<use f='linux/kernel/rcu/update.c' l='377' u='c' c='wakeme_after_rcu'/>
<def f='linux/kernel/sched/completion.c' l='31' ll='41' type='void complete(struct completion * x)'/>
<dec f='linux/kernel/sched/completion.c' l='42' type='void complete(struct completion * )'/>
<use f='linux/kernel/sched/completion.c' l='42' c='complete'/>
<use f='linux/kernel/sched/completion.c' l='42' u='a'/>
<use f='linux/kernel/sched/completion.c' l='42' u='a'/>
<doc f='linux/kernel/sched/completion.c' l='19'>/**
 * complete: - signals a single thread waiting on this completion
 * @x:  holds the state of this particular completion
 *
 * This will wake up a single thread waiting on this completion. Threads will be
 * awakened in the same order in which they were queued.
 *
 * See also complete_all(), wait_for_completion() and related routines.
 *
 * It may be assumed that this function implies a write memory barrier before
 * changing the task state if and only if any tasks are woken up.
 */</doc>
<use f='linux/kernel/smp.c' l='775' u='c' c='smp_call_on_cpu_callback'/>
<use f='linux/kernel/stop_machine.c' l='64' u='c' c='cpu_stop_signal_done'/>
<use f='linux/kernel/trace/ring_buffer.c' l='1603' u='c' c='update_pages_handler'/>
<use f='linux/kernel/umh.c' l='55' u='c' c='umh_complete'/>
<use f='linux/kernel/workqueue.c' l='1176' u='c' c='pwq_dec_nr_in_flight'/>
<use f='linux/kernel/workqueue.c' l='1740' u='c' c='worker_detach_from_pool'/>
<use f='linux/kernel/workqueue.c' l='2451' u='c' c='wq_barrier_func'/>
<use f='linux/kernel/workqueue.c' l='2584' u='c' c='flush_workqueue_prep_pwqs'/>
<use f='linux/kernel/workqueue.c' l='2687' u='c' c='flush_workqueue'/>
<use f='linux/net/sunrpc/cache.c' l='593' u='c' c='cache_restart_thread'/>
<use f='linux/sound/core/init.c' l='500' u='c' c='snd_card_do_free'/>
