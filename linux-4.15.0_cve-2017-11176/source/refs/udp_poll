<dec f='linux/include/net/udp.h' l='278' type='unsigned int udp_poll(struct file * file, struct socket * sock, poll_table * wait)'/>
<use f='linux/net/ipv4/af_inet.c' l='969'/>
<use f='linux/net/ipv4/af_inet.c' l='969'/>
<def f='linux/net/ipv4/udp.c' l='2510' ll='2527' type='unsigned int udp_poll(struct file * file, struct socket * sock, poll_table * wait)'/>
<dec f='linux/net/ipv4/udp.c' l='2528' type='unsigned int udp_poll(struct file * , struct socket * , poll_table * )'/>
<use f='linux/net/ipv4/udp.c' l='2528' c='udp_poll'/>
<use f='linux/net/ipv4/udp.c' l='2528' u='a'/>
<use f='linux/net/ipv4/udp.c' l='2528' u='a'/>
<doc f='linux/net/ipv4/udp.c' l='2497'>/**
 * 	udp_poll - wait for a UDP event.
 *	@file - file struct
 *	@sock - socket
 *	@wait - poll table
 *
 *	This is same as datagram poll, except for the special case of
 *	blocking sockets. If application is using a blocking fd
 *	and a packet with checksum error is in the queue;
 *	then it could get return from select indicating data available
 *	but then block when reading it. Add special case code
 *	to work around these arguably broken applications.
 */</doc>
<use f='linux/net/ipv6/af_inet6.c' l='580'/>
<use f='linux/net/ipv6/af_inet6.c' l='580'/>
