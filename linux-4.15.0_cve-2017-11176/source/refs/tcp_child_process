<dec f='linux/include/net/tcp.h' l='378' type='int tcp_child_process(struct sock * parent, struct sock * child, struct sk_buff * skb)'/>
<use f='linux/net/ipv4/tcp_ipv4.c' l='1482' u='c' c='tcp_v4_do_rcv'/>
<use f='linux/net/ipv4/tcp_ipv4.c' l='1706' u='c' c='tcp_v4_rcv'/>
<def f='linux/net/ipv4/tcp_minisocks.c' l='827' ll='853' type='int tcp_child_process(struct sock * parent, struct sock * child, struct sk_buff * skb)'/>
<dec f='linux/net/ipv4/tcp_minisocks.c' l='854' type='int tcp_child_process(struct sock * , struct sock * , struct sk_buff * )'/>
<use f='linux/net/ipv4/tcp_minisocks.c' l='854' c='tcp_child_process'/>
<use f='linux/net/ipv4/tcp_minisocks.c' l='854' u='a'/>
<use f='linux/net/ipv4/tcp_minisocks.c' l='854' u='a'/>
<doc f='linux/net/ipv4/tcp_minisocks.c' l='815'>/*
 * Queue segment on the new socket if the new socket is active,
 * otherwise we just shortcircuit this and continue with
 * the new socket.
 *
 * For the vast majority of cases child-&gt;sk_state will be TCP_SYN_RECV
 * when entering. But other states are possible due to a race condition
 * where after __inet_lookup_established() fails but before the listener
 * locked is obtained, other packets cause the same connection to
 * be created.
 */</doc>
<use f='linux/net/ipv6/tcp_ipv6.c' l='1323' u='c' c='tcp_v6_do_rcv'/>
<use f='linux/net/ipv6/tcp_ipv6.c' l='1483' u='c' c='tcp_v6_rcv'/>
