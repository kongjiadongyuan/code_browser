<dec f='linux/include/drm/drm_file.h' l='364' type='ssize_t drm_read(struct file * filp, char * buffer, size_t count, loff_t * offset)'/>
<def f='linux/drivers/gpu/drm/drm_file.c' l='476' ll='543' type='ssize_t drm_read(struct file * filp, char * buffer, size_t count, loff_t * offset)'/>
<dec f='linux/drivers/gpu/drm/drm_file.c' l='544' type='ssize_t drm_read(struct file * , char * , size_t , loff_t * )'/>
<use f='linux/drivers/gpu/drm/drm_file.c' l='544' c='drm_read'/>
<use f='linux/drivers/gpu/drm/drm_file.c' l='544' u='a'/>
<use f='linux/drivers/gpu/drm/drm_file.c' l='544' u='a'/>
<doc f='linux/drivers/gpu/drm/drm_file.c' l='450'>/**
 * drm_read - read method for DRM file
 * @filp: file pointer
 * @buffer: userspace destination pointer for the read
 * @count: count in bytes to read
 * @offset: offset to read
 *
 * This function must be used by drivers as their &amp;file_operations.read
 * method iff they use DRM events for asynchronous signalling to userspace.
 * Since events are used by the KMS API for vblank and page flip completion this
 * means all modern display drivers must use it.
 *
 * @offset is ignored, DRM events are read like a pipe. Therefore drivers also
 * must set the &amp;file_operation.llseek to no_llseek(). Polling support is
 * provided by drm_poll().
 *
 * This function will only ever read a full event. Therefore userspace must
 * supply a big enough buffer to fit any event to ensure forward progress. Since
 * the maximum event space is currently 4K it&apos;s recommended to just use that for
 * safety.
 *
 * RETURNS:
 *
 * Number of bytes read (always aligned to full events, and can be 0) or a
 * negative error code on failure.
 */</doc>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2707'/>
<use f='linux/drivers/gpu/drm/i915/i915_drv.c' l='2707'/>
