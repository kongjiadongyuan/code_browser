<dec f='linux/include/linux/io.h' l='164' type='void * memremap(resource_size_t offset, size_t size, unsigned long flags)'/>
<use f='linux/arch/x86/kernel/kdebugfs.c' l='49' u='c' c='setup_data_read'/>
<use f='linux/arch/x86/kernel/kdebugfs.c' l='122' u='c' c='create_setup_data_nodes'/>
<use f='linux/arch/x86/kernel/ksysfs.c' l='82' u='c' c='get_setup_data_paddr'/>
<use f='linux/arch/x86/kernel/ksysfs.c' l='100' u='c' c='get_setup_data_size'/>
<use f='linux/arch/x86/kernel/ksysfs.c' l='130' u='c' c='type_show'/>
<use f='linux/arch/x86/kernel/ksysfs.c' l='157' u='c' c='setup_data_data_read'/>
<use f='linux/arch/x86/kernel/ksysfs.c' l='173' u='c' c='setup_data_data_read'/>
<use f='linux/arch/x86/kernel/ksysfs.c' l='253' u='c' c='get_setup_data_total_num'/>
<use f='linux/arch/x86/mm/ioremap.c' l='459' u='c' c='xlate_dev_mem_ptr'/>
<use f='linux/arch/x86/mm/ioremap.c' l='589' u='c' c='memremap_is_setup_data'/>
<use f='linux/arch/x86/pci/common.c' l='682' u='c' c='pcibios_add_device'/>
<use f='linux/arch/x86/platform/efi/quirks.c' l='427' u='c' c='efi_free_boot_services'/>
<use f='linux/drivers/firmware/dmi_scan.c' l='736' macro='1' u='c' c='dmi_init'/>
<use f='linux/drivers/firmware/dmi_scan.c' l='1031' macro='1' u='c' c='dmi_walk'/>
<use f='linux/drivers/firmware/efi/efi.c' l='928' u='c' c='update_efi_random_seed'/>
<use f='linux/drivers/firmware/efi/efi.c' l='936' u='c' c='update_efi_random_seed'/>
<use f='linux/drivers/firmware/efi/esrt.c' l='388' u='c' c='esrt_sysfs_init'/>
<use f='linux/drivers/firmware/efi/memattr.c' l='153' u='c' c='efi_memattr_apply_permissions'/>
<use f='linux/drivers/firmware/efi/memmap.c' l='80' u='c' c='__efi_memmap_init'/>
<use f='linux/drivers/gpu/drm/i915/intel_opregion.c' l='983' u='c' c='intel_opregion_setup'/>
<use f='linux/drivers/gpu/drm/i915/intel_opregion.c' l='1027' u='c' c='intel_opregion_setup'/>
<use f='linux/drivers/iommu/amd_iommu_init.c' l='896' u='c' c='copy_device_table'/>
<use f='linux/drivers/iommu/intel-iommu.c' l='3089' u='c' c='copy_context_table'/>
<use f='linux/drivers/iommu/intel-iommu.c' l='3172' u='c' c='copy_translation_tables'/>
<def f='linux/kernel/memremap.c' l='87' ll='135' type='void * memremap(resource_size_t offset, size_t size, unsigned long flags)'/>
<dec f='linux/kernel/memremap.c' l='136' type='void * memremap(resource_size_t , size_t , unsigned long )'/>
<use f='linux/kernel/memremap.c' l='136' c='memremap'/>
<use f='linux/kernel/memremap.c' l='136' u='a'/>
<use f='linux/kernel/memremap.c' l='136' u='a'/>
<use f='linux/kernel/memremap.c' l='165' u='c' c='devm_memremap'/>
<doc f='linux/kernel/memremap.c' l='59'>/**
 * memremap() - remap an iomem_resource as cacheable memory
 * @offset: iomem resource start address
 * @size: size of remap
 * @flags: any of MEMREMAP_WB, MEMREMAP_WT, MEMREMAP_WC,
 *		  MEMREMAP_ENC, MEMREMAP_DEC
 *
 * memremap() is &quot;ioremap&quot; for cases where it is known that the resource
 * being mapped does not have i/o side effects and the __iomem
 * annotation is not applicable. In the case of multiple flags, the different
 * mapping types will be attempted in the order listed below until one of
 * them succeeds.
 *
 * MEMREMAP_WB - matches the default mapping for System RAM on
 * the architecture.  This is usually a read-allocate write-back cache.
 * Morever, if MEMREMAP_WB is specified and the requested remap region is RAM
 * memremap() will bypass establishing a new mapping and instead return
 * a pointer into the direct map.
 *
 * MEMREMAP_WT - establish a mapping whereby writes either bypass the
 * cache or are written through to memory and never exist in a
 * cache-dirty state with respect to program visibility.  Attempts to
 * map System RAM with this mapping type will fail.
 *
 * MEMREMAP_WC - establish a writecombine mapping, whereby writes may
 * be coalesced together (e.g. in the CPU&apos;s write buffers), but is otherwise
 * uncached. Attempts to map System RAM with this mapping type will fail.
 */</doc>
