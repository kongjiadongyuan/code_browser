<dec f='linux/include/linux/device.h' l='684' type='void * devm_ioremap_resource(struct device * dev, struct resource * res)'/>
<def f='linux/lib/devres.c' l='135' ll='164' type='void * devm_ioremap_resource(struct device * dev, struct resource * res)'/>
<dec f='linux/lib/devres.c' l='165' type='void * devm_ioremap_resource(struct device * , struct resource * )'/>
<use f='linux/lib/devres.c' l='165' c='devm_ioremap_resource'/>
<use f='linux/lib/devres.c' l='165' u='a'/>
<use f='linux/lib/devres.c' l='165' u='a'/>
<doc f='linux/lib/devres.c' l='118'>/**
 * devm_ioremap_resource() - check, request region, and ioremap resource
 * @dev: generic device to handle the resource for
 * @res: resource to be handled
 *
 * Checks that a resource is a valid memory region, requests the memory
 * region and ioremaps it. All operations are managed and will be undone
 * on driver detach.
 *
 * Returns a pointer to the remapped memory or an ERR_PTR() encoded error code
 * on failure. Usage example:
 *
 *	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 *	base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);
 *	if (IS_ERR(base))
 *		return PTR_ERR(base);
 */</doc>
