<dec f='linux/include/linux/pm_wakeup.h' l='106' type='void pm_stay_awake(struct device * dev)'/>
<def f='linux/drivers/base/power/wakeup.c' l='596' ll='606' type='void pm_stay_awake(struct device * dev)'/>
<dec f='linux/drivers/base/power/wakeup.c' l='607' type='void pm_stay_awake(struct device * )'/>
<use f='linux/drivers/base/power/wakeup.c' l='607' c='pm_stay_awake'/>
<use f='linux/drivers/base/power/wakeup.c' l='607' u='a'/>
<use f='linux/drivers/base/power/wakeup.c' l='607' u='a'/>
<doc f='linux/drivers/base/power/wakeup.c' l='585'>/**
 * pm_stay_awake - Notify the PM core that a wakeup event is being processed.
 * @dev: Device the wakeup event is related to.
 *
 * Notify the PM core of a wakeup event (signaled by @dev) by calling
 * __pm_stay_awake for the @dev&apos;s wakeup source object.
 *
 * Call this function after detecting of a wakeup event if pm_relax() is going
 * to be called directly after processing the event (and possibly passing it to
 * user space for further processing).
 */</doc>
<use f='linux/drivers/power/supply/power_supply_core.c' l='121' u='c' c='power_supply_changed'/>
<use f='linux/drivers/rtc/interface.c' l='86' u='c' c='rtc_set_time'/>
<use f='linux/drivers/rtc/interface.c' l='585' u='c' c='rtc_update_irq'/>
<use f='linux/drivers/rtc/interface.c' l='789' u='c' c='rtc_timer_enqueue'/>
<use f='linux/drivers/rtc/interface.c' l='837' u='c' c='rtc_timer_remove'/>
