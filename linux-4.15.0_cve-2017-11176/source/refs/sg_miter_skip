<dec f='linux/include/linux/scatterlist.h' l='415' type='bool sg_miter_skip(struct sg_mapping_iter * miter, off_t offset)'/>
<use f='linux/drivers/usb/storage/protocol.c' l='141' u='c' c='usb_stor_access_xfer_buf'/>
<def f='linux/lib/scatterlist.c' l='576' ll='593' type='bool sg_miter_skip(struct sg_mapping_iter * miter, off_t offset)'/>
<dec f='linux/lib/scatterlist.c' l='594' type='bool sg_miter_skip(struct sg_mapping_iter * , off_t )'/>
<use f='linux/lib/scatterlist.c' l='594' c='sg_miter_skip'/>
<use f='linux/lib/scatterlist.c' l='594' u='a'/>
<use f='linux/lib/scatterlist.c' l='594' u='a'/>
<use f='linux/lib/scatterlist.c' l='704' u='c' c='sg_copy_buffer'/>
<use f='linux/lib/scatterlist.c' l='814' u='c' c='sg_zero_buffer'/>
<doc f='linux/lib/scatterlist.c' l='558'>/**
 * sg_miter_skip - reposition mapping iterator
 * @miter: sg mapping iter to be skipped
 * @offset: number of bytes to plus the current location
 *
 * Description:
 *   Sets the offset of @miter to its current location plus @offset bytes.
 *   If mapping iterator @miter has been proceeded by sg_miter_next(), this
 *   stops @miter.
 *
 * Context:
 *   Don&apos;t care if @miter is stopped, or not proceeded yet.
 *   Otherwise, preemption disabled if the SG_MITER_ATOMIC is set.
 *
 * Returns:
 *   true if @miter contains the valid mapping.  false if end of sg
 *   list is reached.
 */</doc>
