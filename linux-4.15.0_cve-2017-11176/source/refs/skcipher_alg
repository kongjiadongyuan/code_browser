<def f='linux/include/crypto/skcipher.h' l='125' ll='140'/>
<use f='linux/include/crypto/skcipher.h' l='250' c='crypto_skcipher_alg'/>
<use f='linux/include/crypto/skcipher.h' l='254' c='crypto_skcipher_alg'/>
<use f='linux/include/crypto/skcipher.h' l='254' c='crypto_skcipher_alg'/>
<use f='linux/include/crypto/skcipher.h' l='254' c='crypto_skcipher_alg'/>
<use f='linux/include/crypto/skcipher.h' l='257' c='crypto_skcipher_alg_ivsize'/>
<use f='linux/include/crypto/skcipher.h' l='284' c='crypto_skcipher_alg_chunksize'/>
<use f='linux/include/crypto/skcipher.h' l='297' c='crypto_skcipher_alg_walksize'/>
<use f='linux/include/crypto/internal/skcipher.h' l='28'/>
<use f='linux/include/crypto/internal/skcipher.h' l='31'/>
<use f='linux/include/crypto/internal/skcipher.h' l='112' c='crypto_skcipher_spawn_alg'/>
<use f='linux/include/crypto/internal/skcipher.h' l='115' c='crypto_skcipher_spawn_alg'/>
<use f='linux/include/crypto/internal/skcipher.h' l='115' c='crypto_skcipher_spawn_alg'/>
<use f='linux/include/crypto/internal/skcipher.h' l='115' c='crypto_skcipher_spawn_alg'/>
<use f='linux/include/crypto/internal/skcipher.h' l='118' c='crypto_spawn_skcipher_alg'/>
<use f='linux/include/crypto/internal/skcipher.h' l='136' c='crypto_register_skcipher'/>
<use f='linux/include/crypto/internal/skcipher.h' l='137' c='crypto_unregister_skcipher'/>
<use f='linux/include/crypto/internal/skcipher.h' l='138' c='crypto_register_skciphers'/>
<use f='linux/include/crypto/internal/skcipher.h' l='139' c='crypto_unregister_skciphers'/>
<use f='linux/include/crypto/internal/skcipher.h' l='185' c='crypto_skcipher_alg_min_keysize'/>
<use f='linux/include/crypto/internal/skcipher.h' l='198' c='crypto_skcipher_alg_max_keysize'/>
<size>480</size>
<doc f='linux/include/crypto/skcipher.h' l='68'>/**
 * struct skcipher_alg - symmetric key cipher definition
 * @min_keysize: Minimum key size supported by the transformation. This is the
 *		 smallest key length supported by this transformation algorithm.
 *		 This must be set to one of the pre-defined values as this is
 *		 not hardware specific. Possible values for this field can be
 *		 found via git grep &quot;_MIN_KEY_SIZE&quot; include/crypto/
 * @max_keysize: Maximum key size supported by the transformation. This is the
 *		 largest key length supported by this transformation algorithm.
 *		 This must be set to one of the pre-defined values as this is
 *		 not hardware specific. Possible values for this field can be
 *		 found via git grep &quot;_MAX_KEY_SIZE&quot; include/crypto/
 * @setkey: Set key for the transformation. This function is used to either
 *	    program a supplied key into the hardware or store the key in the
 *	    transformation context for programming it later. Note that this
 *	    function does modify the transformation context. This function can
 *	    be called multiple times during the existence of the transformation
 *	    object, so one must make sure the key is properly reprogrammed into
 *	    the hardware. This function is also responsible for checking the key
 *	    length for validity. In case a software fallback was put in place in
 *	    the @cra_init call, this function might need to use the fallback if
 *	    the algorithm doesn&apos;t support all of the key sizes.
 * @encrypt: Encrypt a scatterlist of blocks. This function is used to encrypt
 *	     the supplied scatterlist containing the blocks of data. The crypto
 *	     API consumer is responsible for aligning the entries of the
 *	     scatterlist properly and making sure the chunks are correctly
 *	     sized. In case a software fallback was put in place in the
 *	     @cra_init call, this function might need to use the fallback if
 *	     the algorithm doesn&apos;t support all of the key sizes. In case the
 *	     key was stored in transformation context, the key might need to be
 *	     re-programmed into the hardware in this function. This function
 *	     shall not modify the transformation context, as this function may
 *	     be called in parallel with the same transformation object.
 * @decrypt: Decrypt a single block. This is a reverse counterpart to @encrypt
 *	     and the conditions are exactly the same.
 * @init: Initialize the cryptographic transformation object. This function
 *	  is used to initialize the cryptographic transformation object.
 *	  This function is called only once at the instantiation time, right
 *	  after the transformation context was allocated. In case the
 *	  cryptographic hardware has some special requirements which need to
 *	  be handled by software, this function shall check for the precise
 *	  requirement of the transformation and put any software fallbacks
 *	  in place.
 * @exit: Deinitialize the cryptographic transformation object. This is a
 *	  counterpart to @init, used to remove various changes set in
 *	  @init.
 * @ivsize: IV size applicable for transformation. The consumer must provide an
 *	    IV of exactly that size to perform the encrypt or decrypt operation.
 * @chunksize: Equal to the block size except for stream ciphers such as
 *	       CTR where it is set to the underlying block size.
 * @walksize: Equal to the chunk size except in cases where the algorithm is
 * 	      considerably more efficient if it can operate on multiple chunks
 * 	      in parallel. Should be a multiple of chunksize.
 * @base: Definition of a generic crypto algorithm.
 *
 * All fields except @ivsize are mandatory and must be filled.
 */</doc>
<mbr r='skcipher_alg::setkey' o='0' t='int (*)(struct crypto_skcipher *, const u8 *, unsigned int)'/>
<mbr r='skcipher_alg::encrypt' o='64' t='int (*)(struct skcipher_request *)'/>
<mbr r='skcipher_alg::decrypt' o='128' t='int (*)(struct skcipher_request *)'/>
<mbr r='skcipher_alg::init' o='192' t='int (*)(struct crypto_skcipher *)'/>
<mbr r='skcipher_alg::exit' o='256' t='void (*)(struct crypto_skcipher *)'/>
<mbr r='skcipher_alg::min_keysize' o='320' t='unsigned int'/>
<mbr r='skcipher_alg::max_keysize' o='352' t='unsigned int'/>
<mbr r='skcipher_alg::ivsize' o='384' t='unsigned int'/>
<mbr r='skcipher_alg::chunksize' o='416' t='unsigned int'/>
<mbr r='skcipher_alg::walksize' o='448' t='unsigned int'/>
<mbr r='skcipher_alg::base' o='512' t='struct crypto_alg'/>
<use f='linux/crypto/authenc.c' l='385' c='crypto_authenc_create'/>
<size>480</size>
<use f='linux/crypto/authencesn.c' l='411' c='crypto_authenc_esn_create'/>
<size>480</size>
<use f='linux/crypto/ccm.c' l='464' c='crypto_ccm_create_common'/>
<size>480</size>
<use f='linux/crypto/ctr.c' l='358' c='crypto_rfc3686_create'/>
<size>480</size>
<use f='linux/crypto/gcm.c' l='606' c='crypto_gcm_create_common'/>
<size>480</size>
<use f='linux/crypto/skcipher.c' l='777' c='skcipher_setkey_unaligned'/>
<use f='linux/crypto/skcipher.c' l='797' c='skcipher_setkey'/>
<use f='linux/crypto/skcipher.c' l='814' c='crypto_skcipher_exit_tfm'/>
<use f='linux/crypto/skcipher.c' l='822' c='crypto_skcipher_init_tfm'/>
<use f='linux/crypto/skcipher.c' l='858' c='crypto_skcipher_show'/>
<use f='linux/crypto/skcipher.c' l='858' c='crypto_skcipher_show'/>
<use f='linux/crypto/skcipher.c' l='858' c='crypto_skcipher_show'/>
<use f='linux/crypto/skcipher.c' l='858' c='crypto_skcipher_show'/>
<use f='linux/crypto/skcipher.c' l='876' c='crypto_skcipher_report'/>
<use f='linux/crypto/skcipher.c' l='876' c='crypto_skcipher_report'/>
<use f='linux/crypto/skcipher.c' l='876' c='crypto_skcipher_report'/>
<use f='linux/crypto/skcipher.c' l='876' c='crypto_skcipher_report'/>
<use f='linux/crypto/skcipher.c' l='938' c='skcipher_prepare_alg'/>
<use f='linux/crypto/skcipher.c' l='958' c='crypto_register_skcipher'/>
<use f='linux/crypto/skcipher.c' l='971' c='crypto_unregister_skcipher'/>
<use f='linux/crypto/skcipher.c' l='977' c='crypto_register_skciphers'/>
<use f='linux/crypto/skcipher.c' l='997' c='crypto_unregister_skciphers'/>
<size>480</size>
