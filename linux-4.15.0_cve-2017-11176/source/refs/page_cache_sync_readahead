<dec f='linux/include/linux/mm.h' l='2294' type='void page_cache_sync_readahead(struct address_space * mapping, struct file_ra_state * ra, struct file * filp, unsigned long offset, unsigned long size)'/>
<use f='linux/fs/ext4/dir.c' l='165' u='c' c='ext4_readdir'/>
<use f='linux/mm/filemap.c' l='2095' u='c' c='generic_file_buffered_read'/>
<use f='linux/mm/filemap.c' l='2425' u='c' c='do_sync_mmap_readahead'/>
<def f='linux/mm/readahead.c' l='495' ll='511' type='void page_cache_sync_readahead(struct address_space * mapping, struct file_ra_state * ra, struct file * filp, unsigned long offset, unsigned long req_size)'/>
<dec f='linux/mm/readahead.c' l='512' type='void page_cache_sync_readahead(struct address_space * , struct file_ra_state * , struct file * , unsigned long , unsigned long )'/>
<use f='linux/mm/readahead.c' l='512' c='page_cache_sync_readahead'/>
<use f='linux/mm/readahead.c' l='512' u='a'/>
<use f='linux/mm/readahead.c' l='512' u='a'/>
<doc f='linux/mm/readahead.c' l='481'>/**
 * page_cache_sync_readahead - generic file readahead
 * @mapping: address_space which holds the pagecache and I/O vectors
 * @ra: file_ra_state which holds the readahead state
 * @filp: passed on to -&gt;readpage() and -&gt;readpages()
 * @offset: start offset into @mapping, in pagecache page-sized units
 * @req_size: hint: total size of the read which the caller is performing in
 *            pagecache pages
 *
 * page_cache_sync_readahead() should be called when a cache miss happened:
 * it will submit the read.  The readahead logic may decide to piggyback more
 * pages onto the read request if access patterns suggest it will improve
 * performance.
 */</doc>
