<dec f='linux/include/linux/sched.h' l='1503' type='unsigned long wait_task_inactive(struct task_struct * , long match_state)'/>
<use f='linux/fs/coredump.c' l='440' u='c' c='coredump_wait'/>
<use f='linux/kernel/kthread.c' l='376' u='c' c='__kthread_bind_mask'/>
<use f='linux/kernel/ptrace.c' l='248' u='c' c='ptrace_check_attach'/>
<def f='linux/kernel/sched/core.c' l='1335' ll='1425' type='unsigned long wait_task_inactive(struct task_struct * p, long match_state)'/>
<doc f='linux/kernel/sched/core.c' l='1319'>/*
 * wait_task_inactive - wait for a thread to unschedule.
 *
 * If @match_state is nonzero, it&apos;s the @p-&gt;state value just checked and
 * not expected to change.  If it changes, i.e. @p might have woken up,
 * then return zero.  When we succeed in waiting for @p to be off its CPU,
 * we return a positive number (its total switch count).  If a second call
 * a short while later returns the same number, the caller can be sure that
 * @p has remained unscheduled the whole time.
 *
 * The caller must ensure that the task *will* unschedule sometime soon,
 * else this function might spin for a *long* time. This function can&apos;t
 * be called with interrupts off, or it may introduce deadlock with
 * smp_call_function() if an IPI is sent by the same process we are
 * waiting to become inactive.
 */</doc>
<use f='linux/kernel/smpboot.c' l='204' u='c' c='__smpboot_create_thread'/>
<use f='linux/lib/syscall.c' l='81' u='c' c='task_current_syscall'/>
<use f='linux/lib/syscall.c' l='84' u='c' c='task_current_syscall'/>
