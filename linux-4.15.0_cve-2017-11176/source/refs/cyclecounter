<def f='linux/include/linux/timecounter.h' l='39' ll='44'/>
<use f='linux/include/linux/timecounter.h' l='40'/>
<use f='linux/include/linux/timecounter.h' l='65'/>
<use f='linux/include/linux/timecounter.h' l='79' c='cyclecounter_cyc2ns'/>
<use f='linux/include/linux/timecounter.h' l='109' c='timecounter_init'/>
<use f='linux/drivers/net/ethernet/intel/e1000e/e1000.h' l='343'/>
<size>24</size>
<doc f='linux/include/linux/timecounter.h' l='25'>/**
 * struct cyclecounter - hardware abstraction for a free running counter
 *	Provides completely state-free accessors to the underlying hardware.
 *	Depending on which hardware it reads, the cycle counter may wrap
 *	around quickly. Locking rules (if necessary) have to be defined
 *	by the implementor and user of specific instances of this API.
 *
 * @read:		returns the current cycle value
 * @mask:		bitmask for two&apos;s complement
 *			subtraction of non 64 bit counters,
 *			see CYCLECOUNTER_MASK() helper macro
 * @mult:		cycle to nanosecond multiplier
 * @shift:		cycle to nanosecond divisor (power of two)
 */</doc>
<mbr r='cyclecounter::read' o='0' t='u64 (*)(const struct cyclecounter *)'/>
<mbr r='cyclecounter::mask' o='64' t='u64'/>
<mbr r='cyclecounter::mult' o='128' t='u32'/>
<mbr r='cyclecounter::shift' o='160' t='u32'/>
<use f='linux/drivers/net/ethernet/intel/e1000e/netdev.c' l='4389' c='e1000e_cyclecounter_read'/>
<size>24</size>
<use f='linux/kernel/time/timecounter.c' l='22' c='timecounter_init'/>
<use f='linux/kernel/time/timecounter.c' l='82' c='cc_cyc2ns_backwards'/>
<size>24</size>
<use f='linux/include/sound/hdaudio.h' l='448'/>
<size>24</size>
<use f='linux/sound/hda/hdac_stream.c' l='468' c='azx_cc_read'/>
<use f='linux/sound/hda/hdac_stream.c' l='479' c='azx_timecounter_init'/>
<size>24</size>
