<dec f='linux/include/linux/blkdev.h' l='1302' type='void blk_start_plug(struct blk_plug * )'/>
<def f='linux/block/blk-core.c' l='3455' ll='3473' type='void blk_start_plug(struct blk_plug * plug)'/>
<dec f='linux/block/blk-core.c' l='3474' type='void blk_start_plug(struct blk_plug * )'/>
<use f='linux/block/blk-core.c' l='3474' c='blk_start_plug'/>
<use f='linux/block/blk-core.c' l='3474' u='a'/>
<use f='linux/block/blk-core.c' l='3474' u='a'/>
<doc f='linux/block/blk-core.c' l='3441'>/**
 * blk_start_plug - initialize blk_plug and track it inside the task_struct
 * @plug:	The &amp;struct blk_plug that needs to be initialized
 *
 * Description:
 *   Tracking blk_plug inside the task_struct will help with auto-flushing the
 *   pending I/O should the task end up blocking between blk_start_plug() and
 *   blk_finish_plug(). This is important from a performance perspective, but
 *   also ensures that we don&apos;t deadlock. For instance, if the task is blocking
 *   for a memory allocation, memory reclaim could end up wanting to free a
 *   page belonging to that request that is currently residing in our private
 *   plug. By flushing the pending I/O when the process goes to sleep, we avoid
 *   this kind of deadlock.
 */</doc>
<use f='linux/block/blk-lib.c' l='120' u='c' c='blkdev_issue_discard'/>
<use f='linux/block/blk-lib.c' l='213' u='c' c='blkdev_issue_write_same'/>
<use f='linux/block/blk-lib.c' l='380' u='c' c='blkdev_issue_zeroout'/>
<use f='linux/drivers/md/dm-kcopyd.c' l='631' u='c' c='do_work'/>
<use f='linux/drivers/md/dm.c' l='1161' u='c' c='dm_offload_start'/>
<use f='linux/drivers/md/md.c' l='8354' u='c' c='md_do_sync'/>
<use f='linux/fs/aio.c' l='1662' u='c' c='do_io_submit'/>
<use f='linux/fs/block_dev.c' l='351' u='c' c='__blkdev_direct_IO'/>
<use f='linux/fs/block_dev.c' l='1892' u='c' c='blkdev_write_iter'/>
<use f='linux/fs/buffer.c' l='710' u='c' c='fsync_buffers_list'/>
<use f='linux/fs/direct-io.c' l='1311' u='c' c='do_blockdev_direct_IO'/>
<use f='linux/fs/ext4/inode.c' l='2744' u='c' c='ext4_writepages'/>
<use f='linux/fs/ext4/inode.c' l='2813' u='c' c='ext4_writepages'/>
<use f='linux/fs/fs-writeback.c' l='1681' u='c' c='writeback_inodes_wb'/>
<use f='linux/fs/fs-writeback.c' l='1720' u='c' c='wb_writeback'/>
<use f='linux/fs/iomap.c' l='1035' u='c' c='iomap_dio_rw'/>
<use f='linux/fs/jbd2/checkpoint.c' l='187' u='c' c='__flush_batch'/>
<use f='linux/fs/jbd2/commit.c' l='533' u='c' c='jbd2_journal_commit_transaction'/>
<use f='linux/fs/mpage.c' l='704' u='c' c='mpage_writepages'/>
<use f='linux/mm/madvise.c' l='842' u='c' c='SYSC_madvise'/>
<use f='linux/mm/page-writeback.c' l='2324' u='c' c='generic_writepages'/>
<use f='linux/mm/readahead.c' l='118' u='c' c='read_pages'/>
<use f='linux/mm/swap_state.c' l='579' u='c' c='swapin_readahead'/>
<use f='linux/mm/swap_state.c' l='735' u='c' c='do_swap_page_readahead'/>
<use f='linux/mm/vmscan.c' l='2416' u='c' c='shrink_node_memcg'/>
