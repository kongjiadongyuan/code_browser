<dec f='linux/mm/internal.h' l='215' type='int find_suitable_fallback(struct free_area * area, unsigned int order, int migratetype, bool only_stealable, bool * can_steal)'/>
<use f='linux/mm/compaction.c' l='1374' u='c' c='__compact_finished'/>
<def f='linux/mm/page_alloc.c' l='2096' ll='2125' type='int find_suitable_fallback(struct free_area * area, unsigned int order, int migratetype, bool only_stealable, bool * can_steal)'/>
<use f='linux/mm/page_alloc.c' l='2274' u='c' c='__rmqueue_fallback'/>
<use f='linux/mm/page_alloc.c' l='2300' u='c' c='__rmqueue_fallback'/>
<doc f='linux/mm/page_alloc.c' l='2090'>/*
 * Check whether there is a suitable fallback freepage with requested order.
 * If only_stealable is true, this function returns fallback_mt only if
 * we can steal other freepages all together. This would help to reduce
 * fragmentation due to mixed migratetype pages in one pageblock.
 */</doc>
