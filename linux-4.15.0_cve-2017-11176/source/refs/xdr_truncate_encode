<dec f='linux/include/linux/sunrpc/xdr.h' l='229' type='void xdr_truncate_encode(struct xdr_stream * xdr, size_t len)'/>
<def f='linux/net/sunrpc/xdr.c' l='603' ll='651' type='void xdr_truncate_encode(struct xdr_stream * xdr, size_t len)'/>
<dec f='linux/net/sunrpc/xdr.c' l='652' type='void xdr_truncate_encode(struct xdr_stream * , size_t )'/>
<use f='linux/net/sunrpc/xdr.c' l='652' c='xdr_truncate_encode'/>
<use f='linux/net/sunrpc/xdr.c' l='652' u='a'/>
<use f='linux/net/sunrpc/xdr.c' l='652' u='a'/>
<doc f='linux/net/sunrpc/xdr.c' l='584'>/**
 * xdr_truncate_encode - truncate an encode buffer
 * @xdr: pointer to xdr_stream
 * @len: new length of buffer
 *
 * Truncates the xdr stream, so that xdr-&gt;buf-&gt;len == len,
 * and xdr-&gt;p points at offset len from the start of the buffer, and
 * head, tail, and page lengths are adjusted to correspond.
 *
 * If this means moving xdr-&gt;p to a different buffer, we assume that
 * that the end pointer should be set to the end of the current page,
 * except in the case of the head buffer when we assume the head
 * buffer&apos;s current length represents the end of the available buffer.
 *
 * This is *not* safe to use on a buffer that already has inlined page
 * cache pages (as in a zero-copy server read reply), except for the
 * simple case of truncating from one position in the tail to another.
 *
 */</doc>
