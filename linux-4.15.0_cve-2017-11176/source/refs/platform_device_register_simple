<def f='linux/include/linux/platform_device.h' l='136' ll='142' type='struct platform_device * platform_device_register_simple(const char * name, int id, const struct resource * res, unsigned int num)'/>
<use f='linux/arch/x86/kernel/cpu/microcode/core.c' l='742' u='c' c='microcode_init'/>
<doc f='linux/include/linux/platform_device.h' l='114'>/**
 * platform_device_register_simple - add a platform-level device and its resources
 * @name: base name of the device we&apos;re adding
 * @id: instance id
 * @res: set of resources that needs to be allocated for the device
 * @num: number of resources
 *
 * This function creates a simple platform device that requires minimal
 * resource and memory management. Canned release function freeing memory
 * allocated for the device allows drivers using such devices to be
 * unloaded without waiting for the last reference to the device to be
 * dropped.
 *
 * This interface is primarily intended for use with legacy drivers which
 * probe hardware directly.  Because such drivers create sysfs device nodes
 * themselves, rather than letting system infrastructure handle such device
 * enumeration tasks, they don&apos;t fully conform to the Linux driver model.
 * In particular, when such drivers are built as modules, they can&apos;t be
 * &quot;hotplugged&quot;.
 *
 * Returns &amp;struct platform_device pointer on success, or ERR_PTR() on error.
 */</doc>
<use f='linux/arch/x86/kernel/pcspeaker.c' l='10' u='c' c='add_pcspkr'/>
<use f='linux/kernel/time/alarmtimer.c' l='872' u='c' c='alarmtimer_init'/>
<use f='linux/net/wireless/reg.c' l='3687' u='c' c='regulatory_init'/>
