<dec f='linux/include/linux/i2c.h' l='363' type='struct i2c_client * i2c_new_device(struct i2c_adapter * adap, const struct i2c_board_info * info)'/>
<doc f='linux/include/linux/i2c.h' l='358'>/* Add-on boards should register/unregister their devices; e.g. a board
 * with integrated I2C, a config eeprom, sensors, and a codec that&apos;s
 * used in conjunction with the primary hardware.
 */</doc>
<use f='linux/drivers/gpu/drm/drm_encoder_slave.c' l='64' u='c' c='drm_i2c_encoder_init'/>
<use f='linux/drivers/i2c/busses/i2c-i801.c' l='1103' u='c' c='dmi_check_onboard_device'/>
<use f='linux/drivers/i2c/busses/i2c-i801.c' l='1152' u='c' c='i801_probe_optional_slaves'/>
<use f='linux/drivers/i2c/i2c-core-acpi.c' l='182' u='c' c='i2c_acpi_register_device'/>
<use f='linux/drivers/i2c/i2c-core-acpi.c' l='420' u='c' c='i2c_acpi_new_device'/>
<def f='linux/drivers/i2c/i2c-core-base.c' l='735' ll='811' type='struct i2c_client * i2c_new_device(struct i2c_adapter * adap, const struct i2c_board_info * info)'/>
<dec f='linux/drivers/i2c/i2c-core-base.c' l='812' type='struct i2c_client * i2c_new_device(struct i2c_adapter * , const struct i2c_board_info * )'/>
<use f='linux/drivers/i2c/i2c-core-base.c' l='812' c='i2c_new_device'/>
<use f='linux/drivers/i2c/i2c-core-base.c' l='812' u='a'/>
<use f='linux/drivers/i2c/i2c-core-base.c' l='812' u='a'/>
<use f='linux/drivers/i2c/i2c-core-base.c' l='884' u='c' c='i2c_new_dummy'/>
<use f='linux/drivers/i2c/i2c-core-base.c' l='1007' u='c' c='i2c_sysfs_new_device'/>
<use f='linux/drivers/i2c/i2c-core-base.c' l='1120' u='c' c='i2c_scan_static_board_info'/>
<use f='linux/drivers/i2c/i2c-core-base.c' l='2135' u='c' c='i2c_detect_address'/>
<use f='linux/drivers/i2c/i2c-core-base.c' l='2234' u='c' c='i2c_new_probed_device'/>
<doc f='linux/drivers/i2c/i2c-core-base.c' l='719'>/**
 * i2c_new_device - instantiate an i2c device
 * @adap: the adapter managing the device
 * @info: describes one I2C device; bus_num is ignored
 * Context: can sleep
 *
 * Create an i2c device. Binding is handled through driver model
 * probe()/remove() methods.  A driver may be bound to this device when we
 * return from this function, or any later moment (e.g. maybe hotplugging will
 * load the driver module).  This call is not appropriate for use by mainboard
 * initialization logic, which usually runs during an arch_initcall() long
 * before any i2c_adapter could exist.
 *
 * This returns the new i2c client, which may be saved for later use with
 * i2c_unregister_device(); or NULL to indicate an error.
 */</doc>
<use f='linux/drivers/i2c/i2c-core-smbus.c' l='626' u='c' c='i2c_setup_smbus_alert'/>
