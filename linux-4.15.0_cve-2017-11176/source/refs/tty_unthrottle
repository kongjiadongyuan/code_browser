<dec f='linux/include/linux/tty.h' l='484' type='void tty_unthrottle(struct tty_struct * tty)'/>
<use f='linux/drivers/tty/n_tty.c' l='1900' u='c' c='n_tty_open'/>
<def f='linux/drivers/tty/tty_ioctl.c' l='134' ll='142' type='void tty_unthrottle(struct tty_struct * tty)'/>
<dec f='linux/drivers/tty/tty_ioctl.c' l='143' type='void tty_unthrottle(struct tty_struct * )'/>
<use f='linux/drivers/tty/tty_ioctl.c' l='143' c='tty_unthrottle'/>
<use f='linux/drivers/tty/tty_ioctl.c' l='143' u='a'/>
<use f='linux/drivers/tty/tty_ioctl.c' l='143' u='a'/>
<use f='linux/drivers/tty/tty_ioctl.c' l='861' u='c' c='__tty_perform_flush'/>
<use f='linux/drivers/tty/tty_ioctl.c' l='867' u='c' c='__tty_perform_flush'/>
<doc f='linux/drivers/tty/tty_ioctl.c' l='121'>/**
 *	tty_unthrottle		-	flow control
 *	@tty: terminal
 *
 *	Indicate that a tty may continue transmitting data down the stack.
 *	Takes the termios rwsem to protect against parallel throttle/unthrottle
 *	and also to ensure the driver can consistently reference its own
 *	termios data at this point when implementing software flow control.
 *
 *	Drivers should however remember that the stack can issue a throttle,
 *	then change flow control method, then unthrottle.
 */</doc>
