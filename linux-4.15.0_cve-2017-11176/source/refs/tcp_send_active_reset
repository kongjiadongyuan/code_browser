<dec f='linux/include/net/tcp.h' l='536' type='void tcp_send_active_reset(struct sock * sk, gfp_t priority)'/>
<use f='linux/net/ipv4/tcp.c' l='2199' u='c' c='tcp_close'/>
<use f='linux/net/ipv4/tcp.c' l='2279' u='c' c='tcp_close'/>
<use f='linux/net/ipv4/tcp.c' l='2298' u='c' c='tcp_close'/>
<use f='linux/net/ipv4/tcp.c' l='2388' u='c' c='tcp_disconnect'/>
<use f='linux/net/ipv4/tcp.c' l='3539' u='c' c='tcp_abort'/>
<def f='linux/net/ipv4/tcp_output.c' l='3121' ll='3147' type='void tcp_send_active_reset(struct sock * sk, gfp_t priority)'/>
<doc f='linux/net/ipv4/tcp_output.c' l='3116'>/* We get here when a process closes a file descriptor (either due to
 * an explicit close() or as a byproduct of exit()&apos;ing) and there
 * was unread data in the receive queue.  This behavior is recommended
 * by RFC 2525, section 2.17.  -DaveM
 */</doc>
<use f='linux/net/ipv4/tcp_timer.c' l='87' u='c' c='tcp_out_of_resources'/>
<use f='linux/net/ipv4/tcp_timer.c' l='661' u='c' c='tcp_keepalive_timer'/>
<use f='linux/net/ipv4/tcp_timer.c' l='686' u='c' c='tcp_keepalive_timer'/>
