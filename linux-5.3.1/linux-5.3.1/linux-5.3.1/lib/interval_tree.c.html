<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>interval_tree.c source code [linux-5.3.1/lib/interval_tree.c] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'linux-5.3.1/lib/interval_tree.c'; var root_path = '../..'; var data_path = '../../../data'; var ecma_script_api_version = 2;</script>
<script src='../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='..'>linux-5.3.1</a>/<a href='./'>lib</a>/<a href='interval_tree.c.html'>interval_tree.c</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>// SPDX-License-Identifier: GPL-2.0-only</i></td></tr>
<tr><th id="2">2</th><td><u>#include <a href="../include/linux/interval_tree.h.html">&lt;linux/interval_tree.h&gt;</a></u></td></tr>
<tr><th id="3">3</th><td><u>#include <a href="../include/linux/interval_tree_generic.h.html">&lt;linux/interval_tree_generic.h&gt;</a></u></td></tr>
<tr><th id="4">4</th><td><u>#include <a href="../include/linux/compiler.h.html">&lt;linux/compiler.h&gt;</a></u></td></tr>
<tr><th id="5">5</th><td><u>#include <a href="../include/linux/export.h.html">&lt;linux/export.h&gt;</a></u></td></tr>
<tr><th id="6">6</th><td></td></tr>
<tr><th id="7">7</th><td><u>#define <dfn class="macro" id="_M/START" data-ref="_M/START">START</dfn>(node) ((node)-&gt;<a class="ref field" href="../include/linux/interval_tree.h.html#interval_tree_node::start" title='interval_tree_node::start' data-ref="interval_tree_node::start" data-ref-filename="interval_tree_node..start">start</a>)</u></td></tr>
<tr><th id="8">8</th><td><u>#define <dfn class="macro" id="_M/LAST" data-ref="_M/LAST">LAST</dfn>(node)  ((node)-&gt;<a class="ref field" href="../include/linux/interval_tree.h.html#interval_tree_node::last" title='interval_tree_node::last' data-ref="interval_tree_node::last" data-ref-filename="interval_tree_node..last">last</a>)</u></td></tr>
<tr><th id="9">9</th><td></td></tr>
<tr><th id="10">10</th><td><a class="macro" href="../include/linux/interval_tree_generic.h.html#28" title="static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((no_instrument_function)) unsigned long interval_tree_compute_subtree_last(struct interval_tree_node *node) { unsigned long max = ((node)-&gt;last), subtree_last; if (node-&gt;rb.rb_left) { subtree_last = ({ void *__mptr = (void *)(node-&gt;rb.rb_left); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(node-&gt;rb.rb_left)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(node-&gt;rb.rb_left)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); })-&gt;__subtree_last; if (max &lt; subtree_last) max = subtree_last; } if (node-&gt;rb.rb_right) { subtree_last = ({ void *__mptr = (void *)(node-&gt;rb.rb_right); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(node-&gt;rb.rb_right)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(node-&gt;rb.rb_right)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); })-&gt;__subtree_last; if (max &lt; subtree_last) max = subtree_last; } return max; } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((no_instrument_function)) void interval_tree_augment_propagate(struct rb_node *rb, struct rb_node *stop) { while (rb != stop) { struct interval_tree_node *node = ({ void *__mptr = (void *)(rb); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(rb)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(rb)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); unsigned long augmented = interval_tree_compute_subtree_last(node); if (node-&gt;__subtree_last == augmented) break; node-&gt;__subtree_last = augmented; rb = ((struct rb_node *)((&amp;node-&gt;rb)-&gt;__rb_parent_color &amp; ~3)); } } static inline __attribute__((__gnu_inline__)) __attribute__((__unused__)) __attribute__((no_instrument_function)) void interval_tree_augment_copy(struct rb_node *rb_old, struct rb_node *rb_new) { struct interval_tree_node *old = ({ void *__mptr = (void *)(rb_old); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(rb_old)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(rb_old)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); struct interval_tree_node *new = ({ void *__mptr = (void *)(rb_new); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(rb_new)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(rb_new)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); new-&gt;__subtree_last = old-&gt;__subtree_last; } static void interval_tree_augment_rotate(struct rb_node *rb_old, struct rb_node *rb_new) { struct interval_tree_node *old = ({ void *__mptr = (void *)(rb_old); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(rb_old)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(rb_old)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); struct interval_tree_node *new = ({ void *__mptr = (void *)(rb_new); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(rb_new)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(rb_new)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); new-&gt;__subtree_last = old-&gt;__subtree_last; old-&gt;__subtree_last = interval_tree_compute_subtree_last(old); } static const struct rb_augment_callbacks interval_tree_augment = { .propagate = interval_tree_augment_propagate, .copy = interval_tree_augment_copy, .rotate = interval_tree_augment_rotate }; void interval_tree_insert(struct interval_tree_node *node, struct rb_root_cached *root) { struct rb_node **link = &amp;root-&gt;rb_root.rb_node, *rb_parent = ((void *)0); unsigned long start = ((node)-&gt;start), last = ((node)-&gt;last); struct interval_tree_node *parent; bool leftmost = true; while (*link) { rb_parent = *link; parent = ({ void *__mptr = (void *)(rb_parent); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(rb_parent)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(rb_parent)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); if (parent-&gt;__subtree_last &lt; last) parent-&gt;__subtree_last = last; if (start &lt; ((parent)-&gt;start)) link = &amp;parent-&gt;rb.rb_left; else { link = &amp;parent-&gt;rb.rb_right; leftmost = false; } } node-&gt;__subtree_last = last; rb_link_node(&amp;node-&gt;rb, rb_parent, link); rb_insert_augmented_cached(&amp;node-&gt;rb, root, leftmost, &amp;interval_tree_augment); } void interval_tree_remove(struct interval_tree_node *node, struct rb_root_cached *root) { rb_erase_augmented_cached(&amp;node-&gt;rb, root, &amp;interval_tree_augment); } static struct interval_tree_node * interval_tree_subtree_search(struct interval_tree_node *node, unsigned long start, unsigned long last) { while (true) { if (node-&gt;rb.rb_left) { struct interval_tree_node *left = ({ void *__mptr = (void *)(node-&gt;rb.rb_left); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(node-&gt;rb.rb_left)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(node-&gt;rb.rb_left)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); if (start &lt;= left-&gt;__subtree_last) { node = left; continue; } } if (((node)-&gt;start) &lt;= last) { if (start &lt;= ((node)-&gt;last)) return node; if (node-&gt;rb.rb_right) { node = ({ void *__mptr = (void *)(node-&gt;rb.rb_right); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(node-&gt;rb.rb_right)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(node-&gt;rb.rb_right)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); if (start &lt;= node-&gt;__subtree_last) continue; } } return ((void *)0); } } struct interval_tree_node * interval_tree_iter_first(struct rb_root_cached *root, unsigned long start, unsigned long last) { struct interval_tree_node *node, *leftmost; if (!root-&gt;rb_root.rb_node) return ((void *)0); node = ({ void *__mptr = (void *)(root-&gt;rb_root.rb_node); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(root-&gt;rb_root.rb_node)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(root-&gt;rb_root.rb_node)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); if (node-&gt;__subtree_last &lt; start) return ((void *)0); leftmost = ({ void *__mptr = (void *)(root-&gt;rb_leftmost); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(root-&gt;rb_leftmost)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(root-&gt;rb_leftmost)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); if (((leftmost)-&gt;start) &gt; last) return ((void *)0); return interval_tree_subtree_search(node, start, last); } struct interval_tree_node * interval_tree_iter_next(struct interval_tree_node *node, unsigned long start, unsigned long last) { struct rb_node *rb = node-&gt;rb.rb_right, *prev; while (true) { if (rb) { struct interval_tree_node *right = ({ void *__mptr = (void *)(rb); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(rb)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(rb)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); if (start &lt;= right-&gt;__subtree_last) return interval_tree_subtree_search(right, start, last); } do { rb = ((struct rb_node *)((&amp;node-&gt;rb)-&gt;__rb_parent_color &amp; ~3)); if (!rb) return ((void *)0); prev = &amp;node-&gt;rb; node = ({ void *__mptr = (void *)(rb); do { extern void __compiletime_assert_12(void) ; if (!(!(!__builtin_types_compatible_p(typeof(*(rb)), typeof(((struct interval_tree_node *)0)-&gt;rb)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(rb)), typeof(void))))) __compiletime_assert_12(); } while (0); ((struct interval_tree_node *)(__mptr - __builtin_offsetof(struct interval_tree_node, rb))); }); rb = node-&gt;rb.rb_right; } while (prev == rb); if (last &lt; ((node)-&gt;start)) return ((void *)0); else if (start &lt;= ((node)-&gt;last)) return node; } }" data-ref="_M/INTERVAL_TREE_DEFINE">INTERVAL_TREE_DEFINE</a>(<b>struct</b> <a class="type" href="../include/linux/interval_tree.h.html#interval_tree_node" title='interval_tree_node' data-ref="interval_tree_node" data-ref-filename="interval_tree_node">interval_tree_node</a>, <a class="ref field" href="../include/linux/interval_tree.h.html#interval_tree_node::rb" title='interval_tree_node::rb' data-ref="interval_tree_node::rb" data-ref-filename="interval_tree_node..rb">rb</a>,</td></tr>
<tr><th id="11">11</th><td>		     <em>unsigned</em> <em>long</em>, <a class="ref field" href="../include/linux/interval_tree.h.html#interval_tree_node::__subtree_last" title='interval_tree_node::__subtree_last' data-ref="interval_tree_node::__subtree_last" data-ref-filename="interval_tree_node..__subtree_last">__subtree_last</a>,</td></tr>
<tr><th id="12">12</th><td>		     START, LAST,, interval_tree)</td></tr>
<tr><th id="13">13</th><td></td></tr>
<tr><th id="14">14</th><td><a class="macro" href="../include/linux/export.h.html#126" title="extern typeof(interval_tree_insert) interval_tree_insert; static const char __kstrtab_interval_tree_insert[] __attribute__((section(&quot;__ksymtab_strings&quot;), used, aligned(1))) = &quot;interval_tree_insert&quot;; static void * __attribute__((__section__(&quot;.discard.addressable&quot;))) __attribute__((__used__)) __addressable_interval_tree_insert14 = (void *)&amp;interval_tree_insert; asm(&quot;	.section \&quot;___ksymtab&quot; &quot;_gpl&quot; &quot;+&quot; &quot;interval_tree_insert&quot; &quot;\&quot;, \&quot;a\&quot;	\n&quot; &quot;	.balign	8					\n&quot; &quot;__ksymtab_&quot; &quot;interval_tree_insert&quot; &quot;:				\n&quot; &quot;	.long	&quot; &quot;interval_tree_insert&quot; &quot;- .				\n&quot; &quot;	.long	__kstrtab_&quot; &quot;interval_tree_insert&quot; &quot;- .			\n&quot; &quot;	.previous					\n&quot;)" data-ref="_M/EXPORT_SYMBOL_GPL">EXPORT_SYMBOL_GPL</a>(<a class="decl fn" href="#10" title='interval_tree_insert' data-ref="interval_tree_insert" data-ref-filename="interval_tree_insert"><a class="ref fn" href="#10" title='interval_tree_insert' data-ref="interval_tree_insert" data-ref-filename="interval_tree_insert"><a class="ref fn" href="#10" title='interval_tree_insert' data-ref="interval_tree_insert" data-ref-filename="interval_tree_insert">interval_tree_insert</a></a></a>);</td></tr>
<tr><th id="15">15</th><td><a class="macro" href="../include/linux/export.h.html#126" title="extern typeof(interval_tree_remove) interval_tree_remove; static const char __kstrtab_interval_tree_remove[] __attribute__((section(&quot;__ksymtab_strings&quot;), used, aligned(1))) = &quot;interval_tree_remove&quot;; static void * __attribute__((__section__(&quot;.discard.addressable&quot;))) __attribute__((__used__)) __addressable_interval_tree_remove15 = (void *)&amp;interval_tree_remove; asm(&quot;	.section \&quot;___ksymtab&quot; &quot;_gpl&quot; &quot;+&quot; &quot;interval_tree_remove&quot; &quot;\&quot;, \&quot;a\&quot;	\n&quot; &quot;	.balign	8					\n&quot; &quot;__ksymtab_&quot; &quot;interval_tree_remove&quot; &quot;:				\n&quot; &quot;	.long	&quot; &quot;interval_tree_remove&quot; &quot;- .				\n&quot; &quot;	.long	__kstrtab_&quot; &quot;interval_tree_remove&quot; &quot;- .			\n&quot; &quot;	.previous					\n&quot;)" data-ref="_M/EXPORT_SYMBOL_GPL">EXPORT_SYMBOL_GPL</a>(<a class="decl fn" href="#10" title='interval_tree_remove' data-ref="interval_tree_remove" data-ref-filename="interval_tree_remove"><a class="ref fn" href="#10" title='interval_tree_remove' data-ref="interval_tree_remove" data-ref-filename="interval_tree_remove"><a class="ref fn" href="#10" title='interval_tree_remove' data-ref="interval_tree_remove" data-ref-filename="interval_tree_remove">interval_tree_remove</a></a></a>);</td></tr>
<tr><th id="16">16</th><td><a class="macro" href="../include/linux/export.h.html#126" title="extern typeof(interval_tree_iter_first) interval_tree_iter_first; static const char __kstrtab_interval_tree_iter_first[] __attribute__((section(&quot;__ksymtab_strings&quot;), used, aligned(1))) = &quot;interval_tree_iter_first&quot;; static void * __attribute__((__section__(&quot;.discard.addressable&quot;))) __attribute__((__used__)) __addressable_interval_tree_iter_first16 = (void *)&amp;interval_tree_iter_first; asm(&quot;	.section \&quot;___ksymtab&quot; &quot;_gpl&quot; &quot;+&quot; &quot;interval_tree_iter_first&quot; &quot;\&quot;, \&quot;a\&quot;	\n&quot; &quot;	.balign	8					\n&quot; &quot;__ksymtab_&quot; &quot;interval_tree_iter_first&quot; &quot;:				\n&quot; &quot;	.long	&quot; &quot;interval_tree_iter_first&quot; &quot;- .				\n&quot; &quot;	.long	__kstrtab_&quot; &quot;interval_tree_iter_first&quot; &quot;- .			\n&quot; &quot;	.previous					\n&quot;)" data-ref="_M/EXPORT_SYMBOL_GPL">EXPORT_SYMBOL_GPL</a>(<a class="decl fn" href="#10" title='interval_tree_iter_first' data-ref="interval_tree_iter_first" data-ref-filename="interval_tree_iter_first"><a class="ref fn" href="#10" title='interval_tree_iter_first' data-ref="interval_tree_iter_first" data-ref-filename="interval_tree_iter_first"><a class="ref fn" href="#10" title='interval_tree_iter_first' data-ref="interval_tree_iter_first" data-ref-filename="interval_tree_iter_first">interval_tree_iter_first</a></a></a>);</td></tr>
<tr><th id="17">17</th><td><a class="macro" href="../include/linux/export.h.html#126" title="extern typeof(interval_tree_iter_next) interval_tree_iter_next; static const char __kstrtab_interval_tree_iter_next[] __attribute__((section(&quot;__ksymtab_strings&quot;), used, aligned(1))) = &quot;interval_tree_iter_next&quot;; static void * __attribute__((__section__(&quot;.discard.addressable&quot;))) __attribute__((__used__)) __addressable_interval_tree_iter_next17 = (void *)&amp;interval_tree_iter_next; asm(&quot;	.section \&quot;___ksymtab&quot; &quot;_gpl&quot; &quot;+&quot; &quot;interval_tree_iter_next&quot; &quot;\&quot;, \&quot;a\&quot;	\n&quot; &quot;	.balign	8					\n&quot; &quot;__ksymtab_&quot; &quot;interval_tree_iter_next&quot; &quot;:				\n&quot; &quot;	.long	&quot; &quot;interval_tree_iter_next&quot; &quot;- .				\n&quot; &quot;	.long	__kstrtab_&quot; &quot;interval_tree_iter_next&quot; &quot;- .			\n&quot; &quot;	.previous					\n&quot;)" data-ref="_M/EXPORT_SYMBOL_GPL">EXPORT_SYMBOL_GPL</a>(<a class="decl fn" href="#10" title='interval_tree_iter_next' data-ref="interval_tree_iter_next" data-ref-filename="interval_tree_iter_next"><a class="ref fn" href="#10" title='interval_tree_iter_next' data-ref="interval_tree_iter_next" data-ref-filename="interval_tree_iter_next"><a class="ref fn" href="#10" title='interval_tree_iter_next' data-ref="interval_tree_iter_next" data-ref-filename="interval_tree_iter_next">interval_tree_iter_next</a></a></a>);</td></tr>
<tr><th id="18">18</th><td></td></tr>
</table><hr/><p id='footer'>
Generated on <em>2020-Jun-10</em> from project linux-5.3.1 revision <em>5.3.1</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
