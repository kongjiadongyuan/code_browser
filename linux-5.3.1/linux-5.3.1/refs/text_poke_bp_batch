<dec f='linux-5.3.1/arch/x86/include/asm/text-patching.h' l='55' type='void text_poke_bp_batch(struct text_poke_loc * tp, unsigned int nr_entries)'/>
<def f='linux-5.3.1/arch/x86/kernel/alternative.c' l='1028' ll='1088' type='void text_poke_bp_batch(struct text_poke_loc * tp, unsigned int nr_entries)'/>
<use f='linux-5.3.1/arch/x86/kernel/alternative.c' l='1116' u='c' c='text_poke_bp'/>
<doc f='linux-5.3.1/arch/x86/kernel/alternative.c' l='1007'>/**
 * text_poke_bp_batch() -- update instructions on live kernel on SMP
 * @tp:			vector of instructions to patch
 * @nr_entries:		number of entries in the vector
 *
 * Modify multi-byte instruction by using int3 breakpoint on SMP.
 * We completely avoid stop_machine() here, and achieve the
 * synchronization using int3 breakpoint.
 *
 * The way it is done:
 * 	- For each entry in the vector:
 *		- add a int3 trap to the address that will be patched
 *	- sync cores
 *	- For each entry in the vector:
 *		- update all but the first byte of the patched range
 *	- sync cores
 *	- For each entry in the vector:
 *		- replace the first byte (int3) by the first byte of
 *		  replacing opcode
 *	- sync cores
 */</doc>
<use f='linux-5.3.1/arch/x86/kernel/jump_label.c' l='167' u='c' c='arch_jump_label_transform_apply'/>
