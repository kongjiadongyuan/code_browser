<dec f='linux-5.3.1/include/net/mac80211.h' l='4952' type='struct sk_buff * ieee80211_get_buffered_bc(struct ieee80211_hw * hw, struct ieee80211_vif * vif)'/>
<doc f='linux-5.3.1/include/net/mac80211.h' l='4930'>/**
 * ieee80211_get_buffered_bc - accessing buffered broadcast and multicast frames
 * @hw: pointer as obtained from ieee80211_alloc_hw().
 * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.
 *
 * Function for accessing buffered broadcast and multicast frames. If
 * hardware/firmware does not implement buffering of broadcast/multicast
 * frames when power saving is used, 802.11 code buffers them in the host
 * memory. The low-level driver uses this function to fetch next buffered
 * frame. In most cases, this is used when generating beacon frame.
 *
 * Return: A pointer to the next buffered skb or NULL if no more buffered
 * frames are available.
 *
 * Note: buffered frames are returned only after DTIM beacon frame was
 * generated with ieee80211_beacon_get() and the low-level driver must thus
 * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc() returns
 * NULL if the previous generated beacon was not DTIM, so the low-level driver
 * does not need to check for DTIM beacons separately and should be able to
 * use common code for all beacons.
 */</doc>
<def f='linux-5.3.1/net/mac80211/tx.c' l='4855' ll='4926' type='struct sk_buff * ieee80211_get_buffered_bc(struct ieee80211_hw * hw, struct ieee80211_vif * vif)'/>
<dec f='linux-5.3.1/net/mac80211/tx.c' l='4927' type='struct sk_buff * ieee80211_get_buffered_bc(struct ieee80211_hw * , struct ieee80211_vif * )'/>
<use f='linux-5.3.1/net/mac80211/tx.c' l='4927' c='ieee80211_get_buffered_bc'/>
<use f='linux-5.3.1/net/mac80211/tx.c' l='4927' u='a'/>
