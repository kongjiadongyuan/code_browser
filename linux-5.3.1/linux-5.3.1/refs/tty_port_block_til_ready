<dec f='linux-5.3.1/include/linux/tty.h' l='692' type='int tty_port_block_til_ready(struct tty_port * port, struct tty_struct * tty, struct file * filp)'/>
<def f='linux-5.3.1/drivers/tty/tty_port.c' l='461' ll='540' type='int tty_port_block_til_ready(struct tty_port * port, struct tty_struct * tty, struct file * filp)'/>
<dec f='linux-5.3.1/drivers/tty/tty_port.c' l='541' type='int tty_port_block_til_ready(struct tty_port * , struct tty_struct * , struct file * )'/>
<use f='linux-5.3.1/drivers/tty/tty_port.c' l='541' c='tty_port_block_til_ready'/>
<use f='linux-5.3.1/drivers/tty/tty_port.c' l='541' u='a'/>
<use f='linux-5.3.1/drivers/tty/tty_port.c' l='697' u='c' c='tty_port_open'/>
<doc f='linux-5.3.1/drivers/tty/tty_port.c' l='437'>/**
 *	tty_port_block_til_ready	-	Waiting logic for tty open
 *	@port: the tty port being opened
 *	@tty: the tty device being bound
 *	@filp: the file pointer of the opener or NULL
 *
 *	Implement the core POSIX/SuS tty behaviour when opening a tty device.
 *	Handles:
 *		- hangup (both before and during)
 *		- non blocking open
 *		- rts/dtr/dcd
 *		- signals
 *		- port flags and counts
 *
 *	The passed tty_port must implement the carrier_raised method if it can
 *	do carrier detect and the dtr_rts method if it supports software
 *	management of these lines. Note that the dtr/rts raise is done each
 *	iteration as a hangup may have previously dropped them while we wait.
 *
 *	Caller holds tty lock.
 *
 *      NB: May drop and reacquire tty lock when blocking, so tty and tty_port
 *      may have changed state (eg., may have been hung up).
 */</doc>
