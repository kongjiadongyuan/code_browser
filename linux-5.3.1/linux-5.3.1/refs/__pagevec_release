<dec f='linux-5.3.1/include/linux/pagevec.h' l='26' type='void __pagevec_release(struct pagevec * pvec)'/>
<use f='linux-5.3.1/include/linux/pagevec.h' l='88' u='c' c='pagevec_release'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_gem.c' l='528' u='c' c='drm_gem_check_release_pagevec'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_shmem.c' l='21' u='c' c='check_release_pagevec'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_gem_gtt.c' l='418' u='c' c='vm_alloc_page'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_gem_gtt.c' l='464' u='c' c='vm_free_pages_release'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_gem_gtt.c' l='2942' u='c' c='i915_ggtt_cleanup_hw'/>
<def f='linux-5.3.1/mm/swap.c' l='814' ll='822' type='void __pagevec_release(struct pagevec * pvec)'/>
<dec f='linux-5.3.1/mm/swap.c' l='823' type='void __pagevec_release(struct pagevec * )'/>
<use f='linux-5.3.1/mm/swap.c' l='823' c='__pagevec_release'/>
<use f='linux-5.3.1/mm/swap.c' l='823' u='a'/>
<doc f='linux-5.3.1/mm/swap.c' l='804'>/*
 * The pages which we&apos;re about to release may be in the deferred lru-addition
 * queues.  That would prevent them from really being freed right now.  That&apos;s
 * OK from a correctness point of view but is inefficient - those pages may be
 * cache-warm and we want to give them back to the page allocator ASAP.
 *
 * So __pagevec_release() will drain those queues here.  __pagevec_lru_add()
 * and __pagevec_lru_add_active() call release_pages() directly to avoid
 * mutual recursion.
 */</doc>
