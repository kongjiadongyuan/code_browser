<def f='linux-5.3.1/include/linux/nvram.h' l='32' ll='42'/>
<use f='linux-5.3.1/include/linux/nvram.h' l='44'/>
<use f='linux-5.3.1/drivers/char/nvram.c' l='206'/>
<size>56</size>
<doc f='linux-5.3.1/include/linux/nvram.h' l='12'>/**
 * struct nvram_ops - NVRAM functionality made available to drivers
 * @read: validate checksum (if any) then load a range of bytes from NVRAM
 * @write: store a range of bytes to NVRAM then update checksum (if any)
 * @read_byte: load a single byte from NVRAM
 * @write_byte: store a single byte to NVRAM
 * @get_size: return the fixed number of bytes in the NVRAM
 *
 * Architectures which provide an nvram ops struct need not implement all
 * of these methods. If the NVRAM hardware can be accessed only one byte
 * at a time then it may be sufficient to provide .read_byte and .write_byte.
 * If the NVRAM has a checksum (and it is to be checked) the .read and
 * .write methods can be used to implement that efficiently.
 *
 * Portable drivers may use the wrapper functions defined here.
 * The nvram_read() and nvram_write() functions call the .read and .write
 * methods when available and fall back on the .read_byte and .write_byte
 * methods otherwise.
 */</doc>
<mbr r='nvram_ops::get_size' o='0' t='ssize_t (*)(void)'/>
<mbr r='nvram_ops::read_byte' o='64' t='unsigned char (*)(int)'/>
<mbr r='nvram_ops::write_byte' o='128' t='void (*)(unsigned char, int)'/>
<mbr r='nvram_ops::read' o='192' t='ssize_t (*)(char *, size_t, loff_t *)'/>
<mbr r='nvram_ops::write' o='256' t='ssize_t (*)(char *, size_t, loff_t *)'/>
<mbr r='nvram_ops::initialize' o='320' t='long (*)(void)'/>
<mbr r='nvram_ops::set_checksum' o='384' t='long (*)(void)'/>
