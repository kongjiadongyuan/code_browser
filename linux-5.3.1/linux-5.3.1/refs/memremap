<dec f='linux-5.3.1/include/linux/io.h' l='153' type='void * memremap(resource_size_t offset, size_t size, unsigned long flags)'/>
<use f='linux-5.3.1/arch/x86/kernel/kdebugfs.c' l='48' u='c' c='setup_data_read'/>
<use f='linux-5.3.1/arch/x86/kernel/kdebugfs.c' l='104' u='c' c='create_setup_data_nodes'/>
<use f='linux-5.3.1/arch/x86/kernel/ksysfs.c' l='81' u='c' c='get_setup_data_paddr'/>
<use f='linux-5.3.1/arch/x86/kernel/ksysfs.c' l='99' u='c' c='get_setup_data_size'/>
<use f='linux-5.3.1/arch/x86/kernel/ksysfs.c' l='129' u='c' c='type_show'/>
<use f='linux-5.3.1/arch/x86/kernel/ksysfs.c' l='156' u='c' c='setup_data_data_read'/>
<use f='linux-5.3.1/arch/x86/kernel/ksysfs.c' l='172' u='c' c='setup_data_data_read'/>
<use f='linux-5.3.1/arch/x86/kernel/ksysfs.c' l='252' u='c' c='get_setup_data_total_num'/>
<use f='linux-5.3.1/arch/x86/mm/ioremap.c' l='492' u='c' c='xlate_dev_mem_ptr'/>
<use f='linux-5.3.1/arch/x86/mm/ioremap.c' l='622' u='c' c='memremap_is_setup_data'/>
<use f='linux-5.3.1/arch/x86/pci/common.c' l='679' u='c' c='pcibios_add_device'/>
<use f='linux-5.3.1/arch/x86/platform/efi/quirks.c' l='471' u='c' c='efi_free_boot_services'/>
<use f='linux-5.3.1/drivers/acpi/bgrt.c' l='94' u='c' c='bgrt_init'/>
<use f='linux-5.3.1/drivers/firmware/dmi_scan.c' l='739' macro='1' u='c' c='dmi_init'/>
<use f='linux-5.3.1/drivers/firmware/dmi_scan.c' l='1072' macro='1' u='c' c='dmi_walk'/>
<use f='linux-5.3.1/drivers/firmware/efi/efi.c' l='989' u='c' c='efi_memreserve_map_root'/>
<use f='linux-5.3.1/drivers/firmware/efi/efi.c' l='1014' u='c' c='efi_mem_reserve_persistent'/>
<use f='linux-5.3.1/drivers/firmware/efi/efi.c' l='1070' u='c' c='update_efi_random_seed'/>
<use f='linux-5.3.1/drivers/firmware/efi/efi.c' l='1078' u='c' c='update_efi_random_seed'/>
<use f='linux-5.3.1/drivers/firmware/efi/esrt.c' l='384' u='c' c='esrt_sysfs_init'/>
<use f='linux-5.3.1/drivers/firmware/efi/memattr.c' l='150' u='c' c='efi_memattr_apply_permissions'/>
<use f='linux-5.3.1/drivers/firmware/efi/memmap.c' l='80' u='c' c='__efi_memmap_init'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_opregion.c' l='921' u='c' c='intel_opregion_setup'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_opregion.c' l='985' u='c' c='intel_opregion_setup'/>
<use f='linux-5.3.1/drivers/iommu/amd_iommu_init.c' l='910' u='c' c='copy_device_table'/>
<use f='linux-5.3.1/drivers/iommu/intel-iommu.c' l='3037' u='c' c='copy_context_table'/>
<use f='linux-5.3.1/drivers/iommu/intel-iommu.c' l='3120' u='c' c='copy_translation_tables'/>
<use f='linux-5.3.1/drivers/video/fbdev/efifb.c' l='498' u='c' c='efifb_probe'/>
<use f='linux-5.3.1/drivers/video/fbdev/efifb.c' l='501' u='c' c='efifb_probe'/>
<def f='linux-5.3.1/kernel/iomem.c' l='71' ll='119' type='void * memremap(resource_size_t offset, size_t size, unsigned long flags)'/>
<dec f='linux-5.3.1/kernel/iomem.c' l='120' type='void * memremap(resource_size_t , size_t , unsigned long )'/>
<use f='linux-5.3.1/kernel/iomem.c' l='120' c='memremap'/>
<use f='linux-5.3.1/kernel/iomem.c' l='120' u='a'/>
<use f='linux-5.3.1/kernel/iomem.c' l='149' u='c' c='devm_memremap'/>
<doc f='linux-5.3.1/kernel/iomem.c' l='43'>/**
 * memremap() - remap an iomem_resource as cacheable memory
 * @offset: iomem resource start address
 * @size: size of remap
 * @flags: any of MEMREMAP_WB, MEMREMAP_WT, MEMREMAP_WC,
 *		  MEMREMAP_ENC, MEMREMAP_DEC
 *
 * memremap() is &quot;ioremap&quot; for cases where it is known that the resource
 * being mapped does not have i/o side effects and the __iomem
 * annotation is not applicable. In the case of multiple flags, the different
 * mapping types will be attempted in the order listed below until one of
 * them succeeds.
 *
 * MEMREMAP_WB - matches the default mapping for System RAM on
 * the architecture.  This is usually a read-allocate write-back cache.
 * Moreover, if MEMREMAP_WB is specified and the requested remap region is RAM
 * memremap() will bypass establishing a new mapping and instead return
 * a pointer into the direct map.
 *
 * MEMREMAP_WT - establish a mapping whereby writes either bypass the
 * cache or are written through to memory and never exist in a
 * cache-dirty state with respect to program visibility.  Attempts to
 * map System RAM with this mapping type will fail.
 *
 * MEMREMAP_WC - establish a writecombine mapping, whereby writes may
 * be coalesced together (e.g. in the CPU&apos;s write buffers), but is otherwise
 * uncached. Attempts to map System RAM with this mapping type will fail.
 */</doc>
