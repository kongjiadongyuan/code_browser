<dec f='linux-5.3.1/include/linux/dma-fence.h' l='211' type='long (*)(struct dma_fence *, bool, long)'/>
<offset>320</offset>
<doc f='linux-5.3.1/include/linux/dma-fence.h' l='191'>/**
	 * @wait:
	 *
	 * Custom wait implementation, defaults to dma_fence_default_wait() if
	 * not set.
	 *
	 * The dma_fence_default_wait implementation should work for any fence, as long
	 * as @enable_signaling works correctly. This hook allows drivers to
	 * have an optimized version for the case where a process context is
	 * already available, e.g. if @enable_signaling for the general case
	 * needs to set up a worker thread.
	 *
	 * Must return -ERESTARTSYS if the wait is intr = true and the wait was
	 * interrupted, and remaining jiffies if fence has signaled, or 0 if wait
	 * timed out. Can also return other error values on custom implementations,
	 * which should be treated as if the fence is signaled. For example a hardware
	 * lockup could be reported like that.
	 *
	 * This callback is optional.
	 */</doc>
<use f='linux-5.3.1/drivers/dma-buf/dma-fence.c' l='228' u='r' c='dma_fence_wait_timeout'/>
<use f='linux-5.3.1/drivers/dma-buf/dma-fence.c' l='229' u='r' c='dma_fence_wait_timeout'/>
<use f='linux-5.3.1/include/linux/seqno-fence.h' l='94' u='r' c='seqno_fence_init'/>
<use f='linux-5.3.1/drivers/dma-buf/seqno-fence.c' l='60' u='r' c='seqno_wait'/>
<use f='linux-5.3.1/drivers/dma-buf/seqno-fence.c' l='68' u='w'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_writeback.c' l='111' u='w'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_request.c' l='118' u='w'/>
