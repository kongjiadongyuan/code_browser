<def f='linux-5.3.1/arch/x86/include/asm/fpu/internal.h' l='572' ll='583' type='void switch_fpu_prepare(struct fpu * old_fpu, int cpu)'/>
<doc f='linux-5.3.1/arch/x86/include/asm/fpu/internal.h' l='550'>/*
 * FPU state switching for scheduling.
 *
 * This is a two-stage process:
 *
 *  - switch_fpu_prepare() saves the old state.
 *    This is done within the context of the old process.
 *
 *  - switch_fpu_finish() sets TIF_NEED_FPU_LOAD; the floating point state
 *    will get loaded on return to userspace, or when the kernel needs it.
 *
 * If TIF_NEED_FPU_LOAD is cleared then the CPU&apos;s FPU registers
 * are saved in the current thread&apos;s FPU register state.
 *
 * If TIF_NEED_FPU_LOAD is set then CPU&apos;s FPU registers may not
 * hold current()&apos;s FPU registers. It is required to load the
 * registers before returning to userland or using the content
 * otherwise.
 *
 * The FPU context is only stored/restored for a user task and
 * PF_KTHREAD is used to distinguish between kernel and user threads.
 */</doc>
<use f='linux-5.3.1/arch/x86/kernel/process_64.c' l='516' u='c' c='__switch_to'/>
