<dec f='linux-5.3.1/include/linux/mm.h' l='1555' type='long get_user_pages_locked(unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page ** pages, int * locked)'/>
<def f='linux-5.3.1/mm/gup.c' l='1644' ll='1660' type='long get_user_pages_locked(unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page ** pages, int * locked)'/>
<dec f='linux-5.3.1/mm/gup.c' l='1661' type='long get_user_pages_locked(unsigned long , unsigned long , unsigned int , struct page ** , int * )'/>
<use f='linux-5.3.1/mm/gup.c' l='1661' c='get_user_pages_locked'/>
<use f='linux-5.3.1/mm/gup.c' l='1661' u='a'/>
<doc f='linux-5.3.1/mm/gup.c' l='1623'>/*
 * We can leverage the VM_FAULT_RETRY functionality in the page fault
 * paths better by using either get_user_pages_locked() or
 * get_user_pages_unlocked().
 *
 * get_user_pages_locked() is suitable to replace the form:
 *
 *      down_read(&amp;mm-&gt;mmap_sem);
 *      do_something()
 *      get_user_pages(tsk, mm, ..., pages, NULL);
 *      up_read(&amp;mm-&gt;mmap_sem);
 *
 *  to:
 *
 *      int locked = 1;
 *      down_read(&amp;mm-&gt;mmap_sem);
 *      do_something()
 *      get_user_pages_locked(tsk, mm, ..., pages, &amp;locked);
 *      if (locked)
 *          up_read(&amp;mm-&gt;mmap_sem);
 */</doc>
<use f='linux-5.3.1/mm/mempolicy.c' l='859' u='c' c='lookup_node'/>
