<dec f='linux-5.3.1/include/linux/dmapool.h' l='21' type='struct dma_pool * dma_pool_create(const char * name, struct device * dev, size_t size, size_t align, size_t allocation)'/>
<use f='linux-5.3.1/drivers/net/ethernet/intel/e100.c' l='2940' u='c' c='e100_probe'/>
<use f='linux-5.3.1/drivers/usb/core/buffer.c' l='77' u='c' c='hcd_buffer_create'/>
<use f='linux-5.3.1/drivers/usb/host/ehci-mem.c' l='144' u='c' c='ehci_mem_init'/>
<use f='linux-5.3.1/drivers/usb/host/ehci-mem.c' l='154' u='c' c='ehci_mem_init'/>
<use f='linux-5.3.1/drivers/usb/host/ehci-mem.c' l='168' u='c' c='ehci_mem_init'/>
<use f='linux-5.3.1/drivers/usb/host/ehci-mem.c' l='178' u='c' c='ehci_mem_init'/>
<use f='linux-5.3.1/drivers/usb/host/ohci-mem.c' l='46' u='c' c='ohci_mem_init'/>
<use f='linux-5.3.1/drivers/usb/host/ohci-mem.c' l='53' u='c' c='ohci_mem_init'/>
<use f='linux-5.3.1/drivers/usb/host/uhci-hcd.c' l='613' u='c' c='uhci_start'/>
<use f='linux-5.3.1/drivers/usb/host/uhci-hcd.c' l='620' u='c' c='uhci_start'/>
<use f='linux-5.3.1/drivers/usb/host/xhci-mem.c' l='2416' u='c' c='xhci_mem_init'/>
<use f='linux-5.3.1/drivers/usb/host/xhci-mem.c' l='2420' u='c' c='xhci_mem_init'/>
<use f='linux-5.3.1/drivers/usb/host/xhci-mem.c' l='2429' u='c' c='xhci_mem_init'/>
<use f='linux-5.3.1/drivers/usb/host/xhci-mem.c' l='2432' u='c' c='xhci_mem_init'/>
<def f='linux-5.3.1/mm/dmapool.c' l='130' ll='202' type='struct dma_pool * dma_pool_create(const char * name, struct device * dev, size_t size, size_t align, size_t boundary)'/>
<dec f='linux-5.3.1/mm/dmapool.c' l='203' type='struct dma_pool * dma_pool_create(const char * , struct device * , size_t , size_t , size_t )'/>
<use f='linux-5.3.1/mm/dmapool.c' l='203' c='dma_pool_create'/>
<use f='linux-5.3.1/mm/dmapool.c' l='203' u='a'/>
<use f='linux-5.3.1/mm/dmapool.c' l='515' u='c' c='dmam_pool_create'/>
<doc f='linux-5.3.1/mm/dmapool.c' l='107'>/**
 * dma_pool_create - Creates a pool of consistent memory blocks, for dma.
 * @name: name of pool, for diagnostics
 * @dev: device that will be doing the DMA
 * @size: size of the blocks in this pool.
 * @align: alignment requirement for blocks; must be a power of two
 * @boundary: returned blocks won&apos;t cross this power of two boundary
 * Context: not in_interrupt()
 *
 * Given one of these pools, dma_pool_alloc()
 * may be used to allocate memory.  Such memory will all have &quot;consistent&quot;
 * DMA mappings, accessible by the device and its driver without using
 * cache flushing primitives.  The actual size of blocks allocated may be
 * larger than requested because of alignment.
 *
 * If @boundary is nonzero, objects returned from dma_pool_alloc() won&apos;t
 * cross that size boundary.  This is useful for devices which have
 * addressing restrictions on individual DMA transfers, such as not crossing
 * boundaries of 4KBytes.
 *
 * Return: a dma allocation pool with the requested characteristics, or
 * %NULL if one can&apos;t be created.
 */</doc>
