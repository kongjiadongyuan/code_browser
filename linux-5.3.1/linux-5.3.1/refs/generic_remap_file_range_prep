<dec f='linux-5.3.1/include/linux/fs.h' l='1893' type='int generic_remap_file_range_prep(struct file * file_in, loff_t pos_in, struct file * file_out, loff_t pos_out, loff_t * count, unsigned int remap_flags)'/>
<def f='linux-5.3.1/fs/read_write.c' l='1946' ll='2026' type='int generic_remap_file_range_prep(struct file * file_in, loff_t pos_in, struct file * file_out, loff_t pos_out, loff_t * len, unsigned int remap_flags)'/>
<dec f='linux-5.3.1/fs/read_write.c' l='2027' type='int generic_remap_file_range_prep(struct file * , loff_t , struct file * , loff_t , loff_t * , unsigned int )'/>
<use f='linux-5.3.1/fs/read_write.c' l='2027' c='generic_remap_file_range_prep'/>
<use f='linux-5.3.1/fs/read_write.c' l='2027' u='a'/>
<doc f='linux-5.3.1/fs/read_write.c' l='1938'>/*
 * Check that the two inodes are eligible for cloning, the ranges make
 * sense, and then flush all dirty data.  Caller must ensure that the
 * inodes have been locked against any other modifications.
 *
 * If there&apos;s an error, then the usual negative error code is returned.
 * Otherwise returns 0 with *len set to the request length.
 */</doc>
