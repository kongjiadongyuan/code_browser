<dec f='linux-5.3.1/drivers/pci/pci.h' l='81' type='void pci_update_current_state(struct pci_dev * dev, pci_power_t state)'/>
<use f='linux-5.3.1/drivers/pci/pci-driver.c' l='507' u='c' c='pci_restore_standard_config'/>
<def f='linux-5.3.1/drivers/pci/pci.c' l='931' ll='944' type='void pci_update_current_state(struct pci_dev * dev, pci_power_t state)'/>
<use f='linux-5.3.1/drivers/pci/pci.c' l='958' u='c' c='pci_refresh_power_state'/>
<use f='linux-5.3.1/drivers/pci/pci.c' l='971' u='c' c='pci_power_up'/>
<use f='linux-5.3.1/drivers/pci/pci.c' l='986' u='c' c='pci_platform_power_transition'/>
<doc f='linux-5.3.1/drivers/pci/pci.c' l='919'>/**
 * pci_update_current_state - Read power state of given device and cache it
 * @dev: PCI device to handle.
 * @state: State to cache in case the device doesn&apos;t have the PM capability
 *
 * The power state is read from the PMCSR register, which however is
 * inaccessible in D3cold.  The platform firmware is therefore queried first
 * to detect accessibility of the register.  In case the platform firmware
 * reports an incorrect state or the device isn&apos;t power manageable by the
 * platform at all, we try to detect D3cold by testing accessibility of the
 * vendor ID in config space.
 */</doc>
