<dec f='linux-5.3.1/include/linux/mm.h' l='824' type='vm_fault_t alloc_set_pte(struct vm_fault * vmf, struct mem_cgroup * memcg, struct page * page)'/>
<use f='linux-5.3.1/mm/filemap.c' l='2700' u='c' c='filemap_map_pages'/>
<def f='linux-5.3.1/mm/memory.c' l='3258' ll='3306' type='vm_fault_t alloc_set_pte(struct vm_fault * vmf, struct mem_cgroup * memcg, struct page * page)'/>
<use f='linux-5.3.1/mm/memory.c' l='3343' u='c' c='finish_fault'/>
<doc f='linux-5.3.1/mm/memory.c' l='3242'>/**
 * alloc_set_pte - setup new PTE entry for given page and add reverse page
 * mapping. If needed, the fucntion allocates page table or use pre-allocated.
 *
 * @vmf: fault environment
 * @memcg: memcg to charge page (only for private mappings)
 * @page: page to map
 *
 * Caller must take care of unlocking vmf-&gt;ptl, if vmf-&gt;pte is non-NULL on
 * return.
 *
 * Target users are page handler itself and implementations of
 * vm_ops-&gt;map_pages.
 *
 * Return: %0 on success, %VM_FAULT_ code in case of error.
 */</doc>
