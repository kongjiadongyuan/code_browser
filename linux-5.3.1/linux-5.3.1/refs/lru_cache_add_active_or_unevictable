<dec f='linux-5.3.1/include/linux/swap.h' l='346' type='void lru_cache_add_active_or_unevictable(struct page * page, struct vm_area_struct * vma)'/>
<use f='linux-5.3.1/kernel/events/uprobes.c' l='188' u='c' c='__replace_page'/>
<use f='linux-5.3.1/mm/memory.c' l='2360' u='c' c='wp_page_copy'/>
<use f='linux-5.3.1/mm/memory.c' l='2884' u='c' c='do_swap_page'/>
<use f='linux-5.3.1/mm/memory.c' l='3032' u='c' c='do_anonymous_page'/>
<use f='linux-5.3.1/mm/memory.c' l='3295' u='c' c='alloc_set_pte'/>
<def f='linux-5.3.1/mm/swap.c' l='454' ll='472' type='void lru_cache_add_active_or_unevictable(struct page * page, struct vm_area_struct * vma)'/>
<doc f='linux-5.3.1/mm/swap.c' l='444'>/**
 * lru_cache_add_active_or_unevictable
 * @page:  the page to be added to LRU
 * @vma:   vma in which page is mapped for determining reclaimability
 *
 * Place @page on the active or unevictable LRU list, depending on its
 * evictability.  Note that if the page is not evictable, it goes
 * directly back onto it&apos;s zone&apos;s unevictable list, it does NOT use a
 * per cpu pagevec.
 */</doc>
<use f='linux-5.3.1/mm/swapfile.c' l='1891' u='c' c='unuse_pte'/>
