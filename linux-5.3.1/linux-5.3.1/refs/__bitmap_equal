<dec f='linux-5.3.1/include/linux/bitmap.h' l='121' type='int __bitmap_equal(const unsigned long * bitmap1, const unsigned long * bitmap2, unsigned int nbits)'/>
<use f='linux-5.3.1/include/linux/bitmap.h' l='321' u='c' c='bitmap_equal'/>
<def f='linux-5.3.1/lib/bitmap.c' l='46' ll='59' type='int __bitmap_equal(const unsigned long * bitmap1, const unsigned long * bitmap2, unsigned int bits)'/>
<dec f='linux-5.3.1/lib/bitmap.c' l='60' type='int __bitmap_equal(const unsigned long * , const unsigned long * , unsigned int )'/>
<use f='linux-5.3.1/lib/bitmap.c' l='60' c='__bitmap_equal'/>
<use f='linux-5.3.1/lib/bitmap.c' l='60' u='a'/>
<doc f='linux-5.3.1/lib/bitmap.c' l='23'>/**
 * DOC: bitmap introduction
 *
 * bitmaps provide an array of bits, implemented using an an
 * array of unsigned longs.  The number of valid bits in a
 * given bitmap does _not_ need to be an exact multiple of
 * BITS_PER_LONG.
 *
 * The possible unused bits in the last, partially used word
 * of a bitmap are &apos;don&apos;t care&apos;.  The implementation makes
 * no particular effort to keep them zero.  It ensures that
 * their value will not affect the results of any operation.
 * The bitmap operations that return Boolean (bitmap_empty,
 * for example) or scalar (bitmap_weight, for example) results
 * carefully filter out these unused bits from impacting their
 * results.
 *
 * The byte ordering of bitmaps is more natural on little
 * endian architectures.  See the big-endian headers
 * include/asm-ppc64/bitops.h and include/asm-s390/bitops.h
 * for the best explanations of this ordering.
 */</doc>
