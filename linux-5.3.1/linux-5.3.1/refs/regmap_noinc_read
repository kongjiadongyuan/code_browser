<dec f='linux-5.3.1/include/linux/regmap.h' l='1027' type='int regmap_noinc_read(struct regmap * map, unsigned int reg, void * val, size_t val_len)'/>
<def f='linux-5.3.1/drivers/base/regmap/regmap.c' l='2681' ll='2720' type='int regmap_noinc_read(struct regmap * map, unsigned int reg, void * val, size_t val_len)'/>
<dec f='linux-5.3.1/drivers/base/regmap/regmap.c' l='2721' type='int regmap_noinc_read(struct regmap * , unsigned int , void * , size_t )'/>
<use f='linux-5.3.1/drivers/base/regmap/regmap.c' l='2721' c='regmap_noinc_read'/>
<use f='linux-5.3.1/drivers/base/regmap/regmap.c' l='2721' u='a'/>
<doc f='linux-5.3.1/drivers/base/regmap/regmap.c' l='2660'>/**
 * regmap_noinc_read(): Read data from a register without incrementing the
 *			register number
 *
 * @map: Register map to read from
 * @reg: Register to read from
 * @val: Pointer to data buffer
 * @val_len: Length of output buffer in bytes.
 *
 * The regmap API usually assumes that bulk bus read operations will read a
 * range of registers. Some devices have certain registers for which a read
 * operation read will read from an internal FIFO.
 *
 * The target register must be volatile but registers after it can be
 * completely unrelated cacheable registers.
 *
 * This will attempt multiple reads as required to read val_len bytes.
 *
 * A value of zero will be returned on success, a negative errno will be
 * returned in error cases.
 */</doc>
