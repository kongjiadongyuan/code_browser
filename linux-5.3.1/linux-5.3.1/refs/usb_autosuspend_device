<dec f='linux-5.3.1/drivers/usb/core/usb.h' l='89' type='void usb_autosuspend_device(struct usb_device * udev)'/>
<use f='linux-5.3.1/drivers/usb/core/devio.c' l='1036' u='c' c='usbdev_release'/>
<use f='linux-5.3.1/drivers/usb/core/driver.c' l='278' u='c' c='usb_unbind_device'/>
<use f='linux-5.3.1/drivers/usb/core/driver.c' l='371' u='c' c='usb_probe_interface'/>
<use f='linux-5.3.1/drivers/usb/core/driver.c' l='388' u='c' c='usb_probe_interface'/>
<use f='linux-5.3.1/drivers/usb/core/driver.c' l='477' u='c' c='usb_unbind_interface'/>
<def f='linux-5.3.1/drivers/usb/core/driver.c' l='1564' ll='1573' type='void usb_autosuspend_device(struct usb_device * udev)'/>
<doc f='linux-5.3.1/drivers/usb/core/driver.c' l='1548'>/**
 * usb_autosuspend_device - delayed autosuspend of a USB device and its interfaces
 * @udev: the usb_device to autosuspend
 *
 * This routine should be called when a core subsystem is finished using
 * @udev and wants to allow it to autosuspend.  Examples would be when
 * @udev&apos;s device file in usbfs is closed or after a configuration change.
 *
 * @udev&apos;s usage counter is decremented; if it drops to 0 and all the
 * interfaces are inactive then a delayed autosuspend will be attempted.
 * The attempt may fail (see autosuspend_check()).
 *
 * The caller must hold @udev&apos;s device lock.
 *
 * This routine can run only in process context.
 */</doc>
<use f='linux-5.3.1/drivers/usb/core/hub.c' l='2645' u='c' c='usb_authorize_device'/>
<use f='linux-5.3.1/drivers/usb/core/hub.c' l='3606' u='c' c='usb_remote_wakeup'/>
<use f='linux-5.3.1/drivers/usb/core/hub.c' l='5920' u='c' c='usb_reset_device'/>
<use f='linux-5.3.1/drivers/usb/core/message.c' l='1902' u='c' c='usb_set_configuration'/>
<use f='linux-5.3.1/drivers/usb/core/message.c' l='1988' u='c' c='usb_set_configuration'/>
<use f='linux-5.3.1/drivers/usb/core/message.c' l='2032' u='c' c='usb_set_configuration'/>
