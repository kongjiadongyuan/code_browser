<dec f='linux-5.3.1/include/linux/mm.h' l='1497' type='void pagecache_isize_extended(struct inode * inode, loff_t from, loff_t to)'/>
<use f='linux-5.3.1/fs/buffer.c' l='2151' u='c' c='generic_write_end'/>
<use f='linux-5.3.1/fs/ext4/inode.c' l='1432' u='c' c='ext4_write_end'/>
<use f='linux-5.3.1/fs/ext4/inode.c' l='1550' u='c' c='ext4_journalled_write_end'/>
<use f='linux-5.3.1/fs/ext4/inode.c' l='5669' u='c' c='ext4_setattr'/>
<use f='linux-5.3.1/fs/iomap/buffered-io.c' l='727' u='c' c='iomap_write_end'/>
<use f='linux-5.3.1/mm/truncate.c' l='829' u='c' c='truncate_setsize'/>
<def f='linux-5.3.1/mm/truncate.c' l='853' ll='882' type='void pagecache_isize_extended(struct inode * inode, loff_t from, loff_t to)'/>
<dec f='linux-5.3.1/mm/truncate.c' l='883' type='void pagecache_isize_extended(struct inode * , loff_t , loff_t )'/>
<use f='linux-5.3.1/mm/truncate.c' l='883' c='pagecache_isize_extended'/>
<use f='linux-5.3.1/mm/truncate.c' l='883' u='a'/>
<doc f='linux-5.3.1/mm/truncate.c' l='834'>/**
 * pagecache_isize_extended - update pagecache after extension of i_size
 * @inode:	inode for which i_size was extended
 * @from:	original inode size
 * @to:		new inode size
 *
 * Handle extension of inode size either caused by extending truncate or by
 * write starting after current i_size. We mark the page straddling current
 * i_size RO so that page_mkwrite() is called on the nearest write access to
 * the page.  This way filesystem can be sure that page_mkwrite() is called on
 * the page before user writes to the page via mmap after the i_size has been
 * changed.
 *
 * The function must be called after i_size is updated so that page fault
 * coming after we unlock the page will already see the new i_size.
 * The function must be called while we still hold i_mutex - this not only
 * makes sure i_size is stable but also that userspace cannot observe new
 * i_size value before we are prepared to store mmap writes at new inode size.
 */</doc>
