<dec f='linux-5.3.1/include/net/cfg80211.h' l='6688' type='bool cfg80211_rx_control_port(struct net_device * dev, struct sk_buff * skb, bool unencrypted)'/>
<doc f='linux-5.3.1/include/net/cfg80211.h' l='6669'>/**
 * cfg80211_rx_control_port - notification about a received control port frame
 * @dev: The device the frame matched to
 * @skb: The skbuf with the control port frame.  It is assumed that the skbuf
 *	is 802.3 formatted (with 802.3 header).  The skb can be non-linear.
 *	This function does not take ownership of the skb, so the caller is
 *	responsible for any cleanup.  The caller must also ensure that
 *	skb-&gt;protocol is set appropriately.
 * @unencrypted: Whether the frame was received unencrypted
 *
 * This function is used to inform userspace about a received control port
 * frame.  It should only be used if userspace indicated it wants to receive
 * control port frames over nl80211.
 *
 * The frame is the data portion of the 802.3 or 802.11 data frame with all
 * network layer headers removed (e.g. the raw EAPoL frame).
 *
 * Return: %true if the frame was passed to userspace
 */</doc>
<use f='linux-5.3.1/net/mac80211/rx.c' l='2452' u='c' c='ieee80211_deliver_skb_to_local_stack'/>
<def f='linux-5.3.1/net/wireless/nl80211.c' l='15751' ll='15760' type='bool cfg80211_rx_control_port(struct net_device * dev, struct sk_buff * skb, bool unencrypted)'/>
<dec f='linux-5.3.1/net/wireless/nl80211.c' l='15761' type='bool cfg80211_rx_control_port(struct net_device * , struct sk_buff * , bool )'/>
<use f='linux-5.3.1/net/wireless/nl80211.c' l='15761' c='cfg80211_rx_control_port'/>
<use f='linux-5.3.1/net/wireless/nl80211.c' l='15761' u='a'/>
