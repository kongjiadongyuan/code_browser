<dec f='linux-5.3.1/include/linux/fsnotify_backend.h' l='475' type='void fsnotify_detach_mark(struct fsnotify_mark * mark)'/>
<doc f='linux-5.3.1/include/linux/fsnotify_backend.h' l='474'>/* detach mark from inode / mount list, group list, drop inode reference */</doc>
<use f='linux-5.3.1/fs/notify/dnotify/dnotify.c' l='177' u='c' c='dnotify_flush'/>
<use f='linux-5.3.1/fs/notify/dnotify/dnotify.c' l='364' u='c' c='fcntl_dirnotify'/>
<def f='linux-5.3.1/fs/notify/mark.c' l='370' ll='393' type='void fsnotify_detach_mark(struct fsnotify_mark * mark)'/>
<use f='linux-5.3.1/fs/notify/mark.c' l='429' u='c' c='fsnotify_destroy_mark'/>
<use f='linux-5.3.1/fs/notify/mark.c' l='753' u='c' c='fsnotify_clear_marks_by_group'/>
<doc f='linux-5.3.1/fs/notify/mark.c' l='360'>/*
 * Mark mark as detached, remove it from group list. Mark still stays in object
 * list until its last reference is dropped. Note that we rely on mark being
 * removed from group list before corresponding reference to it is dropped. In
 * particular we rely on mark-&gt;connector being valid while we hold
 * group-&gt;mark_mutex if we found the mark through g_list.
 *
 * Must be called with group-&gt;mark_mutex held. The caller must either hold
 * reference to the mark or be protected by fsnotify_mark_srcu.
 */</doc>
<use f='linux-5.3.1/kernel/audit_tree.c' l='372' u='c' c='untag_chunk'/>
<use f='linux-5.3.1/kernel/audit_tree.c' l='426' u='c' c='create_chunk'/>
