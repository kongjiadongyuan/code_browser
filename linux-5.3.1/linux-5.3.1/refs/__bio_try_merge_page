<dec f='linux-5.3.1/include/linux/bio.h' l='438' type='bool __bio_try_merge_page(struct bio * bio, struct page * page, unsigned int len, unsigned int off, bool * same_page)'/>
<def f='linux-5.3.1/block/bio.c' l='766' ll='782' type='bool __bio_try_merge_page(struct bio * bio, struct page * page, unsigned int len, unsigned int off, bool * same_page)'/>
<dec f='linux-5.3.1/block/bio.c' l='783' type='bool __bio_try_merge_page(struct bio * , struct page * , unsigned int , unsigned int , bool * )'/>
<use f='linux-5.3.1/block/bio.c' l='783' c='__bio_try_merge_page'/>
<use f='linux-5.3.1/block/bio.c' l='783' u='a'/>
<use f='linux-5.3.1/block/bio.c' l='827' u='c' c='bio_add_page'/>
<use f='linux-5.3.1/block/bio.c' l='909' u='c' c='__bio_iov_iter_get_pages'/>
<doc f='linux-5.3.1/block/bio.c' l='750'>/**
 * __bio_try_merge_page - try appending data to an existing bvec.
 * @bio: destination bio
 * @page: start page to add
 * @len: length of the data to add
 * @off: offset of the data relative to @page
 * @same_page: return if the segment has been merged inside the same page
 *
 * Try to add the data at @page + @off to the last bvec of @bio.  This is a
 * a useful optimisation for file systems with a block size smaller than the
 * page size.
 *
 * Warn if (@len, @off) crosses pages in case that @same_page is true.
 *
 * Return %true on success or %false on failure.
 */</doc>
<use f='linux-5.3.1/fs/iomap/buffered-io.c' l='245' u='c' c='iomap_readpage_actor'/>
