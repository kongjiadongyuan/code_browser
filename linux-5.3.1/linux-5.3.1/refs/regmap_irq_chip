<def f='linux-5.3.1/include/linux/regmap.h' l='1224' ll='1261'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='1266' c='regmap_add_irq_chip'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='1272' c='devm_regmap_add_irq_chip'/>
<size>112</size>
<doc f='linux-5.3.1/include/linux/regmap.h' l='1159'>/**
 * struct regmap_irq_chip - Description of a generic regmap irq_chip.
 *
 * @name:        Descriptive name for IRQ controller.
 *
 * @main_status: Base main status register address. For chips which have
 *		 interrupts arranged in separate sub-irq blocks with own IRQ
 *		 registers and which have a main IRQ registers indicating
 *		 sub-irq blocks with unhandled interrupts. For such chips fill
 *		 sub-irq register information in status_base, mask_base and
 *		 ack_base.
 * @num_main_status_bits: Should be given to chips where number of meaningfull
 *			  main status bits differs from num_regs.
 * @sub_reg_offsets: arrays of mappings from main register bits to sub irq
 *		     registers. First item in array describes the registers
 *		     for first main status bit. Second array for second bit etc.
 *		     Offset is given as sub register status offset to
 *		     status_base. Should contain num_regs arrays.
 *		     Can be provided for chips with more complex mapping than
 *		     1.st bit to 1.st sub-reg, 2.nd bit to 2.nd sub-reg, ...
 * @num_main_regs: Number of &apos;main status&apos; irq registers for chips which have
 *		   main_status set.
 *
 * @status_base: Base status register address.
 * @mask_base:   Base mask register address.
 * @mask_writeonly: Base mask register is write only.
 * @unmask_base:  Base unmask register address. for chips who have
 *                separate mask and unmask registers
 * @ack_base:    Base ack address. If zero then the chip is clear on read.
 *               Using zero value is possible with @use_ack bit.
 * @wake_base:   Base address for wake enables.  If zero unsupported.
 * @type_base:   Base address for irq type.  If zero unsupported.
 * @irq_reg_stride:  Stride to use for chips where registers are not contiguous.
 * @init_ack_masked: Ack all masked interrupts once during initalization.
 * @mask_invert: Inverted mask register: cleared bits are masked out.
 * @use_ack:     Use @ack register even if it is zero.
 * @ack_invert:  Inverted ack register: cleared bits for ack.
 * @wake_invert: Inverted wake register: cleared bits are wake enabled.
 * @type_invert: Invert the type flags.
 * @type_in_mask: Use the mask registers for controlling irq type. For
 *                interrupts defining type_rising/falling_mask use mask_base
 *                for edge configuration and never update bits in type_base.
 * @clear_on_unmask: For chips with interrupts cleared on read: read the status
 *                   registers before unmasking interrupts to clear any bits
 *                   set when they were masked.
 * @runtime_pm:  Hold a runtime PM lock on the device when accessing it.
 *
 * @num_regs:    Number of registers in each control bank.
 * @irqs:        Descriptors for individual IRQs.  Interrupt numbers are
 *               assigned based on the index in the array of the interrupt.
 * @num_irqs:    Number of descriptors.
 * @num_type_reg:    Number of type registers.
 * @type_reg_stride: Stride to use for chips where type registers are not
 *			contiguous.
 * @handle_pre_irq:  Driver specific callback to handle interrupt from device
 *		     before regmap_irq_handler process the interrupts.
 * @handle_post_irq: Driver specific callback to handle interrupt from device
 *		     after handling the interrupts in regmap_irq_handler().
 * @irq_drv_data:    Driver specific IRQ data which is passed as parameter when
 *		     driver specific pre/post interrupt handler is called.
 *
 * This is not intended to handle every possible interrupt controller, but
 * it should handle a substantial proportion of those that are found in the
 * wild.
 */</doc>
<mbr r='regmap_irq_chip::name' o='0' t='const char *'/>
<mbr r='regmap_irq_chip::main_status' o='64' t='unsigned int'/>
<mbr r='regmap_irq_chip::num_main_status_bits' o='96' t='unsigned int'/>
<mbr r='regmap_irq_chip::sub_reg_offsets' o='128' t='struct regmap_irq_sub_irq_map *'/>
<mbr r='regmap_irq_chip::num_main_regs' o='192' t='int'/>
<mbr r='regmap_irq_chip::status_base' o='224' t='unsigned int'/>
<mbr r='regmap_irq_chip::mask_base' o='256' t='unsigned int'/>
<mbr r='regmap_irq_chip::unmask_base' o='288' t='unsigned int'/>
<mbr r='regmap_irq_chip::ack_base' o='320' t='unsigned int'/>
<mbr r='regmap_irq_chip::wake_base' o='352' t='unsigned int'/>
<mbr r='regmap_irq_chip::type_base' o='384' t='unsigned int'/>
<mbr r='regmap_irq_chip::irq_reg_stride' o='416' t='unsigned int'/>
<mbr r='regmap_irq_chip::mask_writeonly' o='448' t='bool'/>
<mbr r='regmap_irq_chip::init_ack_masked' o='449' t='bool'/>
<mbr r='regmap_irq_chip::mask_invert' o='450' t='bool'/>
<mbr r='regmap_irq_chip::use_ack' o='451' t='bool'/>
<mbr r='regmap_irq_chip::ack_invert' o='452' t='bool'/>
<mbr r='regmap_irq_chip::wake_invert' o='453' t='bool'/>
<mbr r='regmap_irq_chip::runtime_pm' o='454' t='bool'/>
<mbr r='regmap_irq_chip::type_invert' o='455' t='bool'/>
<mbr r='regmap_irq_chip::type_in_mask' o='456' t='bool'/>
<mbr r='regmap_irq_chip::clear_on_unmask' o='457' t='bool'/>
<mbr r='regmap_irq_chip::num_regs' o='480' t='int'/>
<mbr r='regmap_irq_chip::irqs' o='512' t='const struct regmap_irq *'/>
<mbr r='regmap_irq_chip::num_irqs' o='576' t='int'/>
<mbr r='regmap_irq_chip::num_type_reg' o='608' t='int'/>
<mbr r='regmap_irq_chip::type_reg_stride' o='640' t='unsigned int'/>
<mbr r='regmap_irq_chip::handle_pre_irq' o='704' t='int (*)(void *)'/>
<mbr r='regmap_irq_chip::handle_post_irq' o='768' t='int (*)(void *)'/>
<mbr r='regmap_irq_chip::irq_drv_data' o='832' t='void *'/>
