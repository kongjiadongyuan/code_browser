<dec f='linux-5.3.1/include/linux/vmalloc.h' l='189' type='long vwrite(char * buf, char * addr, unsigned long count)'/>
<use f='linux-5.3.1/drivers/char/mem.c' l='593' u='c' c='write_kmem'/>
<def f='linux-5.3.1/mm/vmalloc.c' l='2916' ll='2964' type='long vwrite(char * buf, char * addr, unsigned long count)'/>
<doc f='linux-5.3.1/mm/vmalloc.c' l='2892'>/**
 * vwrite() - write vmalloc area in a safe way.
 * @buf:      buffer for source data
 * @addr:     vm address.
 * @count:    number of bytes to be read.
 *
 * This function checks that addr is a valid vmalloc&apos;ed area, and
 * copy data from a buffer to the given addr. If specified range of
 * [addr...addr+count) includes some valid address, data is copied from
 * proper area of @buf. If there are memory holes, no copy to hole.
 * IOREMAP area is treated as memory hole and no copy is done.
 *
 * If [addr...addr+count) doesn&apos;t includes any intersects with alive
 * vm_struct area, returns 0. @buf should be kernel&apos;s buffer.
 *
 * Note: In usual ops, vwrite() is never necessary because the caller
 * should know vmalloc() area is valid and can use memcpy().
 * This is for routines which have to access vmalloc area without
 * any information, as /dev/kmem.
 *
 * Return: number of bytes for which addr and buf should be
 * increased (same number as @count) or %0 if [addr...addr+count)
 * doesn&apos;t include any intersection with valid vmalloc area
 */</doc>
