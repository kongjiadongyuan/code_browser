<dec f='linux-5.3.1/include/linux/vmalloc.h' l='71' type='void vm_unmap_aliases()'/>
<use f='linux-5.3.1/arch/x86/mm/pageattr.c' l='1709' u='c' c='change_page_attr_set_clr'/>
<use f='linux-5.3.1/arch/x86/mm/pageattr.c' l='2055' u='c' c='__set_memory_enc_dec'/>
<def f='linux-5.3.1/mm/vmalloc.c' l='1714' ll='1720' type='void vm_unmap_aliases()'/>
<dec f='linux-5.3.1/mm/vmalloc.c' l='1721' type='void vm_unmap_aliases()'/>
<use f='linux-5.3.1/mm/vmalloc.c' l='1721' c='vm_unmap_aliases'/>
<use f='linux-5.3.1/mm/vmalloc.c' l='1721' u='a'/>
<use f='linux-5.3.1/mm/vmalloc.c' l='2193' u='c' c='vm_remove_mappings'/>
<doc f='linux-5.3.1/mm/vmalloc.c' l='1701'>/**
 * vm_unmap_aliases - unmap outstanding lazy aliases in the vmap layer
 *
 * The vmap/vmalloc layer lazily flushes kernel virtual mappings primarily
 * to amortize TLB flushing overheads. What this means is that any page you
 * have now, may, in a former life, have been mapped into kernel virtual
 * address by the vmap layer and so there might be some CPUs with TLB entries
 * still referencing that page (additional to the regular 1:1 kernel mapping).
 *
 * vm_unmap_aliases flushes all such lazy mappings. After it returns, we can
 * be sure that none of the pages we have control over will have any aliases
 * from the vmap layer.
 */</doc>
