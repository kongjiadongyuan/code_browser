<dec f='linux-5.3.1/include/linux/refcount.h' l='52' type='bool refcount_sub_and_test_checked(unsigned int i, refcount_t * r)'/>
<def f='linux-5.3.1/lib/refcount.c' l='180' ll='202' type='bool refcount_sub_and_test_checked(unsigned int i, refcount_t * r)'/>
<dec f='linux-5.3.1/lib/refcount.c' l='203' type='bool refcount_sub_and_test_checked(unsigned int , refcount_t * )'/>
<use f='linux-5.3.1/lib/refcount.c' l='203' c='refcount_sub_and_test_checked'/>
<use f='linux-5.3.1/lib/refcount.c' l='203' u='a'/>
<use f='linux-5.3.1/lib/refcount.c' l='220' u='c' c='refcount_dec_and_test_checked'/>
<doc f='linux-5.3.1/lib/refcount.c' l='160'>/**
 * refcount_sub_and_test_checked - subtract from a refcount and test if it is 0
 * @i: amount to subtract from the refcount
 * @r: the refcount
 *
 * Similar to atomic_dec_and_test(), but it will WARN, return false and
 * ultimately leak on underflow and will fail to decrement when saturated
 * at UINT_MAX.
 *
 * Provides release memory ordering, such that prior loads and stores are done
 * before, and provides an acquire ordering on success such that free()
 * must come after.
 *
 * Use of this function is not recommended for the normal reference counting
 * use case in which references are taken and released one at a time.  In these
 * cases, refcount_dec(), or one of its variants, should instead be used to
 * decrement a reference count.
 *
 * Return: true if the resulting refcount is 0, false otherwise
 */</doc>
