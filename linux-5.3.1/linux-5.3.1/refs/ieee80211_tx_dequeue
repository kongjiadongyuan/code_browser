<dec f='linux-5.3.1/include/net/mac80211.h' l='6238' type='struct sk_buff * ieee80211_tx_dequeue(struct ieee80211_hw * hw, struct ieee80211_txq * txq)'/>
<doc f='linux-5.3.1/include/net/mac80211.h' l='6221'>/**
 * ieee80211_tx_dequeue - dequeue a packet from a software tx queue
 *
 * @hw: pointer as obtained from ieee80211_alloc_hw()
 * @txq: pointer obtained from station or virtual interface, or from
 *	ieee80211_next_txq()
 *
 * Returns the skb if successful, %NULL if no frame was available.
 *
 * Note that this must be called in an rcu_read_lock() critical section,
 * which can only be released after the SKB was handled. Some pointers in
 * skb-&gt;cb, e.g. the key pointer, are protected by by RCU and thus the
 * critical section must persist not just for the duration of this call
 * but for the duration of the frame handling.
 * However, also note that while in the wake_tx_queue() method,
 * rcu_read_lock() is already held.
 */</doc>
<def f='linux-5.3.1/net/mac80211/tx.c' l='3535' ll='3665' type='struct sk_buff * ieee80211_tx_dequeue(struct ieee80211_hw * hw, struct ieee80211_txq * txq)'/>
<dec f='linux-5.3.1/net/mac80211/tx.c' l='3666' type='struct sk_buff * ieee80211_tx_dequeue(struct ieee80211_hw * , struct ieee80211_txq * )'/>
<use f='linux-5.3.1/net/mac80211/tx.c' l='3666' c='ieee80211_tx_dequeue'/>
<use f='linux-5.3.1/net/mac80211/tx.c' l='3666' u='a'/>
