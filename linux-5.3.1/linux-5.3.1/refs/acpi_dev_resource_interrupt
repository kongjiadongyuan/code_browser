<dec f='linux-5.3.1/include/linux/acpi.h' l='435' type='bool acpi_dev_resource_interrupt(struct acpi_resource * ares, int index, struct resource * res)'/>
<def f='linux-5.3.1/drivers/acpi/resource.c' l='452' ll='492' type='bool acpi_dev_resource_interrupt(struct acpi_resource * ares, int index, struct resource * res)'/>
<dec f='linux-5.3.1/drivers/acpi/resource.c' l='493' type='bool acpi_dev_resource_interrupt(struct acpi_resource * , int , struct resource * )'/>
<use f='linux-5.3.1/drivers/acpi/resource.c' l='493' c='acpi_dev_resource_interrupt'/>
<use f='linux-5.3.1/drivers/acpi/resource.c' l='493' u='a'/>
<use f='linux-5.3.1/drivers/acpi/resource.c' l='558' u='c' c='acpi_dev_process_resource'/>
<doc f='linux-5.3.1/drivers/acpi/resource.c' l='433'>/**
 * acpi_dev_resource_interrupt - Extract ACPI interrupt resource information.
 * @ares: Input ACPI resource object.
 * @index: Index into the array of GSIs represented by the resource.
 * @res: Output generic resource object.
 *
 * Check if the given ACPI resource object represents an interrupt resource
 * and @index does not exceed the resource&apos;s interrupt count (true is returned
 * in that case regardless of the results of the other checks)).  If that&apos;s the
 * case, register the GSI corresponding to @index from the array of interrupts
 * represented by the resource and populate the generic resource object pointed
 * to by @res accordingly.  If the registration of the GSI is not successful,
 * IORESOURCE_DISABLED will be set it that object&apos;s flags.
 *
 * Return:
 * 1) false with res-&gt;flags setting to zero: not the expected resource type
 * 2) false with IORESOURCE_DISABLED in res-&gt;flags: valid unassigned resource
 * 3) true: valid assigned resource
 */</doc>
<use f='linux-5.3.1/drivers/i2c/i2c-core-acpi.c' l='140' u='c' c='i2c_acpi_add_resource'/>
<use f='linux-5.3.1/drivers/pnp/pnpacpi/rsparser.c' l='182' u='c' c='pnpacpi_allocated_resource'/>
<use f='linux-5.3.1/drivers/pnp/pnpacpi/rsparser.c' l='184' u='c' c='pnpacpi_allocated_resource'/>
