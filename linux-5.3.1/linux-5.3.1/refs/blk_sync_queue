<dec f='linux-5.3.1/include/linux/blkdev.h' l='859' type='void blk_sync_queue(struct request_queue * q)'/>
<def f='linux-5.3.1/block/blk-core.c' l='274' ll='278' type='void blk_sync_queue(struct request_queue * q)'/>
<dec f='linux-5.3.1/block/blk-core.c' l='279' type='void blk_sync_queue(struct request_queue * )'/>
<use f='linux-5.3.1/block/blk-core.c' l='279' c='blk_sync_queue'/>
<use f='linux-5.3.1/block/blk-core.c' l='279' u='a'/>
<use f='linux-5.3.1/block/blk-core.c' l='360' u='c' c='blk_cleanup_queue'/>
<doc f='linux-5.3.1/block/blk-core.c' l='256'>/**
 * blk_sync_queue - cancel any pending callbacks on a queue
 * @q: the queue
 *
 * Description:
 *     The block layer may perform asynchronous callback activity
 *     on a queue, such as calling the unplug function after a timeout.
 *     A block device may call blk_sync_queue to ensure that any
 *     such activity is cancelled, thus allowing it to release resources
 *     that the callbacks might use. The caller must already have made sure
 *     that its -&gt;make_request_fn will not re-add plugging prior to calling
 *     this function.
 *
 *     This function does not cancel any asynchronous activity arising
 *     out of elevator or throttling code. That would require elevator_exit()
 *     and blkcg_exit_queue() to be called with queue lock initialized.
 *
 */</doc>
<use f='linux-5.3.1/drivers/md/md.c' l='5948' u='c' c='mddev_detach'/>
