<def f='linux-5.3.1/kernel/events/internal.h' l='112' ll='115' type='int page_order(struct ring_buffer * rb)'/>
<use f='linux-5.3.1/kernel/events/internal.h' l='120' u='c' c='perf_data_size'/>
<use f='linux-5.3.1/kernel/events/internal.h' l='148' u='c' c='__output_custom'/>
<use f='linux-5.3.1/kernel/events/internal.h' l='148' u='c' c='__output_copy'/>
<use f='linux-5.3.1/kernel/events/internal.h' l='148' u='c' c='__output_skip'/>
<use f='linux-5.3.1/kernel/events/internal.h' l='148' u='c' c='__output_copy_user'/>
<use f='linux-5.3.1/kernel/events/ring_buffer.c' l='232' u='c' c='__perf_output_begin'/>
<def f='linux-5.3.1/mm/internal.h' l='236' ll='240' type='unsigned int page_order(struct page * page)'/>
<doc f='linux-5.3.1/mm/internal.h' l='228'>/*
 * This function returns the order of a free page in the buddy system. In
 * general, page_zone(page)-&gt;lock must be held by the caller to prevent the
 * page from being allocated in parallel and returning garbage as the order.
 * If a caller does not hold page_zone(page)-&gt;lock, it must guarantee that the
 * page cannot be allocated or merged in parallel. Alternatively, it must
 * handle invalid values gracefully, and use page_order_unsafe() below.
 */</doc>
<use f='linux-5.3.1/mm/compaction.c' l='609' u='c' c='isolate_freepages_block'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='803' u='c' c='page_is_buddy'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='812' u='c' c='page_is_buddy'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='2265' u='c' c='move_freepages'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='2381' u='c' c='steal_suitable_fallback'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='8212' u='c' c='has_unmovable_pages'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='8584' u='c' c='is_free_buddy_page'/>
