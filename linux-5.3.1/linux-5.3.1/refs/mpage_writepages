<dec f='linux-5.3.1/include/linux/mpage.h' l='20' type='int mpage_writepages(struct address_space * mapping, struct writeback_control * wbc, get_block_t * get_block)'/>
<use f='linux-5.3.1/fs/fat/inode.c' l='199' u='c' c='fat_writepages'/>
<def f='linux-5.3.1/fs/mpage.c' l='711' ll='739' type='int mpage_writepages(struct address_space * mapping, struct writeback_control * wbc, get_block_t * get_block)'/>
<dec f='linux-5.3.1/fs/mpage.c' l='740' type='int mpage_writepages(struct address_space * , struct writeback_control * , get_block_t * )'/>
<use f='linux-5.3.1/fs/mpage.c' l='740' c='mpage_writepages'/>
<use f='linux-5.3.1/fs/mpage.c' l='740' u='a'/>
<doc f='linux-5.3.1/fs/mpage.c' l='692'>/**
 * mpage_writepages - walk the list of dirty pages of the given address space &amp; writepage() all of them
 * @mapping: address space structure to write
 * @wbc: subtract the number of written pages from *@wbc-&gt;nr_to_write
 * @get_block: the filesystem&apos;s block mapper function.
 *             If this is NULL then use a_ops-&gt;writepage.  Otherwise, go
 *             direct-to-BIO.
 *
 * This is a library function, which implements the writepages()
 * address_space_operation.
 *
 * If a page is already under I/O, generic_writepages() skips it, even
 * if it&apos;s dirty.  This is desirable behaviour for memory-cleaning writeback,
 * but it is INCORRECT for data-integrity system calls such as fsync().  fsync()
 * and msync() need to guarantee that all the data which was dirty at the time
 * the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
 * WB_SYNC_ALL then we were called for data integrity and we must wait for
 * existing IO to complete.
 */</doc>
