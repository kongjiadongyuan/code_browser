<dec f='linux-5.3.1/include/linux/usb/hcd.h' l='429' type='int usb_hcd_check_unlink_urb(struct usb_hcd * hcd, struct urb * urb, int status)'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='856' u='c' c='usb_rh_urb_dequeue'/>
<def f='linux-5.3.1/drivers/usb/core/hcd.c' l='1202' ll='1222' type='int usb_hcd_check_unlink_urb(struct usb_hcd * hcd, struct urb * urb, int status)'/>
<dec f='linux-5.3.1/drivers/usb/core/hcd.c' l='1223' type='int usb_hcd_check_unlink_urb(struct usb_hcd * , struct urb * , int )'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='1223' c='usb_hcd_check_unlink_urb'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='1223' u='a'/>
<doc f='linux-5.3.1/drivers/usb/core/hcd.c' l='1183'>/**
 * usb_hcd_check_unlink_urb - check whether an URB may be unlinked
 * @hcd: host controller to which @urb was submitted
 * @urb: URB being checked for unlinkability
 * @status: error code to store in @urb if the unlink succeeds
 *
 * Host controller drivers should call this routine in their dequeue()
 * method.  The HCD&apos;s private spinlock must be held and interrupts must
 * be disabled.  The actions carried out here are required for making
 * sure than an unlink is valid.
 *
 * Return: 0 for no error, otherwise a negative error code (in which case
 * the dequeue() method must fail).  The possible error codes are:
 *
 *	-EIDRM: @urb was not submitted or has already completed.
 *		The completion function may not have been called yet.
 *
 *	-EBUSY: @urb has already been unlinked.
 */</doc>
<use f='linux-5.3.1/drivers/usb/host/ehci-hcd.c' l='901' u='c' c='ehci_urb_dequeue'/>
<use f='linux-5.3.1/drivers/usb/host/ohci-hcd.c' l='323' u='c' c='ohci_urb_dequeue'/>
<use f='linux-5.3.1/drivers/usb/host/uhci-q.c' l='1489' u='c' c='uhci_urb_dequeue'/>
<use f='linux-5.3.1/drivers/usb/host/xhci.c' l='1608' u='c' c='xhci_urb_dequeue'/>
