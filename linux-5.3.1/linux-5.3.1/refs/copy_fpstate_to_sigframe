<dec f='linux-5.3.1/arch/x86/include/asm/fpu/internal.h' l='475' type='int copy_fpstate_to_sigframe(void * buf, void * fp, int size)'/>
<use f='linux-5.3.1/arch/x86/ia32/ia32_signal.c' l='240' u='c' c='get_sigframe'/>
<def f='linux-5.3.1/arch/x86/kernel/fpu/signal.c' l='164' ll='211' type='int copy_fpstate_to_sigframe(void * buf, void * buf_fx, int size)'/>
<doc f='linux-5.3.1/arch/x86/kernel/fpu/signal.c' l='143'>/*
 * Save the fpu, extended register state to the user signal frame.
 *
 * &apos;buf_fx&apos; is the 64-byte aligned pointer at which the [f|fx|x]save
 *  state is copied.
 *  &apos;buf&apos; points to the &apos;buf_fx&apos; or to the fsave header followed by &apos;buf_fx&apos;.
 *
 *	buf == buf_fx for 64-bit frames and 32-bit fsave frame.
 *	buf != buf_fx for 32-bit frames with fxstate.
 *
 * Try to save it directly to the user frame with disabled page fault handler.
 * If this fails then do the slow path where the FPU state is first saved to
 * task&apos;s fpu-&gt;state and then copy it to the user frame pointed to by the
 * aligned pointer &apos;buf_fx&apos;.
 *
 * If this is a 32-bit frame with fxstate, put a fsave header before
 * the aligned state at &apos;buf_fx&apos;.
 *
 * For [f]xsave state, update the SW reserved fields in the [f]xsave frame
 * indicating the absence/presence of the extended state to the user.
 */</doc>
<use f='linux-5.3.1/arch/x86/kernel/signal.c' l='281' u='c' c='get_sigframe'/>
