<dec f='linux-5.3.1/include/linux/ptrace.h' l='417' type='int task_current_syscall(struct task_struct * target, struct syscall_info * info)'/>
<use f='linux-5.3.1/fs/proc/base.c' l='639' u='c' c='proc_pid_syscall'/>
<def f='linux-5.3.1/lib/syscall.c' l='62' ll='81' type='int task_current_syscall(struct task_struct * target, struct syscall_info * info)'/>
<doc f='linux-5.3.1/lib/syscall.c' l='37'>/**
 * task_current_syscall - Discover what a blocked task is doing.
 * @target:		thread to examine
 * @info:		structure with the following fields:
 *			 .sp        - filled with user stack pointer
 *			 .data.nr   - filled with system call number or -1
 *			 .data.args - filled with @maxargs system call arguments
 *			 .data.instruction_pointer - filled with user PC
 *
 * If @target is blocked in a system call, returns zero with @info.data.nr
 * set to the the call&apos;s number and @info.data.args filled in with its
 * arguments. Registers not used for system call arguments may not be available
 * and it is not kosher to use &amp;struct user_regset calls while the system
 * call is still in progress.  Note we may get this result if @target
 * has finished its system call but not yet returned to user mode, such
 * as when it&apos;s stopped for signal handling or syscall exit tracing.
 *
 * If @target is blocked in the kernel during a fault or exception,
 * returns zero with *@info.data.nr set to -1 and does not fill in
 * @info.data.args. If so, it&apos;s now safe to examine @target using
 * &amp;struct user_regset get() calls as long as we&apos;re sure @target won&apos;t return
 * to user mode.
 *
 * Returns -%EAGAIN if @target does not remain blocked.
 */</doc>
