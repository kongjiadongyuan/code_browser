<def f='linux-5.3.1/include/linux/regmap.h' l='352' ll='407'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='532' c='__regmap_init'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='536' c='__regmap_init_i2c'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='540' c='__regmap_init_sccb'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='544' c='__regmap_init_slimbus'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='548' c='__regmap_init_spi'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='552' c='__regmap_init_spmi_base'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='556' c='__regmap_init_spmi_ext'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='560' c='__regmap_init_w1'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='565' c='__regmap_init_mmio_clk'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='569' c='__regmap_init_ac97'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='573' c='__regmap_init_sdw'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='580' c='__devm_regmap_init'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='584' c='__devm_regmap_init_i2c'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='588' c='__devm_regmap_init_sccb'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='592' c='__devm_regmap_init_spi'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='596' c='__devm_regmap_init_spmi_base'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='600' c='__devm_regmap_init_spmi_ext'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='604' c='__devm_regmap_init_w1'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='610' c='__devm_regmap_init_mmio_clk'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='614' c='__devm_regmap_init_ac97'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='618' c='__devm_regmap_init_sdw'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='622' c='__devm_regmap_init_slimbus'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='626' c='__devm_regmap_init_i3c'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='667' c='regmap_attach_dev'/>
<use f='linux-5.3.1/include/linux/regmap.h' l='1006' c='regmap_reinit_cache'/>
<use f='linux-5.3.1/drivers/base/regmap/internal.h' l='236' c='regcache_init'/>
<use f='linux-5.3.1/drivers/base/regmap/internal.h' l='268' c='regmap_get_val_endian'/>
<size>264</size>
<doc f='linux-5.3.1/include/linux/regmap.h' l='235'>/**
 * struct regmap_config - Configuration for the register map of a device.
 *
 * @name: Optional name of the regmap. Useful when a device has multiple
 *        register regions.
 *
 * @reg_bits: Number of bits in a register address, mandatory.
 * @reg_stride: The register address stride. Valid register addresses are a
 *              multiple of this value. If set to 0, a value of 1 will be
 *              used.
 * @pad_bits: Number of bits of padding between register and value.
 * @val_bits: Number of bits in a register value, mandatory.
 *
 * @writeable_reg: Optional callback returning true if the register
 *		   can be written to. If this field is NULL but wr_table
 *		   (see below) is not, the check is performed on such table
 *                 (a register is writeable if it belongs to one of the ranges
 *                  specified by wr_table).
 * @readable_reg: Optional callback returning true if the register
 *		  can be read from. If this field is NULL but rd_table
 *		   (see below) is not, the check is performed on such table
 *                 (a register is readable if it belongs to one of the ranges
 *                  specified by rd_table).
 * @volatile_reg: Optional callback returning true if the register
 *		  value can&apos;t be cached. If this field is NULL but
 *		  volatile_table (see below) is not, the check is performed on
 *                such table (a register is volatile if it belongs to one of
 *                the ranges specified by volatile_table).
 * @precious_reg: Optional callback returning true if the register
 *		  should not be read outside of a call from the driver
 *		  (e.g., a clear on read interrupt status register). If this
 *                field is NULL but precious_table (see below) is not, the
 *                check is performed on such table (a register is precious if
 *                it belongs to one of the ranges specified by precious_table).
 * @writeable_noinc_reg: Optional callback returning true if the register
 *			supports multiple write operations without incrementing
 *			the register number. If this field is NULL but
 *			wr_noinc_table (see below) is not, the check is
 *			performed on such table (a register is no increment
 *			writeable if it belongs to one of the ranges specified
 *			by wr_noinc_table).
 * @readable_noinc_reg: Optional callback returning true if the register
 *			supports multiple read operations without incrementing
 *			the register number. If this field is NULL but
 *			rd_noinc_table (see below) is not, the check is
 *			performed on such table (a register is no increment
 *			readable if it belongs to one of the ranges specified
 *			by rd_noinc_table).
 * @disable_locking: This regmap is either protected by external means or
 *                   is guaranteed not be be accessed from multiple threads.
 *                   Don&apos;t use any locking mechanisms.
 * @lock:	  Optional lock callback (overrides regmap&apos;s default lock
 *		  function, based on spinlock or mutex).
 * @unlock:	  As above for unlocking.
 * @lock_arg:	  this field is passed as the only argument of lock/unlock
 *		  functions (ignored in case regular lock/unlock functions
 *		  are not overridden).
 * @reg_read:	  Optional callback that if filled will be used to perform
 *           	  all the reads from the registers. Should only be provided for
 *		  devices whose read operation cannot be represented as a simple
 *		  read operation on a bus such as SPI, I2C, etc. Most of the
 *		  devices do not need this.
 * @reg_write:	  Same as above for writing.
 * @fast_io:	  Register IO is fast. Use a spinlock instead of a mutex
 *	     	  to perform locking. This field is ignored if custom lock/unlock
 *	     	  functions are used (see fields lock/unlock of struct regmap_config).
 *		  This field is a duplicate of a similar file in
 *		  &apos;struct regmap_bus&apos; and serves exact same purpose.
 *		   Use it only for &quot;no-bus&quot; cases.
 * @max_register: Optional, specifies the maximum valid register address.
 * @wr_table:     Optional, points to a struct regmap_access_table specifying
 *                valid ranges for write access.
 * @rd_table:     As above, for read access.
 * @volatile_table: As above, for volatile registers.
 * @precious_table: As above, for precious registers.
 * @wr_noinc_table: As above, for no increment writeable registers.
 * @rd_noinc_table: As above, for no increment readable registers.
 * @reg_defaults: Power on reset values for registers (for use with
 *                register cache support).
 * @num_reg_defaults: Number of elements in reg_defaults.
 *
 * @read_flag_mask: Mask to be set in the top bytes of the register when doing
 *                  a read.
 * @write_flag_mask: Mask to be set in the top bytes of the register when doing
 *                   a write. If both read_flag_mask and write_flag_mask are
 *                   empty and zero_flag_mask is not set the regmap_bus default
 *                   masks are used.
 * @zero_flag_mask: If set, read_flag_mask and write_flag_mask are used even
 *                   if they are both empty.
 * @use_single_read: If set, converts the bulk read operation into a series of
 *                   single read operations. This is useful for a device that
 *                   does not support  bulk read.
 * @use_single_write: If set, converts the bulk write operation into a series of
 *                    single write operations. This is useful for a device that
 *                    does not support bulk write.
 * @can_multi_write: If set, the device supports the multi write mode of bulk
 *                   write operations, if clear multi write requests will be
 *                   split into individual write operations
 *
 * @cache_type: The actual cache type.
 * @reg_defaults_raw: Power on reset values for registers (for use with
 *                    register cache support).
 * @num_reg_defaults_raw: Number of elements in reg_defaults_raw.
 * @reg_format_endian: Endianness for formatted register addresses. If this is
 *                     DEFAULT, the @reg_format_endian_default value from the
 *                     regmap bus is used.
 * @val_format_endian: Endianness for formatted register values. If this is
 *                     DEFAULT, the @reg_format_endian_default value from the
 *                     regmap bus is used.
 *
 * @ranges: Array of configuration entries for virtual address ranges.
 * @num_ranges: Number of range configuration entries.
 * @use_hwlock: Indicate if a hardware spinlock should be used.
 * @hwlock_id: Specify the hardware spinlock id.
 * @hwlock_mode: The hardware spinlock mode, should be HWLOCK_IRQSTATE,
 *		 HWLOCK_IRQ or 0.
 */</doc>
<mbr r='regmap_config::name' o='0' t='const char *'/>
<mbr r='regmap_config::reg_bits' o='64' t='int'/>
<mbr r='regmap_config::reg_stride' o='96' t='int'/>
<mbr r='regmap_config::pad_bits' o='128' t='int'/>
<mbr r='regmap_config::val_bits' o='160' t='int'/>
<mbr r='regmap_config::writeable_reg' o='192' t='bool (*)(struct device *, unsigned int)'/>
<mbr r='regmap_config::readable_reg' o='256' t='bool (*)(struct device *, unsigned int)'/>
<mbr r='regmap_config::volatile_reg' o='320' t='bool (*)(struct device *, unsigned int)'/>
<mbr r='regmap_config::precious_reg' o='384' t='bool (*)(struct device *, unsigned int)'/>
<mbr r='regmap_config::writeable_noinc_reg' o='448' t='bool (*)(struct device *, unsigned int)'/>
<mbr r='regmap_config::readable_noinc_reg' o='512' t='bool (*)(struct device *, unsigned int)'/>
<mbr r='regmap_config::disable_locking' o='576' t='bool'/>
<mbr r='regmap_config::lock' o='640' t='regmap_lock'/>
<mbr r='regmap_config::unlock' o='704' t='regmap_unlock'/>
<mbr r='regmap_config::lock_arg' o='768' t='void *'/>
<mbr r='regmap_config::reg_read' o='832' t='int (*)(void *, unsigned int, unsigned int *)'/>
<mbr r='regmap_config::reg_write' o='896' t='int (*)(void *, unsigned int, unsigned int)'/>
<mbr r='regmap_config::fast_io' o='960' t='bool'/>
<mbr r='regmap_config::max_register' o='992' t='unsigned int'/>
<mbr r='regmap_config::wr_table' o='1024' t='const struct regmap_access_table *'/>
<mbr r='regmap_config::rd_table' o='1088' t='const struct regmap_access_table *'/>
<mbr r='regmap_config::volatile_table' o='1152' t='const struct regmap_access_table *'/>
<mbr r='regmap_config::precious_table' o='1216' t='const struct regmap_access_table *'/>
<mbr r='regmap_config::wr_noinc_table' o='1280' t='const struct regmap_access_table *'/>
<mbr r='regmap_config::rd_noinc_table' o='1344' t='const struct regmap_access_table *'/>
<mbr r='regmap_config::reg_defaults' o='1408' t='const struct reg_default *'/>
<mbr r='regmap_config::num_reg_defaults' o='1472' t='unsigned int'/>
<mbr r='regmap_config::cache_type' o='1504' t='enum regcache_type'/>
<mbr r='regmap_config::reg_defaults_raw' o='1536' t='const void *'/>
<mbr r='regmap_config::num_reg_defaults_raw' o='1600' t='unsigned int'/>
<mbr r='regmap_config::read_flag_mask' o='1664' t='unsigned long'/>
<mbr r='regmap_config::write_flag_mask' o='1728' t='unsigned long'/>
<mbr r='regmap_config::zero_flag_mask' o='1792' t='bool'/>
<mbr r='regmap_config::use_single_read' o='1800' t='bool'/>
<mbr r='regmap_config::use_single_write' o='1808' t='bool'/>
<mbr r='regmap_config::can_multi_write' o='1816' t='bool'/>
<mbr r='regmap_config::reg_format_endian' o='1824' t='enum regmap_endian'/>
<mbr r='regmap_config::val_format_endian' o='1856' t='enum regmap_endian'/>
<mbr r='regmap_config::ranges' o='1920' t='const struct regmap_range_cfg *'/>
<mbr r='regmap_config::num_ranges' o='1984' t='unsigned int'/>
<mbr r='regmap_config::use_hwlock' o='2016' t='bool'/>
<mbr r='regmap_config::hwlock_id' o='2048' t='unsigned int'/>
<mbr r='regmap_config::hwlock_mode' o='2080' t='unsigned int'/>
<use f='linux-5.3.1/drivers/base/regmap/regcache.c' l='115' c='regcache_init'/>
<size>264</size>
<use f='linux-5.3.1/drivers/base/regmap/regmap-i2c.c' l='250' c='regmap_get_i2c_bus'/>
<use f='linux-5.3.1/drivers/base/regmap/regmap-i2c.c' l='278' c='__regmap_init_i2c'/>
<use f='linux-5.3.1/drivers/base/regmap/regmap-i2c.c' l='293' c='__devm_regmap_init_i2c'/>
<size>264</size>
<use f='linux-5.3.1/drivers/base/regmap/regmap.c' l='593' c='regmap_attach_dev'/>
<use f='linux-5.3.1/drivers/base/regmap/regmap.c' l='615' c='regmap_get_reg_endian'/>
<use f='linux-5.3.1/drivers/base/regmap/regmap.c' l='640' c='regmap_get_val_endian'/>
<use f='linux-5.3.1/drivers/base/regmap/regmap.c' l='685' c='__regmap_init'/>
<use f='linux-5.3.1/drivers/base/regmap/regmap.c' l='1182' c='__devm_regmap_init'/>
<use f='linux-5.3.1/drivers/base/regmap/regmap.c' l='1310' c='regmap_reinit_cache'/>
<size>264</size>
<use f='linux-5.3.1/sound/hda/hdac_regmap.c' l='352'/>
<size>264</size>
