<dec f='linux-5.3.1/include/linux/usb.h' l='1710' type='void usb_block_urb(struct urb * urb)'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='563' u='c' c='__usbhid_submit_report'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='614' u='c' c='__usbhid_submit_report'/>
<use f='linux-5.3.1/drivers/usb/core/message.c' l='315' u='c' c='sg_complete'/>
<use f='linux-5.3.1/drivers/usb/core/message.c' l='600' u='c' c='usb_sg_cancel'/>
<def f='linux-5.3.1/drivers/usb/core/urb.c' l='764' ll='770' type='void usb_block_urb(struct urb * urb)'/>
<dec f='linux-5.3.1/drivers/usb/core/urb.c' l='771' type='void usb_block_urb(struct urb * )'/>
<use f='linux-5.3.1/drivers/usb/core/urb.c' l='771' c='usb_block_urb'/>
<use f='linux-5.3.1/drivers/usb/core/urb.c' l='771' u='a'/>
<doc f='linux-5.3.1/drivers/usb/core/urb.c' l='752'>/**
 * usb_block_urb - reliably prevent further use of an URB
 * @urb: pointer to URB to be blocked, may be NULL
 *
 * After the routine has run, attempts to resubmit the URB will fail
 * with error -EPERM.  Thus even if the URB&apos;s completion handler always
 * tries to resubmit, it will not succeed and the URB will become idle.
 *
 * The URB must not be deallocated while this routine is running.  In
 * particular, when a driver calls this routine, it must insure that the
 * completion handler cannot deallocate the URB.
 */</doc>
