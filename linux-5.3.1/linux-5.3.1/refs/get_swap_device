<dec f='linux-5.3.1/include/linux/swap.h' l='473' type='struct swap_info_struct * get_swap_device(swp_entry_t entry)'/>
<use f='linux-5.3.1/mm/mincore.c' l='74' u='c' c='mincore_page'/>
<use f='linux-5.3.1/mm/swap_state.c' l='85' u='c' c='total_swapcache_pages'/>
<use f='linux-5.3.1/mm/swap_state.c' l='316' u='c' c='lookup_swap_cache'/>
<use f='linux-5.3.1/mm/swap_state.c' l='374' u='c' c='__read_swap_cache_async'/>
<def f='linux-5.3.1/mm/swapfile.c' l='1249' ll='1275' type='struct swap_info_struct * get_swap_device(swp_entry_t entry)'/>
<use f='linux-5.3.1/mm/swapfile.c' l='1454' u='c' c='__swap_count'/>
<use f='linux-5.3.1/mm/swapfile.c' l='1484' u='c' c='__swp_swapcount'/>
<use f='linux-5.3.1/mm/swapfile.c' l='3378' u='c' c='__swap_duplicate'/>
<use f='linux-5.3.1/mm/swapfile.c' l='3530' u='c' c='add_swap_count_continuation'/>
<doc f='linux-5.3.1/mm/swapfile.c' l='1214'>/*
 * Check whether swap entry is valid in the swap device.  If so,
 * return pointer to swap_info_struct, and keep the swap entry valid
 * via preventing the swap device from being swapoff, until
 * put_swap_device() is called.  Otherwise return NULL.
 *
 * The entirety of the RCU read critical section must come before the
 * return from or after the call to synchronize_rcu() in
 * enable_swap_info() or swapoff().  So if &quot;si-&gt;flags &amp; SWP_VALID&quot; is
 * true, the si-&gt;map, si-&gt;cluster_info, etc. must be valid in the
 * critical section.
 *
 * Notice that swapoff or swapoff+swapon can still happen before the
 * rcu_read_lock() in get_swap_device() or after the rcu_read_unlock()
 * in put_swap_device() if there isn&apos;t any other way to prevent
 * swapoff, such as page lock, page table lock, etc.  The caller must
 * be prepared for that.  For example, the following situation is
 * possible.
 *
 *   CPU1				CPU2
 *   do_swap_page()
 *     ...				swapoff+swapon
 *     __read_swap_cache_async()
 *       swapcache_prepare()
 *         __swap_duplicate()
 *           // check swap_map
 *     // verify PTE not changed
 *
 * In __swap_duplicate(), the swap_map need to be checked before
 * changing partly because the specified swap entry may be for another
 * swap device which has been swapoff.  And in do_swap_page(), after
 * the page is read from the swap device, the PTE is verified not
 * changed with the page table locked to check whether the swap device
 * has been swapoff or swapoff+swapon.
 */</doc>
