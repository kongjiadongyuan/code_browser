<dec f='linux-5.3.1/include/net/ipv6.h' l='809' type='__be32 ipv6_proxy_select_ident(struct net * net, struct sk_buff * skb)'/>
<def f='linux-5.3.1/net/ipv6/output_core.c' l='53' ll='68' type='__be32 ipv6_proxy_select_ident(struct net * net, struct sk_buff * skb)'/>
<dec f='linux-5.3.1/net/ipv6/output_core.c' l='69' type='__be32 ipv6_proxy_select_ident(struct net * , struct sk_buff * )'/>
<use f='linux-5.3.1/net/ipv6/output_core.c' l='69' c='ipv6_proxy_select_ident'/>
<use f='linux-5.3.1/net/ipv6/output_core.c' l='69' u='a'/>
<doc f='linux-5.3.1/net/ipv6/output_core.c' l='45'>/* This function exists only for tap drivers that must support broken
 * clients requesting UFO without specifying an IPv6 fragment ID.
 *
 * This is similar to ipv6_select_ident() but we use an independent hash
 * seed to limit information leakage.
 *
 * The network header must be set before calling this.
 */</doc>
<use f='linux-5.3.1/net/ipv6/udp_offload.c' l='102' u='c' c='udp6_ufo_fragment'/>
