<dec f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_ioctls.h' l='29' type='int i915_gem_mmap_ioctl(struct drm_device * dev, void * data, struct drm_file * file)'/>
<def f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_mman.c' l='48' ll='114' type='int i915_gem_mmap_ioctl(struct drm_device * dev, void * data, struct drm_file * file)'/>
<doc f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_mman.c' l='28'>/**
 * i915_gem_mmap_ioctl - Maps the contents of an object, returning the address
 *			 it is mapped to.
 * @dev: drm device
 * @data: ioctl data blob
 * @file: drm file
 *
 * While the mapping holds a reference on the contents of the object, it doesn&apos;t
 * imply a ref on the object itself.
 *
 * IMPORTANT:
 *
 * DRM driver writers who look a this function as an example for how to do GEM
 * mmap support, please don&apos;t implement mmap support like here. The modern way
 * to implement DRM mmap support is with an mmap offset ioctl (like
 * i915_gem_mmap_gtt) and then using the mmap syscall on the DRM fd directly.
 * That way debug tooling like valgrind will understand what&apos;s going on, hiding
 * the mmap call in a driver private ioctl will break that. The i915 driver only
 * does cpu mmaps this way because we didn&apos;t know better.
 */</doc>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3175'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3175'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3175'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3175'/>
