<def f='linux-5.3.1/arch/x86/include/asm/fpu/internal.h' l='500' ll='503' type='void __cpu_invalidate_fpregs_state()'/>
<doc f='linux-5.3.1/arch/x86/include/asm/fpu/internal.h' l='483'>/*
 * The in-register FPU state for an FPU context on a CPU is assumed to be
 * valid if the fpu-&gt;last_cpu matches the CPU, and the fpu_fpregs_owner_ctx
 * matches the FPU.
 *
 * If the FPU register state is valid, the kernel can skip restoring the
 * FPU state from memory.
 *
 * Any code that clobbers the FPU registers or updates the in-memory
 * FPU state for a task MUST let the rest of the kernel know that the
 * FPU registers are no longer valid for this task.
 *
 * Either one of these invalidation functions is enough. Invalidate
 * a resource you control: CPU if using the CPU for something else
 * (with preemption disabled), FPU for the current task, or a task that
 * is prevented from running by the current task.
 */</doc>
<use f='linux-5.3.1/arch/x86/kernel/fpu/core.c' l='103' u='c' c='kernel_fpu_begin'/>
