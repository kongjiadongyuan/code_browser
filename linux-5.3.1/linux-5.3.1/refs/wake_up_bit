<dec f='linux-5.3.1/include/linux/wait_bit.h' l='29' type='void wake_up_bit(void * word, int bit)'/>
<use f='linux-5.3.1/include/linux/wait_bit.h' l='335' u='c' c='clear_and_wake_up_bit'/>
<use f='linux-5.3.1/include/linux/fs.h' l='3144' u='c' c='inode_dio_end'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/gt/intel_reset.c' l='1366' u='c' c='i915_handle_error'/>
<use f='linux-5.3.1/drivers/md/dm.c' l='2828' u='c' c='__dm_internal_resume'/>
<use f='linux-5.3.1/fs/block_dev.c' l='1197' u='c' c='bd_clear_claiming'/>
<use f='linux-5.3.1/fs/buffer.c' l='74' u='c' c='unlock_buffer'/>
<use f='linux-5.3.1/fs/dcache.c' l='1977' u='c' c='d_instantiate_new'/>
<use f='linux-5.3.1/fs/fs-writeback.c' l='1114' u='c' c='inode_sync_complete'/>
<use f='linux-5.3.1/fs/inode.c' l='584' u='c' c='evict'/>
<use f='linux-5.3.1/fs/inode.c' l='987' u='c' c='unlock_new_inode'/>
<use f='linux-5.3.1/fs/inode.c' l='999' u='c' c='discard_new_inode'/>
<use f='linux-5.3.1/fs/jbd2/commit.c' l='44' u='c' c='journal_end_buffer_io_sync'/>
<use f='linux-5.3.1/fs/jbd2/commit.c' l='245' u='c' c='journal_submit_data_buffers'/>
<use f='linux-5.3.1/fs/jbd2/commit.c' l='280' u='c' c='journal_finish_inode_data_buffers'/>
<use f='linux-5.3.1/fs/nfs/inode.c' l='1331' u='c' c='nfs_revalidate_mapping'/>
<use f='linux-5.3.1/fs/nfs/nfs4state.c' l='1215' u='c' c='nfs4_clear_state_manager_bit'/>
<use f='linux-5.3.1/fs/nfs/pagelist.c' l='176' u='c' c='nfs_page_group_unlock'/>
<use f='linux-5.3.1/fs/nfs/pagelist.c' l='394' u='c' c='nfs_unlock_request'/>
<def f='linux-5.3.1/kernel/sched/wait_bit.c' l='147' ll='150' type='void wake_up_bit(void * word, int bit)'/>
<dec f='linux-5.3.1/kernel/sched/wait_bit.c' l='151' type='void wake_up_bit(void * , int )'/>
<use f='linux-5.3.1/kernel/sched/wait_bit.c' l='151' c='wake_up_bit'/>
<use f='linux-5.3.1/kernel/sched/wait_bit.c' l='151' u='a'/>
<doc f='linux-5.3.1/kernel/sched/wait_bit.c' l='130'>/**
 * wake_up_bit - wake up a waiter on a bit
 * @word: the word being waited on, a kernel virtual address
 * @bit: the bit of the word being waited on
 *
 * There is a standard hashed waitqueue table for generic use. This
 * is the part of the hashtable&apos;s accessor API that wakes up waiters
 * on a bit. For instance, if one were to have waiters on a bitflag,
 * one would call wake_up_bit() after clearing the bit.
 *
 * In order for this to function properly, as it uses waitqueue_active()
 * internally, some kind of memory barrier must be done prior to calling
 * this. Typically, this will be smp_mb__after_atomic(), but in some
 * cases where bitflags are manipulated non-atomically under a lock, one
 * may need to use a less regular barrier, such fs/inode.c&apos;s smp_mb(),
 * because spin_unlock() does not guarantee a memory barrier.
 */</doc>
<use f='linux-5.3.1/kernel/signal.c' l='318' u='c' c='task_clear_jobctl_trapping'/>
<use f='linux-5.3.1/net/sunrpc/sched.c' l='376' u='c' c='rpc_make_runnable'/>
<use f='linux-5.3.1/net/sunrpc/xprt.c' l='659' u='c' c='xprt_autoclose'/>
<use f='linux-5.3.1/net/sunrpc/xprt.c' l='802' u='c' c='xprt_unlock_connect'/>
<use f='linux-5.3.1/security/keys/gc.c' l='313' u='c' c='key_garbage_collector'/>
<use f='linux-5.3.1/security/keys/key.c' l='473' u='c' c='__key_instantiate_and_link'/>
<use f='linux-5.3.1/security/keys/key.c' l='627' u='c' c='key_reject_and_link'/>
