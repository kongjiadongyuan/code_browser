<def f='linux-5.3.1/arch/x86/include/asm/word-at-a-time.h' l='14' ll='16'/>
<use f='linux-5.3.1/arch/x86/include/asm/word-at-a-time.h' l='47' c='has_zero'/>
<use f='linux-5.3.1/arch/x86/include/asm/word-at-a-time.h' l='54' c='prep_zero_mask'/>
<size>16</size>
<doc f='linux-5.3.1/arch/x86/include/asm/word-at-a-time.h' l='7'>/*
 * This is largely generic for little-endian machines, but the
 * optimal byte mask counting is probably going to be something
 * that is architecture-specific. If you have a reliably fast
 * bit count instruction, that might be better than the multiply
 * and shift, for example.
 */</doc>
<mbr r='word_at_a_time::one_bits' o='0' t='const unsigned long'/>
<mbr r='word_at_a_time::high_bits' o='64' t='const unsigned long'/>
<use f='linux-5.3.1/fs/namei.c' l='1961' c='hashlen_string'/>
<use f='linux-5.3.1/fs/namei.c' l='1989' c='hash_name'/>
<size>16</size>
<use f='linux-5.3.1/lib/string.c' l='181' c='strscpy'/>
<size>16</size>
<use f='linux-5.3.1/lib/strncpy_from_user.c' l='29' c='do_strncpy_from_user'/>
<size>16</size>
<use f='linux-5.3.1/lib/strnlen_user.c' l='30' c='do_strnlen_user'/>
<size>16</size>
