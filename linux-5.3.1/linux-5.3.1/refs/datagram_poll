<dec f='linux-5.3.1/include/linux/skbuff.h' l='3419' type='__poll_t datagram_poll(struct file * file, struct socket * sock, struct poll_table_struct * wait)'/>
<def f='linux-5.3.1/net/core/datagram.c' l='760' ll='799' type='__poll_t datagram_poll(struct file * file, struct socket * sock, poll_table * wait)'/>
<dec f='linux-5.3.1/net/core/datagram.c' l='800' type='__poll_t datagram_poll(struct file * , struct socket * , struct poll_table_struct * )'/>
<use f='linux-5.3.1/net/core/datagram.c' l='800' c='datagram_poll'/>
<use f='linux-5.3.1/net/core/datagram.c' l='800' u='a'/>
<doc f='linux-5.3.1/net/core/datagram.c' l='746'>/**
 * 	datagram_poll - generic datagram poll
 *	@file: file struct
 *	@sock: socket
 *	@wait: poll table
 *
 *	Datagram poll: Again totally generic. This also handles
 *	sequenced packet sockets providing the socket receive queue
 *	is only ever holding data ready to receive.
 *
 *	Note: when you *don&apos;t* use this routine for this protocol,
 *	and you use a different write policy from sock_writeable()
 *	then please supply your own write_space callback.
 */</doc>
<use f='linux-5.3.1/net/ipv4/af_inet.c' l='1061'/>
<use f='linux-5.3.1/net/ipv4/af_inet.c' l='1061'/>
<use f='linux-5.3.1/net/ipv4/udp.c' l='2709' u='c' c='udp_poll'/>
<use f='linux-5.3.1/net/ipv6/raw.c' l='1366'/>
<use f='linux-5.3.1/net/ipv6/raw.c' l='1366'/>
<use f='linux-5.3.1/net/netlink/af_netlink.c' l='2673'/>
<use f='linux-5.3.1/net/netlink/af_netlink.c' l='2673'/>
<use f='linux-5.3.1/net/packet/af_packet.c' l='4149' u='c' c='packet_poll'/>
<use f='linux-5.3.1/net/packet/af_packet.c' l='4493'/>
<use f='linux-5.3.1/net/packet/af_packet.c' l='4493'/>
