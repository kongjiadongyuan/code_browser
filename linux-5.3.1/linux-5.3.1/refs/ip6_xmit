<dec f='linux-5.3.1/include/net/ipv6.h' l='983' type='int ip6_xmit(const struct sock * sk, struct sk_buff * skb, struct flowi6 * fl6, __u32 mark, struct ipv6_txoptions * opt, int tclass)'/>
<doc f='linux-5.3.1/include/net/ipv6.h' l='980'>/*
 *	upper-layer output functions
 */</doc>
<use f='linux-5.3.1/net/ipv6/inet6_connection_sock.c' l='135' u='c' c='inet6_csk_xmit'/>
<def f='linux-5.3.1/net/ipv6/ip6_output.c' l='195' ll='293' type='int ip6_xmit(const struct sock * sk, struct sk_buff * skb, struct flowi6 * fl6, __u32 mark, struct ipv6_txoptions * opt, int tclass)'/>
<dec f='linux-5.3.1/net/ipv6/ip6_output.c' l='294' type='int ip6_xmit(const struct sock * , struct sk_buff * , struct flowi6 * , __u32 , struct ipv6_txoptions * , int )'/>
<use f='linux-5.3.1/net/ipv6/ip6_output.c' l='294' c='ip6_xmit'/>
<use f='linux-5.3.1/net/ipv6/ip6_output.c' l='294' u='a'/>
<doc f='linux-5.3.1/net/ipv6/ip6_output.c' l='189'>/*
 * xmit an sk_buff (used by TCP, SCTP and DCCP)
 * Note : socket lock is not held for SYNACK packets, but might be modified
 * by calls to skb_set_owner_w() and ipv6_local_error(),
 * which are using proper atomic operations or spinlocks.
 */</doc>
<use f='linux-5.3.1/net/ipv6/tcp_ipv6.c' l='515' u='c' c='tcp_v6_send_synack'/>
<use f='linux-5.3.1/net/ipv6/tcp_ipv6.c' l='910' u='c' c='tcp_v6_send_response'/>
