<dec f='linux-5.3.1/arch/x86/include/asm/text-patching.h' l='51' type='void * text_poke(void * addr, const void * opcode, size_t len)'/>
<use f='linux-5.3.1/arch/x86/kernel/alternative.c' l='452' u='c' c='alternatives_smp_lock'/>
<use f='linux-5.3.1/arch/x86/kernel/alternative.c' l='468' u='c' c='alternatives_smp_unlock'/>
<def f='linux-5.3.1/arch/x86/kernel/alternative.c' l='908' ll='913' type='void * text_poke(void * addr, const void * opcode, size_t len)'/>
<use f='linux-5.3.1/arch/x86/kernel/alternative.c' l='1049' u='c' c='text_poke_bp_batch'/>
<use f='linux-5.3.1/arch/x86/kernel/alternative.c' l='1058' u='c' c='text_poke_bp_batch'/>
<use f='linux-5.3.1/arch/x86/kernel/alternative.c' l='1079' u='c' c='text_poke_bp_batch'/>
<doc f='linux-5.3.1/arch/x86/kernel/alternative.c' l='892'>/**
 * text_poke - Update instructions on a live kernel
 * @addr: address to modify
 * @opcode: source of the copy
 * @len: length to copy
 *
 * Only atomic text poke/set should be allowed when not doing early patching.
 * It means the size must be writable atomically and the address must be aligned
 * in a way that permits an atomic write. It also makes sure we fit on a single
 * page.
 *
 * Note that the caller must ensure that if the modified code is part of a
 * module, the module would not be removed during poking. This can be achieved
 * by registering a module notifier, and ordering module removal and patching
 * trough a mutex.
 */</doc>
<doc f='linux-5.3.1/arch/x86/include/asm/text-patching.h' l='37'>/*
 * Clear and restore the kernel write-protection flag on the local CPU.
 * Allows the kernel to edit read-only pages.
 * Side-effect: any interrupt handler running between save and restore will have
 * the ability to write to read-only pages.
 *
 * Warning:
 * Code patching in the UP case is safe if NMIs and MCE handlers are stopped and
 * no thread can be preempted in the instructions being modified (no iret to an
 * invalid instruction possible) or if the instructions are changed from a
 * consistent state to another consistent state atomically.
 * On the local CPU you need to be protected again NMI or MCE handlers seeing an
 * inconsistent instruction while you patch.
 */</doc>
<use f='linux-5.3.1/arch/x86/kernel/kprobes/core.c' l='470' u='c' c='arch_copy_kprobe'/>
<use f='linux-5.3.1/arch/x86/kernel/kprobes/core.c' l='500' u='c' c='arch_arm_kprobe'/>
<use f='linux-5.3.1/arch/x86/kernel/kprobes/core.c' l='505' u='c' c='arch_disarm_kprobe'/>
<use f='linux-5.3.1/arch/x86/kernel/kprobes/opt.c' l='407' u='c' c='arch_prepare_optimized_kprobe'/>
