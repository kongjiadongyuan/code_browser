<def f='linux-5.3.1/include/linux/skbuff.h' l='1788' ll='1796' type='struct sk_buff * skb_peek_tail(const struct sk_buff_head * list_)'/>
<use f='linux-5.3.1/include/linux/skbuff.h' l='2045' u='c' c='__skb_dequeue_tail'/>
<doc f='linux-5.3.1/include/linux/skbuff.h' l='1775'>/**
 *	skb_peek_tail - peek at the tail of an &amp;sk_buff_head
 *	@list_: list to peek at
 *
 *	Peek an &amp;sk_buff. Unlike most other operations you _MUST_
 *	be careful with this one. A peek leaves the buffer on the
 *	list and someone else may run off with it. You must hold
 *	the appropriate locks or have a private queue to do this.
 *
 *	Returns %NULL for an empty list or a pointer to the tail element.
 *	The reference count is not incremented and the reference is therefore
 *	volatile. Use with caution.
 */</doc>
<use f='linux-5.3.1/include/net/tcp.h' l='1724' u='c' c='tcp_write_queue_tail'/>
<use f='linux-5.3.1/net/core/neighbour.c' l='1006' u='c' c='neigh_probe'/>
<use f='linux-5.3.1/net/core/skbuff.c' l='1229' u='c' c='sock_zerocopy_callback'/>
<use f='linux-5.3.1/net/core/sock.c' l='2469' u='c' c='sk_wait_data'/>
<use f='linux-5.3.1/net/core/sock.c' l='2469' u='c' c='sk_wait_data'/>
<use f='linux-5.3.1/net/ipv4/ip_output.c' l='977' u='c' c='__ip_append_data'/>
<use f='linux-5.3.1/net/ipv4/ip_output.c' l='1358' u='c' c='ip_append_page'/>
<use f='linux-5.3.1/net/ipv4/tcp.c' l='2019' u='c' c='tcp_recvmsg'/>
<use f='linux-5.3.1/net/ipv4/tcp_input.c' l='4456' u='c' c='tcp_ofo_queue'/>
<use f='linux-5.3.1/net/ipv4/tcp_input.c' l='4633' u='c' c='tcp_queue_rcv'/>
<use f='linux-5.3.1/net/ipv6/ip6_output.c' l='1336' u='c' c='__ip6_append_data'/>
<use f='linux-5.3.1/net/mac80211/rx.c' l='1107' u='c' c='ieee80211_rx_reorder_ready'/>
<use f='linux-5.3.1/net/mac80211/tx.c' l='3268' u='c' c='ieee80211_amsdu_aggregate'/>
<use f='linux-5.3.1/net/unix/af_unix.c' l='1932' u='c' c='unix_stream_sendpage'/>
<use f='linux-5.3.1/net/unix/af_unix.c' l='2148' u='c' c='unix_stream_data_wait'/>
