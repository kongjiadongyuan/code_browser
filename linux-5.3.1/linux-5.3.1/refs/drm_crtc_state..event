<dec f='linux-5.3.1/include/drm/drm_crtc.h' l='363' type='struct drm_pending_vblank_event *'/>
<offset>3904</offset>
<doc f='linux-5.3.1/include/drm/drm_crtc.h' l='315'>/**
	 * @event:
	 *
	 * Optional pointer to a DRM event to signal upon completion of the
	 * state update. The driver must send out the event when the atomic
	 * commit operation completes. There are two cases:
	 *
	 *  - The event is for a CRTC which is being disabled through this
	 *    atomic commit. In that case the event can be send out any time
	 *    after the hardware has stopped scanning out the current
	 *    framebuffers. It should contain the timestamp and counter for the
	 *    last vblank before the display pipeline was shut off. The simplest
	 *    way to achieve that is calling drm_crtc_send_vblank_event()
	 *    somewhen after drm_crtc_vblank_off() has been called.
	 *
	 *  - For a CRTC which is enabled at the end of the commit (even when it
	 *    undergoes an full modeset) the vblank timestamp and counter must
	 *    be for the vblank right before the first frame that scans out the
	 *    new set of buffers. Again the event can only be sent out after the
	 *    hardware has stopped scanning out the old buffers.
	 *
	 *  - Events for disabled CRTCs are not allowed, and drivers can ignore
	 *    that case.
	 *
	 * This can be handled by the drm_crtc_send_vblank_event() function,
	 * which the driver should call on the provided event upon completion of
	 * the atomic commit. Note that if the driver supports vblank signalling
	 * and timestamping the vblank counters and timestamps must agree with
	 * the ones returned from page flip events. With the current vblank
	 * helper infrastructure this can be achieved by holding a vblank
	 * reference while the page flip is pending, acquired through
	 * drm_crtc_vblank_get() and released with drm_crtc_vblank_put().
	 * Drivers are free to implement their own vblank counter and timestamp
	 * tracking though, e.g. if they have accurate timestamp registers in
	 * hardware.
	 *
	 * For hardware which supports some means to synchronize vblank
	 * interrupt delivery with committing display state there&apos;s also
	 * drm_crtc_arm_vblank_event(). See the documentation of that function
	 * for a detailed discussion of the constraints it needs to be used
	 * safely.
	 *
	 * If the device can&apos;t notify of flip completion in a race-free way
	 * at all, then the event should be armed just after the page flip is
	 * committed. In the worst case the driver will send the event to
	 * userspace one frame too late. This doesn&apos;t allow for a real atomic
	 * update, but it should avoid tearing.
	 */</doc>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic.c' l='369' u='r' c='drm_atomic_crtc_check'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_helper.c' l='2019' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_helper.c' l='2025' u='w' c='drm_atomic_helper_setup_commit'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_helper.c' l='2028' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_helper.c' l='2029' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_helper.c' l='2190' u='r' c='drm_atomic_helper_fake_vblank'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_helper.c' l='2192' u='r' c='drm_atomic_helper_fake_vblank'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_helper.c' l='2193' u='w' c='drm_atomic_helper_fake_vblank'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_helper.c' l='2238' u='r' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_helper.c' l='3277' u='w' c='page_flip_common'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_state_helper.c' l='130' u='w' c='__drm_atomic_helper_crtc_duplicate_state'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_state_helper.c' l='182' u='r' c='__drm_atomic_helper_crtc_destroy_state'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_uapi.c' l='1127' u='w' c='prepare_signaling'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_uapi.c' l='1131' u='r' c='prepare_signaling'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_uapi.c' l='1140' u='w' c='prepare_signaling'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_uapi.c' l='1169' u='r' c='prepare_signaling'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_uapi.c' l='1242' u='r' c='complete_signaling'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_atomic_uapi.c' l='1250' u='w' c='complete_signaling'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_display.c' l='13861' u='r' c='intel_atomic_commit_tail'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_display.c' l='13863' u='r' c='intel_atomic_commit_tail'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_display.c' l='13866' u='w' c='intel_atomic_commit_tail'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_sprite.c' l='218' u='r' c='intel_pipe_update_end'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_sprite.c' l='222' u='r' c='intel_pipe_update_end'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_sprite.c' l='225' u='w' c='intel_pipe_update_end'/>
