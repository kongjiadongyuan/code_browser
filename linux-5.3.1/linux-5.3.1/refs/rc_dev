<use f='linux-5.3.1/include/media/rc-core.h' l='73'/>
<def f='linux-5.3.1/include/media/rc-core.h' l='162' ll='229'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='212'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='213'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='214'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='215'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='216'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='217'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='218'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='219'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='220'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='221'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='222'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='223'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='225'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='227'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='246' c='rc_allocate_device'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='255' c='devm_rc_allocate_device'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='262' c='rc_free_device'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='269' c='rc_register_device'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='277' c='devm_rc_register_device'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='284' c='rc_unregister_device'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='286' c='rc_repeat'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='287' c='rc_keydown'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='289' c='rc_keydown_notimeout'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='291' c='rc_keyup'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='292' c='rc_g_keycode_from_table'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='318' c='ir_raw_event_handle'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='319' c='ir_raw_event_store'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='320' c='ir_raw_event_store_edge'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='321' c='ir_raw_event_store_with_filter'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='323' c='ir_raw_event_store_with_timeout'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='325' c='ir_raw_event_set_idle'/>
<use f='linux-5.3.1/include/media/rc-core.h' l='330' c='ir_raw_event_reset'/>
<use f='linux-5.3.1/include/media/cec.h' l='183'/>
<size>1216</size>
<doc f='linux-5.3.1/include/media/rc-core.h' l='83'>/**
 * struct rc_dev - represents a remote control device
 * @dev: driver model&apos;s view of this device
 * @managed_alloc: devm_rc_allocate_device was used to create rc_dev
 * @sysfs_groups: sysfs attribute groups
 * @device_name: name of the rc child device
 * @input_phys: physical path to the input child device
 * @input_id: id of the input child device (struct input_id)
 * @driver_name: name of the hardware driver which registered this device
 * @map_name: name of the default keymap
 * @rc_map: current scan/key table
 * @lock: used to ensure we&apos;ve filled in all protocol details before
 *	anyone can call show_protocols or store_protocols
 * @minor: unique minor remote control device number
 * @raw: additional data for raw pulse/space devices
 * @input_dev: the input child device used to communicate events to userspace
 * @driver_type: specifies if protocol decoding is done in hardware or software
 * @idle: used to keep track of RX state
 * @encode_wakeup: wakeup filtering uses IR encode API, therefore the allowed
 *	wakeup protocols is the set of all raw encoders
 * @allowed_protocols: bitmask with the supported RC_PROTO_BIT_* protocols
 * @enabled_protocols: bitmask with the enabled RC_PROTO_BIT_* protocols
 * @allowed_wakeup_protocols: bitmask with the supported RC_PROTO_BIT_* wakeup
 *	protocols
 * @wakeup_protocol: the enabled RC_PROTO_* wakeup protocol or
 *	RC_PROTO_UNKNOWN if disabled.
 * @scancode_filter: scancode filter
 * @scancode_wakeup_filter: scancode wakeup filters
 * @scancode_mask: some hardware decoders are not capable of providing the full
 *	scancode to the application. As this is a hardware limit, we can&apos;t do
 *	anything with it. Yet, as the same keycode table can be used with other
 *	devices, a mask is provided to allow its usage. Drivers should generally
 *	leave this field in blank
 * @users: number of current users of the device
 * @priv: driver-specific data
 * @keylock: protects the remaining members of the struct
 * @keypressed: whether a key is currently pressed
 * @keyup_jiffies: time (in jiffies) when the current keypress should be released
 * @timer_keyup: timer for releasing a keypress
 * @timer_repeat: timer for autorepeat events. This is needed for CEC, which
 *	has non-standard repeats.
 * @last_keycode: keycode of last keypress
 * @last_protocol: protocol of last keypress
 * @last_scancode: scancode of last keypress
 * @last_toggle: toggle value of last command
 * @timeout: optional time after which device stops sending data
 * @min_timeout: minimum timeout supported by device
 * @max_timeout: maximum timeout supported by device
 * @rx_resolution : resolution (in ns) of input sampler
 * @tx_resolution: resolution (in ns) of output sampler
 * @lirc_dev: lirc device
 * @lirc_cdev: lirc char cdev
 * @gap_start: time when gap starts
 * @gap_duration: duration of initial gap
 * @gap: true if we&apos;re in a gap
 * @lirc_fh_lock: protects lirc_fh list
 * @lirc_fh: list of open files
 * @registered: set to true by rc_register_device(), false by
 *	rc_unregister_device
 * @change_protocol: allow changing the protocol used on hardware decoders
 * @open: callback to allow drivers to enable polling/irq when IR input device
 *	is opened.
 * @close: callback to allow drivers to disable polling/irq when IR input device
 *	is opened.
 * @s_tx_mask: set transmitter mask (for devices with multiple tx outputs)
 * @s_tx_carrier: set transmit carrier frequency
 * @s_tx_duty_cycle: set transmit duty cycle (0% - 100%)
 * @s_rx_carrier_range: inform driver about carrier it is expected to handle
 * @tx_ir: transmit IR
 * @s_idle: enable/disable hardware idle mode, upon which,
 *	device doesn&apos;t interrupt host until it sees IR pulses
 * @s_learning_mode: enable wide band receiver used for learning
 * @s_carrier_report: enable carrier reports
 * @s_filter: set the scancode filter
 * @s_wakeup_filter: set the wakeup scancode filter. If the mask is zero
 *	then wakeup should be disabled. wakeup_protocol will be set to
 *	a valid protocol if mask is nonzero.
 * @s_timeout: set hardware timeout in ns
 */</doc>
<mbr r='rc_dev::dev' o='0' t='struct device'/>
<mbr r='rc_dev::managed_alloc' o='5696' t='bool'/>
<mbr r='rc_dev::sysfs_groups' o='5760' t='const struct attribute_group *[5]'/>
<mbr r='rc_dev::device_name' o='6080' t='const char *'/>
<mbr r='rc_dev::input_phys' o='6144' t='const char *'/>
<mbr r='rc_dev::input_id' o='6208' t='struct input_id'/>
<mbr r='rc_dev::driver_name' o='6272' t='const char *'/>
<mbr r='rc_dev::map_name' o='6336' t='const char *'/>
<mbr r='rc_dev::rc_map' o='6400' t='struct rc_map'/>
<mbr r='rc_dev::lock' o='6720' t='struct mutex'/>
<mbr r='rc_dev::minor' o='6976' t='unsigned int'/>
<mbr r='rc_dev::raw' o='7040' t='struct ir_raw_event_ctrl *'/>
<mbr r='rc_dev::input_dev' o='7104' t='struct input_dev *'/>
<mbr r='rc_dev::driver_type' o='7168' t='enum rc_driver_type'/>
<mbr r='rc_dev::idle' o='7200' t='bool'/>
<mbr r='rc_dev::encode_wakeup' o='7208' t='bool'/>
<mbr r='rc_dev::allowed_protocols' o='7232' t='u64'/>
<mbr r='rc_dev::enabled_protocols' o='7296' t='u64'/>
<mbr r='rc_dev::allowed_wakeup_protocols' o='7360' t='u64'/>
<mbr r='rc_dev::wakeup_protocol' o='7424' t='enum rc_proto'/>
<mbr r='rc_dev::scancode_filter' o='7456' t='struct rc_scancode_filter'/>
<mbr r='rc_dev::scancode_wakeup_filter' o='7520' t='struct rc_scancode_filter'/>
<mbr r='rc_dev::scancode_mask' o='7584' t='u32'/>
<mbr r='rc_dev::users' o='7616' t='u32'/>
<mbr r='rc_dev::priv' o='7680' t='void *'/>
<mbr r='rc_dev::keylock' o='7744' t='spinlock_t'/>
<mbr r='rc_dev::keypressed' o='7776' t='bool'/>
<mbr r='rc_dev::keyup_jiffies' o='7808' t='unsigned long'/>
<mbr r='rc_dev::timer_keyup' o='7872' t='struct timer_list'/>
<mbr r='rc_dev::timer_repeat' o='8192' t='struct timer_list'/>
<mbr r='rc_dev::last_keycode' o='8512' t='u32'/>
<mbr r='rc_dev::last_protocol' o='8544' t='enum rc_proto'/>
<mbr r='rc_dev::last_scancode' o='8576' t='u32'/>
<mbr r='rc_dev::last_toggle' o='8608' t='u8'/>
<mbr r='rc_dev::timeout' o='8640' t='u32'/>
<mbr r='rc_dev::min_timeout' o='8672' t='u32'/>
<mbr r='rc_dev::max_timeout' o='8704' t='u32'/>
<mbr r='rc_dev::rx_resolution' o='8736' t='u32'/>
<mbr r='rc_dev::tx_resolution' o='8768' t='u32'/>
<mbr r='rc_dev::registered' o='8800' t='bool'/>
<mbr r='rc_dev::change_protocol' o='8832' t='int (*)(struct rc_dev *, u64 *)'/>
<mbr r='rc_dev::open' o='8896' t='int (*)(struct rc_dev *)'/>
<mbr r='rc_dev::close' o='8960' t='void (*)(struct rc_dev *)'/>
<mbr r='rc_dev::s_tx_mask' o='9024' t='int (*)(struct rc_dev *, u32)'/>
<mbr r='rc_dev::s_tx_carrier' o='9088' t='int (*)(struct rc_dev *, u32)'/>
<mbr r='rc_dev::s_tx_duty_cycle' o='9152' t='int (*)(struct rc_dev *, u32)'/>
<mbr r='rc_dev::s_rx_carrier_range' o='9216' t='int (*)(struct rc_dev *, u32, u32)'/>
<mbr r='rc_dev::tx_ir' o='9280' t='int (*)(struct rc_dev *, unsigned int *, unsigned int)'/>
<mbr r='rc_dev::s_idle' o='9344' t='void (*)(struct rc_dev *, bool)'/>
<mbr r='rc_dev::s_learning_mode' o='9408' t='int (*)(struct rc_dev *, int)'/>
<mbr r='rc_dev::s_carrier_report' o='9472' t='int (*)(struct rc_dev *, int)'/>
<mbr r='rc_dev::s_filter' o='9536' t='int (*)(struct rc_dev *, struct rc_scancode_filter *)'/>
<mbr r='rc_dev::s_wakeup_filter' o='9600' t='int (*)(struct rc_dev *, struct rc_scancode_filter *)'/>
<mbr r='rc_dev::s_timeout' o='9664' t='int (*)(struct rc_dev *, unsigned int)'/>
