<dec f='linux-5.3.1/include/linux/writeback.h' l='396' type='int write_cache_pages(struct address_space * mapping, struct writeback_control * wbc, writepage_t writepage, void * data)'/>
<use f='linux-5.3.1/fs/mpage.c' l='730' u='c' c='mpage_writepages'/>
<use f='linux-5.3.1/fs/nfs/write.c' l='728' u='c' c='nfs_writepages'/>
<def f='linux-5.3.1/mm/page-writeback.c' l='2156' ll='2290' type='int write_cache_pages(struct address_space * mapping, struct writeback_control * wbc, writepage_t writepage, void * data)'/>
<dec f='linux-5.3.1/mm/page-writeback.c' l='2291' type='int write_cache_pages(struct address_space * , struct writeback_control * , writepage_t , void * )'/>
<use f='linux-5.3.1/mm/page-writeback.c' l='2291' c='write_cache_pages'/>
<use f='linux-5.3.1/mm/page-writeback.c' l='2291' u='a'/>
<use f='linux-5.3.1/mm/page-writeback.c' l='2327' u='c' c='generic_writepages'/>
<doc f='linux-5.3.1/mm/page-writeback.c' l='2125'>/**
 * write_cache_pages - walk the list of dirty pages of the given address space and write all of them.
 * @mapping: address space structure to write
 * @wbc: subtract the number of written pages from *@wbc-&gt;nr_to_write
 * @writepage: function called for each page
 * @data: data passed to writepage function
 *
 * If a page is already under I/O, write_cache_pages() skips it, even
 * if it&apos;s dirty.  This is desirable behaviour for memory-cleaning writeback,
 * but it is INCORRECT for data-integrity system calls such as fsync().  fsync()
 * and msync() need to guarantee that all the data which was dirty at the time
 * the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
 * WB_SYNC_ALL then we were called for data integrity and we must wait for
 * existing IO to complete.
 *
 * To avoid livelocks (when other process dirties new pages), we first tag
 * pages which should be written back with TOWRITE tag and only then start
 * writing them. For data-integrity sync we have to be careful so that we do
 * not miss some pages (e.g., because some other process has cleared TOWRITE
 * tag we set). The rule we follow is that TOWRITE tag can be cleared only
 * by the process clearing the DIRTY tag (and submitting the page for IO).
 *
 * To avoid deadlocks between range_cyclic writeback and callers that hold
 * pages in PageWriteback to aggregate IO until write_cache_pages() returns,
 * we do not loop back to the start of the file. Doing so causes a page
 * lock/page writeback access order inversion - we should only ever lock
 * multiple pages in ascending page-&gt;index order, and looping back to the start
 * of the file violates that rule and causes deadlocks.
 *
 * Return: %0 on success, negative error code otherwise
 */</doc>
