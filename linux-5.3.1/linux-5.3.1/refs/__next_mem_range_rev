<dec f='linux-5.3.1/include/linux/memblock.h' l='139' type='void __next_mem_range_rev(u64 * idx, int nid, enum memblock_flags flags, struct memblock_type * type_a, struct memblock_type * type_b, phys_addr_t * out_start, phys_addr_t * out_end, int * out_nid)'/>
<use f='linux-5.3.1/mm/memblock.c' l='232' macro='1' u='c' c='__memblock_find_range_top_down'/>
<use f='linux-5.3.1/mm/memblock.c' l='232' macro='1' u='c' c='__memblock_find_range_top_down'/>
<def f='linux-5.3.1/mm/memblock.c' l='1111' ll='1190' type='void __next_mem_range_rev(u64 * idx, int nid, enum memblock_flags flags, struct memblock_type * type_a, struct memblock_type * type_b, phys_addr_t * out_start, phys_addr_t * out_end, int * out_nid)'/>
<doc f='linux-5.3.1/mm/memblock.c' l='1094'>/**
 * __next_mem_range_rev - generic next function for for_each_*_range_rev()
 *
 * @idx: pointer to u64 loop variable
 * @nid: node selector, %NUMA_NO_NODE for all nodes
 * @flags: pick from blocks based on memory attributes
 * @type_a: pointer to memblock_type from where the range is taken
 * @type_b: pointer to memblock_type which excludes memory from being taken
 * @out_start: ptr to phys_addr_t for start address of the range, can be %NULL
 * @out_end: ptr to phys_addr_t for end address of the range, can be %NULL
 * @out_nid: ptr to int for nid of the range, can be %NULL
 *
 * Finds the next range from type_a which is not marked as unsuitable
 * in type_b.
 *
 * Reverse of __next_mem_range().
 */</doc>
