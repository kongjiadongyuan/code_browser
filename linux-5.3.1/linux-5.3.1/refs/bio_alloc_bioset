<dec f='linux-5.3.1/include/linux/bio.h' l='390' type='struct bio * bio_alloc_bioset(gfp_t , unsigned int , struct bio_set * )'/>
<use f='linux-5.3.1/include/linux/bio.h' l='400' u='c' c='bio_alloc'/>
<use f='linux-5.3.1/include/linux/bio.h' l='405' u='c' c='bio_kmalloc'/>
<def f='linux-5.3.1/block/bio.c' l='426' ll='520' type='struct bio * bio_alloc_bioset(gfp_t gfp_mask, unsigned int nr_iovecs, struct bio_set * bs)'/>
<dec f='linux-5.3.1/block/bio.c' l='521' type='struct bio * bio_alloc_bioset(gfp_t , unsigned int , struct bio_set * )'/>
<use f='linux-5.3.1/block/bio.c' l='521' c='bio_alloc_bioset'/>
<use f='linux-5.3.1/block/bio.c' l='521' u='a'/>
<use f='linux-5.3.1/block/bio.c' l='609' u='c' c='bio_clone_fast'/>
<doc f='linux-5.3.1/block/bio.c' l='391'>/**
 * bio_alloc_bioset - allocate a bio for I/O
 * @gfp_mask:   the GFP_* mask given to the slab allocator
 * @nr_iovecs:	number of iovecs to pre-allocate
 * @bs:		the bio_set to allocate from.
 *
 * Description:
 *   If @bs is NULL, uses kmalloc() to allocate the bio; else the allocation is
 *   backed by the @bs&apos;s mempool.
 *
 *   When @bs is not NULL, if %__GFP_DIRECT_RECLAIM is set then bio_alloc will
 *   always be able to allocate a bio. This is due to the mempool guarantees.
 *   To make this work, callers must never allocate more than 1 bio at a time
 *   from this pool. Callers that need to allocate more than 1 bio must always
 *   submit the previously allocated bio for IO before attempting to allocate
 *   a new one. Failure to do so can cause deadlocks under memory pressure.
 *
 *   Note that when running under generic_make_request() (i.e. any block
 *   driver), bios are not submitted until after you return - see the code in
 *   generic_make_request() that converts recursion into iteration, to prevent
 *   stack overflows.
 *
 *   This would normally mean allocating multiple bios under
 *   generic_make_request() would be susceptible to deadlocks, but we have
 *   deadlock avoidance code that resubmits any blocked bios from a rescuer
 *   thread.
 *
 *   However, we do not guarantee forward progress for allocations from other
 *   mempools. Doing multiple allocations from the same mempool under
 *   generic_make_request() should be avoided - instead, use bio_set&apos;s front_pad
 *   for per bio allocations.
 *
 *   RETURNS:
 *   Pointer to new bio on success, NULL on failure.
 */</doc>
<use f='linux-5.3.1/block/bounce.c' l='246' u='c' c='bounce_clone_bio'/>
<use f='linux-5.3.1/drivers/md/dm-io.c' l='348' u='c' c='do_region'/>
<use f='linux-5.3.1/drivers/md/dm.c' l='571' u='c' c='alloc_io'/>
<use f='linux-5.3.1/drivers/md/dm.c' l='606' u='c' c='alloc_tio'/>
<use f='linux-5.3.1/drivers/md/md.c' l='259' u='c' c='bio_alloc_mddev'/>
<use f='linux-5.3.1/drivers/md/md.c' l='268' u='c' c='md_bio_alloc_sync'/>
<use f='linux-5.3.1/fs/block_dev.c' l='356' u='c' c='__blkdev_direct_IO'/>
