<dec f='linux-5.3.1/include/linux/kthread.h' l='188' type='bool kthread_mod_delayed_work(struct kthread_worker * worker, struct kthread_delayed_work * dwork, unsigned long delay)'/>
<use f='linux-5.3.1/drivers/ptp/ptp_clock.c' l='370' u='c' c='ptp_schedule_worker'/>
<def f='linux-5.3.1/kernel/kthread.c' l='1050' ll='1077' type='bool kthread_mod_delayed_work(struct kthread_worker * worker, struct kthread_delayed_work * dwork, unsigned long delay)'/>
<dec f='linux-5.3.1/kernel/kthread.c' l='1078' type='bool kthread_mod_delayed_work(struct kthread_worker * , struct kthread_delayed_work * , unsigned long )'/>
<use f='linux-5.3.1/kernel/kthread.c' l='1078' c='kthread_mod_delayed_work'/>
<use f='linux-5.3.1/kernel/kthread.c' l='1078' u='a'/>
<doc f='linux-5.3.1/kernel/kthread.c' l='1027'>/**
 * kthread_mod_delayed_work - modify delay of or queue a kthread delayed work
 * @worker: kthread worker to use
 * @dwork: kthread delayed work to queue
 * @delay: number of jiffies to wait before queuing
 *
 * If @dwork is idle, equivalent to kthread_queue_delayed_work(). Otherwise,
 * modify @dwork&apos;s timer so that it expires after @delay. If @delay is zero,
 * @work is guaranteed to be queued immediately.
 *
 * Return: %true if @dwork was pending and its timer was modified,
 * %false otherwise.
 *
 * A special case is when the work is being canceled in parallel.
 * It might be caused either by the real kthread_cancel_delayed_work_sync()
 * or yet another kthread_mod_delayed_work() call. We let the other command
 * win and return %false here. The caller is supposed to synchronize these
 * operations a reasonable way.
 *
 * This function is safe to call from any context including IRQ handler.
 * See __kthread_cancel_work() and kthread_delayed_work_timer_fn()
 * for details.
 */</doc>
