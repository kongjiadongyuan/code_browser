<dec f='linux-5.3.1/include/linux/pm_runtime.h' l='35' type='int pm_runtime_force_suspend(struct device * dev)'/>
<def f='linux-5.3.1/drivers/base/power/runtime.c' l='1735' ll='1766' type='int pm_runtime_force_suspend(struct device * dev)'/>
<dec f='linux-5.3.1/drivers/base/power/runtime.c' l='1767' type='int pm_runtime_force_suspend(struct device * )'/>
<use f='linux-5.3.1/drivers/base/power/runtime.c' l='1767' c='pm_runtime_force_suspend'/>
<use f='linux-5.3.1/drivers/base/power/runtime.c' l='1767' u='a'/>
<doc f='linux-5.3.1/drivers/base/power/runtime.c' l='1718'>/**
 * pm_runtime_force_suspend - Force a device into suspend state if needed.
 * @dev: Device to suspend.
 *
 * Disable runtime PM so we safely can check the device&apos;s runtime PM status and
 * if it is active, invoke its -&gt;runtime_suspend callback to suspend it and
 * change its runtime PM status field to RPM_SUSPENDED.  Also, if the device&apos;s
 * usage and children counters don&apos;t indicate that the device was in use before
 * the system-wide transition under way, decrement its parent&apos;s children counter
 * (if there is a parent).  Keep runtime PM disabled to preserve the state
 * unless we encounter errors.
 *
 * Typically this function may be invoked from a system suspend callback to make
 * sure the device is put into low power state and it should only be used during
 * system-wide PM transitions to sleep states.  It assumes that the analogous
 * pm_runtime_force_resume() will be used to resume the device.
 */</doc>
<use f='linux-5.3.1/sound/pci/hda/hda_codec.c' l='2963' u='c' c='hda_codec_pm_suspend'/>
<use f='linux-5.3.1/sound/pci/hda/hda_codec.c' l='2975' u='c' c='hda_codec_pm_freeze'/>
