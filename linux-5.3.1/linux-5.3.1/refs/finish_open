<dec f='linux-5.3.1/include/linux/fs.h' l='2517' type='int finish_open(struct file * file, struct dentry * dentry, int (*)(struct inode *, struct file *) open)'/>
<use f='linux-5.3.1/fs/namei.c' l='3496' u='c' c='do_tmpfile'/>
<use f='linux-5.3.1/fs/nfs/dir.c' l='1484' u='c' c='nfs_finish_open'/>
<def f='linux-5.3.1/fs/open.c' l='860' ll='867' type='int finish_open(struct file * file, struct dentry * dentry, int (*)(struct inode *, struct file *) open)'/>
<dec f='linux-5.3.1/fs/open.c' l='868' type='int finish_open(struct file * , struct dentry * , int (*)(struct inode *, struct file *) )'/>
<use f='linux-5.3.1/fs/open.c' l='868' c='finish_open'/>
<use f='linux-5.3.1/fs/open.c' l='868' u='a'/>
<doc f='linux-5.3.1/fs/open.c' l='839'>/**
 * finish_open - finish opening a file
 * @file: file pointer
 * @dentry: pointer to dentry
 * @open: open callback
 * @opened: state of open
 *
 * This can be used to finish opening a file passed to i_op-&gt;atomic_open().
 *
 * If the open callback is set to NULL, then the standard f_op-&gt;open()
 * filesystem callback is substituted.
 *
 * NB: the dentry reference is _not_ consumed.  If, for example, the dentry is
 * the return value of d_splice_alias(), then the caller needs to perform dput()
 * on it after finish_open().
 *
 * On successful return @file is a fully instantiated open file.  After this, if
 * an error occurs in -&gt;atomic_open(), it needs to clean up with fput().
 *
 * Returns zero on success or -errno if the open failed.
 */</doc>
