<dec f='linux-5.3.1/include/linux/pm_runtime.h' l='44' type='int pm_runtime_barrier(struct device * dev)'/>
<use f='linux-5.3.1/drivers/base/core.c' l='3184' u='c' c='device_shutdown'/>
<use f='linux-5.3.1/drivers/base/dd.c' l='705' u='c' c='driver_probe_device'/>
<use f='linux-5.3.1/drivers/base/power/main.c' l='1715' u='c' c='__device_suspend'/>
<def f='linux-5.3.1/drivers/base/power/runtime.c' l='1292' ll='1311' type='int pm_runtime_barrier(struct device * dev)'/>
<dec f='linux-5.3.1/drivers/base/power/runtime.c' l='1312' type='int pm_runtime_barrier(struct device * )'/>
<use f='linux-5.3.1/drivers/base/power/runtime.c' l='1312' c='pm_runtime_barrier'/>
<use f='linux-5.3.1/drivers/base/power/runtime.c' l='1312' u='a'/>
<doc f='linux-5.3.1/drivers/base/power/runtime.c' l='1278'>/**
 * pm_runtime_barrier - Flush pending requests and wait for completions.
 * @dev: Device to handle.
 *
 * Prevent the device from being suspended by incrementing its usage counter and
 * if there&apos;s a pending resume request for the device, wake the device up.
 * Next, make sure that all pending requests for the device have been flushed
 * from pm_wq and wait for all runtime PM operations involving the device in
 * progress to complete.
 *
 * Return value:
 * 1, if there was a resume request pending and the device had to be woken up,
 * 0, otherwise
 */</doc>
<use f='linux-5.3.1/drivers/pci/pci.c' l='2577' u='c' c='pci_config_pm_runtime_get'/>
<use f='linux-5.3.1/drivers/usb/core/hub.c' l='1329' u='c' c='hub_pm_barrier_for_all_ports'/>
<use f='linux-5.3.1/drivers/usb/core/hub.c' l='2188' u='c' c='usb_disconnect'/>
<use f='linux-5.3.1/drivers/usb/core/hub.c' l='5437' u='c' c='hub_event'/>
