<dec f='linux-5.3.1/include/linux/mutex.h' l='196' type='int mutex_trylock(struct mutex * lock)'/>
<use f='linux-5.3.1/include/linux/mutex.h' l='229' u='c' c='mutex_trylock_recursive'/>
<use f='linux-5.3.1/include/linux/device.h' l='1230' u='c' c='device_trylock'/>
<doc f='linux-5.3.1/include/linux/mutex.h' l='190'>/*
 * NOTE: mutex_trylock() follows the spin_trylock() convention,
 *       not the down_trylock() convention!
 *
 * Returns 1 if the mutex has been acquired successfully, and 0 on contention.
 */</doc>
<use f='linux-5.3.1/drivers/base/core.c' l='857' u='c' c='lock_device_hotplug_sysfs'/>
<use f='linux-5.3.1/drivers/clk/clk.c' l='125' u='c' c='clk_prepare_lock'/>
<use f='linux-5.3.1/include/linux/ww_mutex.h' l='345' u='c' c='ww_mutex_trylock'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_dp_helper.c' l='1021' u='c' c='trylock_bus'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_probe_helper.c' l='595' u='c' c='output_poll_execute'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_gmbus.c' l='817' u='c' c='gmbus_trylock_bus'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_pm.c' l='75' u='c' c='retire_work_handler'/>
<use f='linux-5.3.1/drivers/md/md.h' l='526' u='c' c='mddev_trylock'/>
<use f='linux-5.3.1/drivers/power/supply/power_supply_core.c' l='144' u='c' c='power_supply_deferred_register_work'/>
<use f='linux-5.3.1/drivers/tty/n_tty.c' l='2153' u='c' c='n_tty_read'/>
<use f='linux-5.3.1/drivers/tty/tty_io.c' l='887' u='c' c='tty_write_lock'/>
<use f='linux-5.3.1/fs/aio.c' l='406' u='c' c='aio_migratepage'/>
<use f='linux-5.3.1/fs/dcache.c' l='2958' u='c' c='__d_unalias'/>
<use f='linux-5.3.1/kernel/kexec.c' l='246' u='c' c='__do_sys_kexec_load'/>
<use f='linux-5.3.1/kernel/kexec.c' l='300' u='c' c='__do_compat_sys_kexec_load'/>
<use f='linux-5.3.1/kernel/kexec_core.c' l='946' u='c' c='__crash_kexec'/>
<use f='linux-5.3.1/kernel/kexec_core.c' l='1121' u='c' c='kernel_kexec'/>
<def f='linux-5.3.1/kernel/locking/mutex.c' l='1384' ll='1397' type='int mutex_trylock(struct mutex * lock)'/>
<dec f='linux-5.3.1/kernel/locking/mutex.c' l='1398' type='int mutex_trylock(struct mutex * )'/>
<use f='linux-5.3.1/kernel/locking/mutex.c' l='1398' c='mutex_trylock'/>
<use f='linux-5.3.1/kernel/locking/mutex.c' l='1398' u='a'/>
<doc f='linux-5.3.1/kernel/locking/mutex.c' l='1370'>/**
 * mutex_trylock - try to acquire the mutex, without waiting
 * @lock: the mutex to be acquired
 *
 * Try to acquire the mutex atomically. Returns 1 if the mutex
 * has been acquired successfully, and 0 on contention.
 *
 * NOTE: this function follows the spin_trylock() convention, so
 * it is negated from the down_trylock() return values! Be careful
 * about this when converting semaphore users to mutexes.
 *
 * This function must not be used in interrupt context. The
 * mutex must be released by the same task that acquired it.
 */</doc>
<use f='linux-5.3.1/kernel/power/suspend.c' l='572' u='c' c='enter_state'/>
<use f='linux-5.3.1/kernel/power/user.c' l='216' u='c' c='snapshot_ioctl'/>
<use f='linux-5.3.1/kernel/rcu/tree_exp.h' l='285' u='c' c='exp_funnel_lock'/>
<use f='linux-5.3.1/kernel/stop_machine.c' l='474' u='c' c='try_stop_cpus'/>
<use f='linux-5.3.1/kernel/stop_machine.c' l='674' u='c' c='stop_machine_from_inactive_cpu'/>
<use f='linux-5.3.1/mm/oom_kill.c' l='1132' u='c' c='pagefault_out_of_memory'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='2898' u='c' c='drain_all_pages'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='3799' u='c' c='__alloc_pages_may_oom'/>
<use f='linux-5.3.1/mm/slab_common.c' l='1431' u='c' c='dump_unreclaimable_slab'/>
<use f='linux-5.3.1/mm/vmalloc.c' l='1301' u='c' c='try_purge_vmap_area_lazy'/>
<use f='linux-5.3.1/net/core/rtnetlink.c' l='118' u='c' c='rtnl_trylock'/>
<use f='linux-5.3.1/sound/core/pcm_native.c' l='1123' u='c' c='snd_pcm_stream_group_ref'/>
