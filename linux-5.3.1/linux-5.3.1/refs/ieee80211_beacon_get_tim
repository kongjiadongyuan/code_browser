<dec f='linux-5.3.1/include/net/mac80211.h' l='4699' type='struct sk_buff * ieee80211_beacon_get_tim(struct ieee80211_hw * hw, struct ieee80211_vif * vif, u16 * tim_offset, u16 * tim_length)'/>
<use f='linux-5.3.1/include/net/mac80211.h' l='4715' u='c' c='ieee80211_beacon_get'/>
<doc f='linux-5.3.1/include/net/mac80211.h' l='4677'>/**
 * ieee80211_beacon_get_tim - beacon generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.
 * @tim_offset: pointer to variable that will receive the TIM IE offset.
 *	Set to 0 if invalid (in non-AP modes).
 * @tim_length: pointer to variable that will receive the TIM IE length,
 *	(including the ID and length bytes!).
 *	Set to 0 if invalid (in non-AP modes).
 *
 * If the driver implements beaconing modes, it must use this function to
 * obtain the beacon frame.
 *
 * If the beacon frames are generated by the host system (i.e., not in
 * hardware/firmware), the driver uses this function to get each beacon
 * frame from mac80211 -- it is responsible for calling this function exactly
 * once before the beacon is needed (e.g. based on hardware interrupt).
 *
 * The driver is responsible for freeing the returned skb.
 *
 * Return: The beacon template. %NULL on error.
 */</doc>
<def f='linux-5.3.1/net/mac80211/tx.c' l='4617' ll='4653' type='struct sk_buff * ieee80211_beacon_get_tim(struct ieee80211_hw * hw, struct ieee80211_vif * vif, u16 * tim_offset, u16 * tim_length)'/>
<dec f='linux-5.3.1/net/mac80211/tx.c' l='4654' type='struct sk_buff * ieee80211_beacon_get_tim(struct ieee80211_hw * , struct ieee80211_vif * , u16 * , u16 * )'/>
<use f='linux-5.3.1/net/mac80211/tx.c' l='4654' c='ieee80211_beacon_get_tim'/>
<use f='linux-5.3.1/net/mac80211/tx.c' l='4654' u='a'/>
