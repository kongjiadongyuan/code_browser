<dec f='linux-5.3.1/include/linux/blk-pm.h' l='18' type='void blk_set_runtime_active(struct request_queue * q)'/>
<def f='linux-5.3.1/block/blk-pm.c' l='208' ll='215' type='void blk_set_runtime_active(struct request_queue * q)'/>
<dec f='linux-5.3.1/block/blk-pm.c' l='216' type='void blk_set_runtime_active(struct request_queue * )'/>
<use f='linux-5.3.1/block/blk-pm.c' l='216' c='blk_set_runtime_active'/>
<use f='linux-5.3.1/block/blk-pm.c' l='216' u='a'/>
<doc f='linux-5.3.1/block/blk-pm.c' l='194'>/**
 * blk_set_runtime_active - Force runtime status of the queue to be active
 * @q: the queue of the device
 *
 * If the device is left runtime suspended during system suspend the resume
 * hook typically resumes the device and corrects runtime status
 * accordingly. However, that does not affect the queue runtime PM status
 * which is still &quot;suspended&quot;. This prevents processing requests from the
 * queue.
 *
 * This function can be used in driver&apos;s resume hook to correct queue
 * runtime PM status and re-enable peeking requests from the queue. It
 * should be called before first request is added to the queue.
 */</doc>
<use f='linux-5.3.1/drivers/scsi/scsi_pm.c' l='98' u='c' c='scsi_dev_type_resume'/>
