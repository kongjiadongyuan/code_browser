<dec f='linux-5.3.1/include/linux/hardirq.h' l='13' type='bool synchronize_hardirq(unsigned int irq)'/>
<use f='linux-5.3.1/drivers/acpi/osl.c' l='1119' u='c' c='acpi_os_wait_events_complete'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/gt/intel_engine_cs.c' l='1163' u='c' c='intel_engine_is_idle'/>
<def f='linux-5.3.1/kernel/irq/manage.c' l='98' ll='108' type='bool synchronize_hardirq(unsigned int irq)'/>
<dec f='linux-5.3.1/kernel/irq/manage.c' l='109' type='bool synchronize_hardirq(unsigned int )'/>
<use f='linux-5.3.1/kernel/irq/manage.c' l='109' c='synchronize_hardirq'/>
<use f='linux-5.3.1/kernel/irq/manage.c' l='109' u='a'/>
<use f='linux-5.3.1/kernel/irq/manage.c' l='579' u='c' c='disable_hardirq'/>
<doc f='linux-5.3.1/kernel/irq/manage.c' l='76'>/**
 *	synchronize_hardirq - wait for pending hard IRQ handlers (on other CPUs)
 *	@irq: interrupt number to wait for
 *
 *	This function waits for any pending hard IRQ handlers for this
 *	interrupt to complete before returning. If you use this
 *	function while holding a resource the IRQ handler may need you
 *	will deadlock. It does not take associated threaded handlers
 *	into account.
 *
 *	Do not use this for shutdown scenarios where you must be sure
 *	that all parts (hardirq and threaded handler) have completed.
 *
 *	Returns: false if a threaded handler is active.
 *
 *	This function may be called - with care - from IRQ context.
 *
 *	It does not check whether there is an interrupt in flight at the
 *	hardware level, but not serviced yet, as this might deadlock when
 *	called with interrupts disabled and the target CPU of the interrupt
 *	is the current CPU.
 */</doc>
