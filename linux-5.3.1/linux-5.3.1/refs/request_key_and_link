<dec f='linux-5.3.1/security/keys/internal.h' l='153' type='struct key * request_key_and_link(struct key_type * type, const char * description, struct key_tag * domain_tag, const void * callout_info, size_t callout_len, void * aux, struct key * dest_keyring, unsigned long flags)'/>
<use f='linux-5.3.1/security/keys/keyctl.c' l='223' u='c' c='__do_sys_request_key'/>
<def f='linux-5.3.1/security/keys/request_key.c' l='558' ll='647' type='struct key * request_key_and_link(struct key_type * type, const char * description, struct key_tag * domain_tag, const void * callout_info, size_t callout_len, void * aux, struct key * dest_keyring, unsigned long flags)'/>
<use f='linux-5.3.1/security/keys/request_key.c' l='701' u='c' c='request_key_tag'/>
<use f='linux-5.3.1/security/keys/request_key.c' l='740' u='c' c='request_key_with_auxdata'/>
<doc f='linux-5.3.1/security/keys/request_key.c' l='529'>/**
 * request_key_and_link - Request a key and cache it in a keyring.
 * @type: The type of key we want.
 * @description: The searchable description of the key.
 * @domain_tag: The domain in which the key operates.
 * @callout_info: The data to pass to the instantiation upcall (or NULL).
 * @callout_len: The length of callout_info.
 * @aux: Auxiliary data for the upcall.
 * @dest_keyring: Where to cache the key.
 * @flags: Flags to key_alloc().
 *
 * A key matching the specified criteria (type, description, domain_tag) is
 * searched for in the process&apos;s keyrings and returned with its usage count
 * incremented if found.  Otherwise, if callout_info is not NULL, a key will be
 * allocated and some service (probably in userspace) will be asked to
 * instantiate it.
 *
 * If successfully found or created, the key will be linked to the destination
 * keyring if one is provided.
 *
 * Returns a pointer to the key if successful; -EACCES, -ENOKEY, -EKEYREVOKED
 * or -EKEYEXPIRED if an inaccessible, negative, revoked or expired key was
 * found; -ENOKEY if no key was found and no @callout_info was given; -EDQUOT
 * if insufficient key quota was available to create a new key; or -ENOMEM if
 * insufficient memory was available.
 *
 * If the returned key was created, then it may still be under construction,
 * and wait_for_key_construction() should be used to wait for that to complete.
 */</doc>
