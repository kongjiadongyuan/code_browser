<dec f='linux-5.3.1/include/linux/skbuff.h' l='1127' type='int skb_to_sgvec_nomark(struct sk_buff * skb, struct scatterlist * sg, int offset, int len)'/>
<def f='linux-5.3.1/net/core/skbuff.c' l='4265' ll='4269' type='int skb_to_sgvec_nomark(struct sk_buff * skb, struct scatterlist * sg, int offset, int len)'/>
<dec f='linux-5.3.1/net/core/skbuff.c' l='4270' type='int skb_to_sgvec_nomark(struct sk_buff * , struct scatterlist * , int , int )'/>
<use f='linux-5.3.1/net/core/skbuff.c' l='4270' c='skb_to_sgvec_nomark'/>
<use f='linux-5.3.1/net/core/skbuff.c' l='4270' u='a'/>
<doc f='linux-5.3.1/net/core/skbuff.c' l='4246'>/* As compared with skb_to_sgvec, skb_to_sgvec_nomark only map skb to given
 * sglist without mark the sg which contain last skb data as the end.
 * So the caller can mannipulate sg list as will when padding new data after
 * the first call without calling sg_unmark_end to expend sg list.
 *
 * Scenario to use skb_to_sgvec_nomark:
 * 1. sg_init_table
 * 2. skb_to_sgvec_nomark(payload1)
 * 3. skb_to_sgvec_nomark(payload2)
 *
 * This is equivalent to:
 * 1. sg_init_table
 * 2. skb_to_sgvec(payload1)
 * 3. sg_unmark_end
 * 4. skb_to_sgvec(payload2)
 *
 * When mapping mutilple payload conditionally, skb_to_sgvec_nomark
 * is more preferable.
 */</doc>
<use f='linux-5.3.1/net/ipv6/ah6.c' l='416' u='c' c='ah6_output'/>
<use f='linux-5.3.1/net/ipv6/ah6.c' l='601' u='c' c='ah6_input'/>
