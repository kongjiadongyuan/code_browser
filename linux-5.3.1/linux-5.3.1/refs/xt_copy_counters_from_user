<dec f='linux-5.3.1/include/linux/netfilter/x_tables.h' l='304' type='void * xt_copy_counters_from_user(const void * user, unsigned int len, struct xt_counters_info * info, bool compat)'/>
<use f='linux-5.3.1/net/ipv4/netfilter/ip_tables.c' l='1167' u='c' c='do_add_counters'/>
<use f='linux-5.3.1/net/ipv6/netfilter/ip6_tables.c' l='1184' u='c' c='do_add_counters'/>
<def f='linux-5.3.1/net/netfilter/x_tables.c' l='1051' ll='1101' type='void * xt_copy_counters_from_user(const void * user, unsigned int len, struct xt_counters_info * info, bool compat)'/>
<dec f='linux-5.3.1/net/netfilter/x_tables.c' l='1102' type='void * xt_copy_counters_from_user(const void * , unsigned int , struct xt_counters_info * , bool )'/>
<use f='linux-5.3.1/net/netfilter/x_tables.c' l='1102' c='xt_copy_counters_from_user'/>
<use f='linux-5.3.1/net/netfilter/x_tables.c' l='1102' u='a'/>
<doc f='linux-5.3.1/net/netfilter/x_tables.c' l='1030'>/**
 * xt_copy_counters_from_user - copy counters and metadata from userspace
 *
 * @user: src pointer to userspace memory
 * @len: alleged size of userspace memory
 * @info: where to store the xt_counters_info metadata
 * @compat: true if we setsockopt call is done by 32bit task on 64bit kernel
 *
 * Copies counter meta data from @user and stores it in @info.
 *
 * vmallocs memory to hold the counters, then copies the counter data
 * from @user to the new memory and returns a pointer to it.
 *
 * If @compat is true, @info gets converted automatically to the 64bit
 * representation.
 *
 * The metadata associated with the counters is stored in @info.
 *
 * Return: returns pointer that caller has to test via IS_ERR().
 * If IS_ERR is false, caller has to vfree the pointer.
 */</doc>
