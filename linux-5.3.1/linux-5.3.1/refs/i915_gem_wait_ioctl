<dec f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_ioctls.h' l='49' type='int i915_gem_wait_ioctl(struct drm_device * dev, void * data, struct drm_file * file)'/>
<def f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_wait.c' l='233' ll='278' type='int i915_gem_wait_ioctl(struct drm_device * dev, void * data, struct drm_file * file)'/>
<doc f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_wait.c' l='209'>/**
 * i915_gem_wait_ioctl - implements DRM_IOCTL_I915_GEM_WAIT
 * @dev: drm device pointer
 * @data: ioctl data blob
 * @file: drm file pointer
 *
 * Returns 0 if successful, else an error is returned with the remaining time in
 * the timeout parameter.
 *  -ETIME: object is still busy after timeout
 *  -ERESTARTSYS: signal interrupted the wait
 *  -ENONENT: object doesn&apos;t exist
 * Also possible, but rare:
 *  -EAGAIN: incomplete, restart syscall
 *  -ENOMEM: damn
 *  -ENODEV: Internal IRQ fail
 *  -E?: The add request failed
 *
 * The wait ioctl with a timeout of 0 reimplements the busy ioctl. With any
 * non-zero timeout parameter the wait ioctl will wait for the given number of
 * nanoseconds on an object becoming unbusy. Since the wait itself does so
 * without holding struct_mutex the object may become re-busied before this
 * function completes. A similar but shorter * race condition exists in the busy
 * ioctl
 */</doc>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3188'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3188'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3188'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3188'/>
