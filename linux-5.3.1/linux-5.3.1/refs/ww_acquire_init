<def f='linux-5.3.1/include/linux/ww_mutex.h' l='129' ll='152' type='void ww_acquire_init(struct ww_acquire_ctx * ctx, struct ww_class * ww_class)'/>
<doc f='linux-5.3.1/include/linux/ww_mutex.h' l='105'>/**
 * ww_acquire_init - initialize a w/w acquire context
 * @ctx: w/w acquire context to initialize
 * @ww_class: w/w class of the context
 *
 * Initializes an context to acquire multiple mutexes of the given w/w class.
 *
 * Context-based w/w mutex acquiring can be done in any order whatsoever within
 * a given lock class. Deadlocks will be detected and handled with the
 * wait/die logic.
 *
 * Mixing of context-based w/w mutex acquiring and single w/w mutex locking can
 * result in undetected deadlocks and is so forbidden. Mixing different contexts
 * for the same w/w class when acquiring mutexes can also result in undetected
 * deadlocks, and is hence also forbidden. Both types of abuse will be caught by
 * enabling CONFIG_PROVE_LOCKING.
 *
 * Nesting of acquire contexts for _different_ w/w classes is possible, subject
 * to the usual locking rules between different lock classes.
 *
 * An acquire context must be released with ww_acquire_fini by the same task
 * before the memory is freed. It is recommended to allocate the context itself
 * on the stack.
 */</doc>
<use f='linux-5.3.1/drivers/gpu/drm/drm_gem.c' l='1285' u='c' c='drm_gem_lock_reservations'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_modeset_lock.c' l='202' u='c' c='drm_modeset_acquire_init'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c' l='1863' u='c' c='eb_move_to_gpu'/>
