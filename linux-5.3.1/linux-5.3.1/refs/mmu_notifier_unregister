<dec f='linux-5.3.1/include/linux/mmu_notifier.h' l='241' type='void mmu_notifier_unregister(struct mmu_notifier * mn, struct mm_struct * mm)'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_userptr.c' l='292' u='c' c='i915_mmu_notifier_free'/>
<def f='linux-5.3.1/mm/mmu_notifier.c' l='337' ll='375' type='void mmu_notifier_unregister(struct mmu_notifier * mn, struct mm_struct * mm)'/>
<dec f='linux-5.3.1/mm/mmu_notifier.c' l='376' type='void mmu_notifier_unregister(struct mmu_notifier * , struct mm_struct * )'/>
<use f='linux-5.3.1/mm/mmu_notifier.c' l='376' c='mmu_notifier_unregister'/>
<use f='linux-5.3.1/mm/mmu_notifier.c' l='376' u='a'/>
<doc f='linux-5.3.1/mm/mmu_notifier.c' l='327'>/*
 * This releases the mm_count pin automatically and frees the mm
 * structure if it was the last user of it. It serializes against
 * running mmu notifiers with SRCU and against mmu_notifier_unregister
 * with the unregister lock + SRCU. All sptes must be dropped before
 * calling mmu_notifier_unregister. -&gt;release or any other notifier
 * method may be invoked concurrently with mmu_notifier_unregister,
 * and only after mmu_notifier_unregister returned we&apos;re guaranteed
 * that -&gt;release or any other method can&apos;t run anymore.
 */</doc>
