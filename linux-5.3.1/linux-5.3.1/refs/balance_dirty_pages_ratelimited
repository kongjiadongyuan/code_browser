<dec f='linux-5.3.1/include/linux/writeback.h' l='386' type='void balance_dirty_pages_ratelimited(struct address_space * mapping)'/>
<use f='linux-5.3.1/fs/buffer.c' l='2365' u='c' c='cont_expand_zero'/>
<use f='linux-5.3.1/fs/iomap/buffered-io.c' l='812' u='c' c='iomap_write_actor'/>
<use f='linux-5.3.1/fs/iomap/buffered-io.c' l='894' u='c' c='iomap_dirty_actor'/>
<use f='linux-5.3.1/mm/filemap.c' l='3363' u='c' c='generic_perform_write'/>
<use f='linux-5.3.1/mm/memory.c' l='2244' u='c' c='fault_dirty_shared_page'/>
<def f='linux-5.3.1/mm/page-writeback.c' l='1862' ll='1914' type='void balance_dirty_pages_ratelimited(struct address_space * mapping)'/>
<dec f='linux-5.3.1/mm/page-writeback.c' l='1915' type='void balance_dirty_pages_ratelimited(struct address_space * )'/>
<use f='linux-5.3.1/mm/page-writeback.c' l='1915' c='balance_dirty_pages_ratelimited'/>
<use f='linux-5.3.1/mm/page-writeback.c' l='1915' u='a'/>
<doc f='linux-5.3.1/mm/page-writeback.c' l='1849'>/**
 * balance_dirty_pages_ratelimited - balance dirty memory state
 * @mapping: address_space which was dirtied
 *
 * Processes which are dirtying memory should call in here once for each page
 * which was newly dirtied.  The function will periodically check the system&apos;s
 * dirty state and will initiate writeback if needed.
 *
 * On really big machines, get_writeback_state is expensive, so try to avoid
 * calling it too often (ratelimiting).  But once we&apos;re over the dirty memory
 * limit we decrease the ratelimiting by a lot, to prevent individual processes
 * from overshooting the limit by (ratelimit_pages) each.
 */</doc>
