<dec f='linux-5.3.1/include/linux/timekeeping.h' l='179' type='u64 ktime_get_boot_fast_ns()'/>
<def f='linux-5.3.1/kernel/time/timekeeping.c' l='505' ll='510' type='u64 ktime_get_boot_fast_ns()'/>
<dec f='linux-5.3.1/kernel/time/timekeeping.c' l='511' type='u64 ktime_get_boot_fast_ns()'/>
<use f='linux-5.3.1/kernel/time/timekeeping.c' l='511' c='ktime_get_boot_fast_ns'/>
<use f='linux-5.3.1/kernel/time/timekeeping.c' l='511' u='a'/>
<doc f='linux-5.3.1/kernel/time/timekeeping.c' l='484'>/**
 * ktime_get_boot_fast_ns - NMI safe and fast access to boot clock.
 *
 * To keep it NMI safe since we&apos;re accessing from tracing, we&apos;re not using a
 * separate timekeeper with updates to monotonic clock and boot offset
 * protected with seqlocks. This has the following minor side effects:
 *
 * (1) Its possible that a timestamp be taken after the boot offset is updated
 * but before the timekeeper is updated. If this happens, the new boot offset
 * is added to the old timekeeping making the clock appear to update slightly
 * earlier:
 *    CPU 0                                        CPU 1
 *    timekeeping_inject_sleeptime64()
 *    __timekeeping_inject_sleeptime(tk, delta);
 *                                                 timestamp();
 *    timekeeping_update(tk, TK_CLEAR_NTP...);
 *
 * (2) On 32-bit systems, the 64-bit boot offset (tk-&gt;offs_boot) may be
 * partially updated.  Since the tk-&gt;offs_boot update is a rare event, this
 * should be a rare occurrence which postprocessing should be able to handle.
 */</doc>
<use f='linux-5.3.1/kernel/trace/trace.c' l='1340'/>
<use f='linux-5.3.1/kernel/trace/trace.c' l='1340'/>
<use f='linux-5.3.1/kernel/trace/trace.c' l='1340'/>
<use f='linux-5.3.1/kernel/trace/trace.c' l='1340'/>
