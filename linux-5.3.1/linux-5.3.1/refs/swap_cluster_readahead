<dec f='linux-5.3.1/include/linux/swap.h' l='424' type='struct page * swap_cluster_readahead(swp_entry_t entry, gfp_t flag, struct vm_fault * vmf)'/>
<use f='linux-5.3.1/mm/shmem.c' l='1445' u='c' c='shmem_swapin'/>
<def f='linux-5.3.1/mm/swap_state.c' l='539' ll='595' type='struct page * swap_cluster_readahead(swp_entry_t entry, gfp_t gfp_mask, struct vm_fault * vmf)'/>
<use f='linux-5.3.1/mm/swap_state.c' l='786' u='c' c='swapin_readahead'/>
<doc f='linux-5.3.1/mm/swap_state.c' l='521'>/**
 * swap_cluster_readahead - swap in pages in hope we need them soon
 * @entry: swap entry of this memory
 * @gfp_mask: memory allocation flags
 * @vmf: fault information
 *
 * Returns the struct page for entry and addr, after queueing swapin.
 *
 * Primitive swap readahead code. We simply read an aligned block of
 * (1 &lt;&lt; page_cluster) entries in the swap area. This method is chosen
 * because it doesn&apos;t cost us any seek time.  We also make sure to queue
 * the &apos;original&apos; request together with the readahead ones...
 *
 * This has been extended to use the NUMA policies from the mm triggering
 * the readahead.
 *
 * Caller must hold read mmap_sem if vmf-&gt;vma is not NULL.
 */</doc>
