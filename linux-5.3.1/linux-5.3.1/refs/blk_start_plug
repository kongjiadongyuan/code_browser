<dec f='linux-5.3.1/include/linux/blkdev.h' l='1154' type='void blk_start_plug(struct blk_plug * )'/>
<def f='linux-5.3.1/block/blk-core.c' l='1658' ll='1678' type='void blk_start_plug(struct blk_plug * plug)'/>
<dec f='linux-5.3.1/block/blk-core.c' l='1679' type='void blk_start_plug(struct blk_plug * )'/>
<use f='linux-5.3.1/block/blk-core.c' l='1679' c='blk_start_plug'/>
<use f='linux-5.3.1/block/blk-core.c' l='1679' u='a'/>
<doc f='linux-5.3.1/block/blk-core.c' l='1635'>/**
 * blk_start_plug - initialize blk_plug and track it inside the task_struct
 * @plug:	The &amp;struct blk_plug that needs to be initialized
 *
 * Description:
 *   blk_start_plug() indicates to the block layer an intent by the caller
 *   to submit multiple I/O requests in a batch.  The block layer may use
 *   this hint to defer submitting I/Os from the caller until blk_finish_plug()
 *   is called.  However, the block layer may choose to submit requests
 *   before a call to blk_finish_plug() if the number of queued I/Os
 *   exceeds %BLK_MAX_REQUEST_COUNT, or if the size of the I/O is larger than
 *   %BLK_PLUG_FLUSH_SIZE.  The queued I/Os may also be submitted early if
 *   the task schedules (see below).
 *
 *   Tracking blk_plug inside the task_struct will help with auto-flushing the
 *   pending I/O should the task end up blocking between blk_start_plug() and
 *   blk_finish_plug(). This is important from a performance perspective, but
 *   also ensures that we don&apos;t deadlock. For instance, if the task is blocking
 *   for a memory allocation, memory reclaim could end up wanting to free a
 *   page belonging to that request that is currently residing in our private
 *   plug. By flushing the pending I/O when the process goes to sleep, we avoid
 *   this kind of deadlock.
 */</doc>
<use f='linux-5.3.1/block/blk-lib.c' l='104' u='c' c='blkdev_issue_discard'/>
<use f='linux-5.3.1/block/blk-lib.c' l='200' u='c' c='blkdev_issue_write_same'/>
<use f='linux-5.3.1/block/blk-lib.c' l='373' u='c' c='blkdev_issue_zeroout'/>
<use f='linux-5.3.1/drivers/md/dm-kcopyd.c' l='664' u='c' c='do_work'/>
<use f='linux-5.3.1/drivers/md/md.c' l='8507' u='c' c='md_do_sync'/>
<use f='linux-5.3.1/fs/aio.c' l='1912' u='c' c='__do_sys_io_submit'/>
<use f='linux-5.3.1/fs/aio.c' l='1954' u='c' c='__do_compat_sys_io_submit'/>
<use f='linux-5.3.1/fs/block_dev.c' l='376' u='c' c='__blkdev_direct_IO'/>
<use f='linux-5.3.1/fs/block_dev.c' l='1986' u='c' c='blkdev_write_iter'/>
<use f='linux-5.3.1/fs/buffer.c' l='682' u='c' c='fsync_buffers_list'/>
<use f='linux-5.3.1/fs/direct-io.c' l='1325' u='c' c='do_blockdev_direct_IO'/>
<use f='linux-5.3.1/fs/ext4/inode.c' l='2836' u='c' c='ext4_writepages'/>
<use f='linux-5.3.1/fs/fs-writeback.c' l='1723' u='c' c='writeback_inodes_wb'/>
<use f='linux-5.3.1/fs/fs-writeback.c' l='1762' u='c' c='wb_writeback'/>
<use f='linux-5.3.1/fs/io_uring.c' l='2200' u='c' c='io_submit_state_start'/>
<use f='linux-5.3.1/fs/iomap/direct-io.c' l='490' u='c' c='iomap_dio_rw'/>
<use f='linux-5.3.1/fs/jbd2/checkpoint.c' l='183' u='c' c='__flush_batch'/>
<use f='linux-5.3.1/fs/jbd2/commit.c' l='545' u='c' c='jbd2_journal_commit_transaction'/>
<use f='linux-5.3.1/fs/mpage.c' l='718' u='c' c='mpage_writepages'/>
<use f='linux-5.3.1/mm/madvise.c' l='854' u='c' c='__do_sys_madvise'/>
<use f='linux-5.3.1/mm/page-writeback.c' l='2326' u='c' c='generic_writepages'/>
<use f='linux-5.3.1/mm/readahead.c' l='123' u='c' c='read_pages'/>
<use f='linux-5.3.1/mm/swap_state.c' l='573' u='c' c='swap_cluster_readahead'/>
<use f='linux-5.3.1/mm/swap_state.c' l='738' u='c' c='swap_vma_readahead'/>
<use f='linux-5.3.1/mm/vmscan.c' l='2485' u='c' c='shrink_node_memcg'/>
