<dec f='linux-5.3.1/include/linux/uio.h' l='270' type='ssize_t import_iovec(int type, const struct iovec * uvector, unsigned int nr_segs, unsigned int fast_segs, struct iovec ** iov, struct iov_iter * i)'/>
<use f='linux-5.3.1/block/scsi_ioctl.c' l='330' u='c' c='sg_io'/>
<use f='linux-5.3.1/drivers/scsi/sg.c' l='1800' u='c' c='sg_start_req'/>
<use f='linux-5.3.1/fs/aio.c' l='1497' u='c' c='aio_setup_rw'/>
<use f='linux-5.3.1/fs/io_uring.c' l='1187' u='c' c='io_import_iovec'/>
<use f='linux-5.3.1/fs/read_write.c' l='995' u='c' c='vfs_readv'/>
<use f='linux-5.3.1/fs/read_write.c' l='1012' u='c' c='vfs_writev'/>
<use f='linux-5.3.1/fs/splice.c' l='1368' u='c' c='__do_sys_vmsplice'/>
<def f='linux-5.3.1/lib/iov_iter.c' l='1639' ll='1656' type='ssize_t import_iovec(int type, const struct iovec * uvector, unsigned int nr_segs, unsigned int fast_segs, struct iovec ** iov, struct iov_iter * i)'/>
<dec f='linux-5.3.1/lib/iov_iter.c' l='1657' type='ssize_t import_iovec(int , const struct iovec * , unsigned int , unsigned int , struct iovec ** , struct iov_iter * )'/>
<use f='linux-5.3.1/lib/iov_iter.c' l='1657' c='import_iovec'/>
<use f='linux-5.3.1/lib/iov_iter.c' l='1657' u='a'/>
<doc f='linux-5.3.1/lib/iov_iter.c' l='1617'>/**
 * import_iovec() - Copy an array of &amp;struct iovec from userspace
 *     into the kernel, check that it is valid, and initialize a new
 *     &amp;struct iov_iter iterator to access it.
 *
 * @type: One of %READ or %WRITE.
 * @uvector: Pointer to the userspace array.
 * @nr_segs: Number of elements in userspace array.
 * @fast_segs: Number of elements in @iov.
 * @iov: (input and output parameter) Pointer to pointer to (usually small
 *     on-stack) kernel array.
 * @i: Pointer to iterator that will be initialized on success.
 *
 * If the array pointed to by *@iov is large enough to hold all @nr_segs,
 * then this function places %NULL in *@iov on return. Otherwise, a new
 * array will be allocated and the result placed in *@iov. This means that
 * the caller may call kfree() on *@iov regardless of whether the small
 * on-stack array was used or not (and regardless of whether this function
 * returns an error or not).
 *
 * Return: Negative error code on error, bytes imported on success
 */</doc>
<use f='linux-5.3.1/mm/process_vm_access.c' l='273' u='c' c='process_vm_rw'/>
<use f='linux-5.3.1/net/socket.c' l='2229' u='c' c='copy_msghdr_from_user'/>
<use f='linux-5.3.1/security/keys/keyctl.c' l='1218' u='c' c='keyctl_instantiate_key_iov'/>
