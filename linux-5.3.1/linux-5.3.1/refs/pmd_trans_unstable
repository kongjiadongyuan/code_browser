<def f='linux-5.3.1/include/asm-generic/pgtable.h' l='1009' ll='1016' type='int pmd_trans_unstable(pmd_t * pmd)'/>
<doc f='linux-5.3.1/include/asm-generic/pgtable.h' l='996'>/*
 * This is a noop if Transparent Hugepage Support is not built into
 * the kernel. Otherwise it is equivalent to
 * pmd_none_or_trans_huge_or_clear_bad(), and shall only be called in
 * places that already verified the pmd is not none and they want to
 * walk ptes while holding the mmap sem in read mode (write mode don&apos;t
 * need this). If THP is not enabled, the pmd can&apos;t go away under the
 * code even if MADV_DONTNEED runs, but if THP is enabled we need to
 * run a pmd_trans_unstable before walking the ptes after
 * split_huge_page_pmd returns (because it may have run when the pmd
 * become null, but then a page fault can map in a THP and not a
 * regular page).
 */</doc>
<use f='linux-5.3.1/fs/proc/task_mmu.c' l='614' u='c' c='smaps_pte_range'/>
<use f='linux-5.3.1/fs/proc/task_mmu.c' l='1070' u='c' c='clear_refs_pte_range'/>
<use f='linux-5.3.1/mm/gup.c' l='409' u='c' c='follow_pmd_mask'/>
<use f='linux-5.3.1/mm/madvise.c' l='328' u='c' c='madvise_free_pte_range'/>
<use f='linux-5.3.1/mm/memory.c' l='2967' u='c' c='do_anonymous_page'/>
<use f='linux-5.3.1/mm/memory.c' l='3112' u='c' c='pmd_devmap_trans_unstable'/>
<use f='linux-5.3.1/mm/mempolicy.c' l='510' u='c' c='queue_pages_pte_range'/>
<use f='linux-5.3.1/mm/mincore.c' l='138' u='c' c='mincore_pte_range'/>
<use f='linux-5.3.1/mm/mprotect.c' l='53' u='c' c='change_pte_range'/>
<use f='linux-5.3.1/mm/mremap.c' l='283' u='c' c='move_page_tables'/>
<use f='linux-5.3.1/mm/pagewalk.c' l='63' u='c' c='walk_pmd_range'/>
