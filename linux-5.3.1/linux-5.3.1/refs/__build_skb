<dec f='linux-5.3.1/include/linux/skbuff.h' l='1040' type='struct sk_buff * __build_skb(void * data, unsigned int frag_size)'/>
<def f='linux-5.3.1/net/core/skbuff.c' l='306' ll='317' type='struct sk_buff * __build_skb(void * data, unsigned int frag_size)'/>
<use f='linux-5.3.1/net/core/skbuff.c' l='326' u='c' c='build_skb'/>
<use f='linux-5.3.1/net/core/skbuff.c' l='463' u='c' c='__netdev_alloc_skb'/>
<use f='linux-5.3.1/net/core/skbuff.c' l='523' u='c' c='__napi_alloc_skb'/>
<doc f='linux-5.3.1/net/core/skbuff.c' l='287'>/**
 * __build_skb - build a network buffer
 * @data: data buffer provided by caller
 * @frag_size: size of data, or 0 if head was kmalloced
 *
 * Allocate a new &amp;sk_buff. Caller provides space holding head and
 * skb_shared_info. @data must have been allocated by kmalloc() only if
 * @frag_size is 0, otherwise data should come from the page allocator
 *  or vmalloc()
 * The return is the new skb buffer.
 * On a failure the return is %NULL, and @data is not freed.
 * Notes :
 *  Before IO, driver allocates only data buffer where NIC put incoming frame
 *  Driver should add room at head (NET_SKB_PAD) and
 *  MUST add room at tail (SKB_DATA_ALIGN(skb_shared_info))
 *  After IO, driver calls build_skb(), to allocate sk_buff and populate it
 *  before giving packet to stack.
 *  RX rings only contains data buffers, not full skbs.
 */</doc>
<use f='linux-5.3.1/net/netlink/af_netlink.c' l='1183' u='c' c='netlink_alloc_large_skb'/>
