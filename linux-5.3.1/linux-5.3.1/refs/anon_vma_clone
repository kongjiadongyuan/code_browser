<dec f='linux-5.3.1/include/linux/rmap.h' l='145' type='int anon_vma_clone(struct vm_area_struct * , struct vm_area_struct * )'/>
<use f='linux-5.3.1/mm/mmap.c' l='809' u='c' c='__vma_adjust'/>
<use f='linux-5.3.1/mm/mmap.c' l='2678' u='c' c='__split_vma'/>
<use f='linux-5.3.1/mm/mmap.c' l='3258' u='c' c='copy_vma'/>
<def f='linux-5.3.1/mm/rmap.c' l='261' ll='308' type='int anon_vma_clone(struct vm_area_struct * dst, struct vm_area_struct * src)'/>
<use f='linux-5.3.1/mm/rmap.c' l='332' u='c' c='anon_vma_fork'/>
<doc f='linux-5.3.1/mm/rmap.c' l='249'>/*
 * Attach the anon_vmas from src to dst.
 * Returns 0 on success, -ENOMEM on failure.
 *
 * If dst-&gt;anon_vma is NULL this function tries to find and reuse existing
 * anon_vma which has no vmas and only one child anon_vma. This prevents
 * degradation of anon_vma hierarchy to endless linear chain in case of
 * constantly forking task. On the other hand, an anon_vma with more than one
 * child isn&apos;t reused even if there was no alive vma, thus rmap walker has a
 * good chance of avoiding scanning the whole hierarchy when it searches where
 * page is mapped.
 */</doc>
