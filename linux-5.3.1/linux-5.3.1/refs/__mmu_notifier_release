<dec f='linux-5.3.1/include/linux/mmu_notifier.h' l='246' type='void __mmu_notifier_release(struct mm_struct * mm)'/>
<use f='linux-5.3.1/include/linux/mmu_notifier.h' l='274' u='c' c='mmu_notifier_release'/>
<def f='linux-5.3.1/mm/mmu_notifier.c' l='48' ll='94' type='void __mmu_notifier_release(struct mm_struct * mm)'/>
<doc f='linux-5.3.1/mm/mmu_notifier.c' l='36'>/*
 * This function can&apos;t run concurrently against mmu_notifier_register
 * because mm-&gt;mm_users &gt; 0 during mmu_notifier_register and exit_mmap
 * runs with mm_users == 0. Other tasks may still invoke mmu notifiers
 * in parallel despite there being no task using this mm any more,
 * through the vmas outside of the exit_mmap context, such as with
 * vmtruncate. This serializes against mmu_notifier_unregister with
 * the mmu_notifier_mm-&gt;lock in addition to SRCU and it serializes
 * against the other mmu notifiers with SRCU. struct mmu_notifier_mm
 * can&apos;t go away from under us as exit_mmap holds an mm_count pin
 * itself.
 */</doc>
