<dec f='linux-5.3.1/include/linux/usb/hcd.h' l='508' type='void usb_hcd_start_port_resume(struct usb_bus * bus, int portnum)'/>
<def f='linux-5.3.1/drivers/usb/core/hcd.c' l='1037' ll='1045' type='void usb_hcd_start_port_resume(struct usb_bus * bus, int portnum)'/>
<dec f='linux-5.3.1/drivers/usb/core/hcd.c' l='1046' type='void usb_hcd_start_port_resume(struct usb_bus * , int )'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='1046' c='usb_hcd_start_port_resume'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='1046' u='a'/>
<doc f='linux-5.3.1/drivers/usb/core/hcd.c' l='1026'>/*
 * usb_hcd_start_port_resume - a root-hub port is sending a resume signal
 * @bus: the bus which the root hub belongs to
 * @portnum: the port which is being resumed
 *
 * HCDs should call this function when they know that a resume signal is
 * being sent to a root-hub port.  The root hub will be prevented from
 * going into autosuspend until usb_hcd_end_port_resume() is called.
 *
 * The bus&apos;s private lock must be held by the caller.
 */</doc>
<use f='linux-5.3.1/drivers/usb/host/ehci-hub.c' l='966' u='c' c='ehci_hub_control'/>
<use f='linux-5.3.1/drivers/usb/host/ehci-hub.c' l='1041' u='c' c='ehci_hub_control'/>
<use f='linux-5.3.1/drivers/usb/host/ehci-hcd.c' l='805' u='c' c='ehci_irq'/>
<use f='linux-5.3.1/drivers/usb/host/uhci-hub.c' l='171' u='c' c='uhci_check_ports'/>
<use f='linux-5.3.1/drivers/usb/host/xhci-hub.c' l='846' u='c' c='xhci_handle_usb2_port_link_resume'/>
<use f='linux-5.3.1/drivers/usb/host/xhci-hub.c' l='1397' u='c' c='xhci_hub_control'/>
<use f='linux-5.3.1/drivers/usb/host/xhci-ring.c' l='1665' u='c' c='handle_port_status'/>
