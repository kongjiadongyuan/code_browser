<dec f='linux-5.3.1/kernel/locking/rtmutex_common.h' l='148' type='bool rt_mutex_cleanup_proxy_lock(struct rt_mutex * lock, struct rt_mutex_waiter * waiter)'/>
<use f='linux-5.3.1/kernel/futex.c' l='2917' u='c' c='futex_lock_pi'/>
<use f='linux-5.3.1/kernel/futex.c' l='3317' u='c' c='futex_wait_requeue_pi'/>
<def f='linux-5.3.1/kernel/locking/rtmutex.c' l='1890' ll='1925' type='bool rt_mutex_cleanup_proxy_lock(struct rt_mutex * lock, struct rt_mutex_waiter * waiter)'/>
<doc f='linux-5.3.1/kernel/locking/rtmutex.c' l='1870'>/**
 * rt_mutex_cleanup_proxy_lock() - Cleanup failed lock acquisition
 * @lock:		the rt_mutex we were woken on
 * @waiter:		the pre-initialized rt_mutex_waiter
 *
 * Attempt to clean up after a failed __rt_mutex_start_proxy_lock() or
 * rt_mutex_wait_proxy_lock().
 *
 * Unless we acquired the lock; we&apos;re still enqueued on the wait-list and can
 * in fact still be granted ownership until we&apos;re removed. Therefore we can
 * find we are in fact the owner and must disregard the
 * rt_mutex_wait_proxy_lock() failure.
 *
 * Returns:
 *  true  - did the cleanup, we done.
 *  false - we acquired the lock after rt_mutex_wait_proxy_lock() returned,
 *          caller should disregards its return value.
 *
 * Special API call for PI-futex support
 */</doc>
