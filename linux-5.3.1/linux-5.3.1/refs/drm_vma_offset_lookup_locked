<dec f='linux-5.3.1/include/drm/drm_vma_manager.h' l='68' type='struct drm_vma_offset_node * drm_vma_offset_lookup_locked(struct drm_vma_offset_manager * mgr, unsigned long start, unsigned long pages)'/>
<use f='linux-5.3.1/include/drm/drm_vma_manager.h' l='101' u='c' c='drm_vma_offset_exact_lookup_locked'/>
<def f='linux-5.3.1/drivers/gpu/drm/drm_vma_manager.c' l='140' ll='175' type='struct drm_vma_offset_node * drm_vma_offset_lookup_locked(struct drm_vma_offset_manager * mgr, unsigned long start, unsigned long pages)'/>
<dec f='linux-5.3.1/drivers/gpu/drm/drm_vma_manager.c' l='176' type='struct drm_vma_offset_node * drm_vma_offset_lookup_locked(struct drm_vma_offset_manager * , unsigned long , unsigned long )'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_vma_manager.c' l='176' c='drm_vma_offset_lookup_locked'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_vma_manager.c' l='176' u='a'/>
<doc f='linux-5.3.1/drivers/gpu/drm/drm_vma_manager.c' l='110'>/**
 * drm_vma_offset_lookup_locked() - Find node in offset space
 * @mgr: Manager object
 * @start: Start address for object (page-based)
 * @pages: Size of object (page-based)
 *
 * Find a node given a start address and object size. This returns the _best_
 * match for the given node. That is, @start may point somewhere into a valid
 * region and the given node will be returned, as long as the node spans the
 * whole requested area (given the size in number of pages as @pages).
 *
 * Note that before lookup the vma offset manager lookup lock must be acquired
 * with drm_vma_offset_lock_lookup(). See there for an example. This can then be
 * used to implement weakly referenced lookups using kref_get_unless_zero().
 *
 * Example:
 *
 * ::
 *
 *     drm_vma_offset_lock_lookup(mgr);
 *     node = drm_vma_offset_lookup_locked(mgr);
 *     if (node)
 *         kref_get_unless_zero(container_of(node, sth, entr));
 *     drm_vma_offset_unlock_lookup(mgr);
 *
 * RETURNS:
 * Returns NULL if no suitable node can be found. Otherwise, the best match
 * is returned. It&apos;s the caller&apos;s responsibility to make sure the node doesn&apos;t
 * get destroyed before the caller can access it.
 */</doc>
