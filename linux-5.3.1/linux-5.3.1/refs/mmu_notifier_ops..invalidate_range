<dec f='linux-5.3.1/include/linux/mmu_notifier.h' l='212' type='void (*)(struct mmu_notifier *, struct mm_struct *, unsigned long, unsigned long)'/>
<offset>448</offset>
<doc f='linux-5.3.1/include/linux/mmu_notifier.h' l='194'>/*
	 * invalidate_range() is either called between
	 * invalidate_range_start() and invalidate_range_end() when the
	 * VM has to free pages that where unmapped, but before the
	 * pages are actually freed, or outside of _start()/_end() when
	 * a (remote) TLB is necessary.
	 *
	 * If invalidate_range() is used to manage a non-CPU TLB with
	 * shared page-tables, it not necessary to implement the
	 * invalidate_range_start()/end() notifiers, as
	 * invalidate_range() alread catches the points in time when an
	 * external TLB range needs to be flushed. For more in depth
	 * discussion on this see Documentation/vm/mmu_notifier.rst
	 *
	 * Note that this function might be called with just a sub-range
	 * of what was passed to invalidate_range_start()/end(), if
	 * called between those functions.
	 */</doc>
<use f='linux-5.3.1/mm/mmu_notifier.c' l='213' u='r' c='__mmu_notifier_invalidate_range_end'/>
<use f='linux-5.3.1/mm/mmu_notifier.c' l='214' u='r' c='__mmu_notifier_invalidate_range_end'/>
<use f='linux-5.3.1/mm/mmu_notifier.c' l='232' u='r' c='__mmu_notifier_invalidate_range'/>
<use f='linux-5.3.1/mm/mmu_notifier.c' l='233' u='r' c='__mmu_notifier_invalidate_range'/>
