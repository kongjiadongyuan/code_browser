<dec f='linux-5.3.1/include/linux/sched.h' l='1685' type='void kick_process(struct task_struct * tsk)'/>
<use f='linux-5.3.1/include/linux/tracehook.h' l='162' u='c' c='set_notify_resume'/>
<def f='linux-5.3.1/kernel/sched/core.c' l='1877' ll='1886' type='void kick_process(struct task_struct * p)'/>
<dec f='linux-5.3.1/kernel/sched/core.c' l='1887' type='void kick_process(struct task_struct * )'/>
<use f='linux-5.3.1/kernel/sched/core.c' l='1887' c='kick_process'/>
<use f='linux-5.3.1/kernel/sched/core.c' l='1887' u='a'/>
<doc f='linux-5.3.1/kernel/sched/core.c' l='1864'>/***
 * kick_process - kick a running thread to enter/exit the kernel
 * @p: the to-be-kicked thread
 *
 * Cause a process which is running on another CPU to enter
 * kernel-mode, without any delay. (to get signals handled.)
 *
 * NOTE: this function doesn&apos;t have to take the runqueue lock,
 * because all it wants to ensure is that the remote task enters
 * the kernel. If the IPI races and the task has been migrated
 * to another CPU then no harm is done and the purpose has been
 * achieved as well.
 */</doc>
<use f='linux-5.3.1/kernel/signal.c' l='765' u='c' c='signal_wake_up_state'/>
