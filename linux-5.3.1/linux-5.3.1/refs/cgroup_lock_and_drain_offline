<dec f='linux-5.3.1/kernel/cgroup/cgroup-internal.h' l='239' type='void cgroup_lock_and_drain_offline(struct cgroup * cgrp)'/>
<use f='linux-5.3.1/kernel/cgroup/cgroup-v1.c' l='1067' u='c' c='cgroup1_reconfigure'/>
<use f='linux-5.3.1/kernel/cgroup/cgroup-v1.c' l='1229' u='c' c='cgroup1_get_tree'/>
<use f='linux-5.3.1/kernel/cgroup/cgroup.c' l='1325' u='c' c='cgroup_destroy_root'/>
<use f='linux-5.3.1/kernel/cgroup/cgroup.c' l='1615' u='c' c='cgroup_kn_lock_live'/>
<def f='linux-5.3.1/kernel/cgroup/cgroup.c' l='2983' ll='3014' type='void cgroup_lock_and_drain_offline(struct cgroup * cgrp)'/>
<doc f='linux-5.3.1/kernel/cgroup/cgroup.c' l='2975'>/**
 * cgroup_lock_and_drain_offline - lock cgroup_mutex and drain offlined csses
 * @cgrp: root of the target subtree
 *
 * Because css offlining is asynchronous, userland may try to re-enable a
 * controller while the previous css is still around.  This function grabs
 * cgroup_mutex and drains the previous css instances of @cgrp&apos;s subtree.
 */</doc>
