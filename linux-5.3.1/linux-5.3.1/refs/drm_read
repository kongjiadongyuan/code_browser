<dec f='linux-5.3.1/include/drm/drm_file.h' l='373' type='ssize_t drm_read(struct file * filp, char * buffer, size_t count, loff_t * offset)'/>
<def f='linux-5.3.1/drivers/gpu/drm/drm_file.c' l='485' ll='553' type='ssize_t drm_read(struct file * filp, char * buffer, size_t count, loff_t * offset)'/>
<dec f='linux-5.3.1/drivers/gpu/drm/drm_file.c' l='554' type='ssize_t drm_read(struct file * , char * , size_t , loff_t * )'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_file.c' l='554' c='drm_read'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_file.c' l='554' u='a'/>
<doc f='linux-5.3.1/drivers/gpu/drm/drm_file.c' l='459'>/**
 * drm_read - read method for DRM file
 * @filp: file pointer
 * @buffer: userspace destination pointer for the read
 * @count: count in bytes to read
 * @offset: offset to read
 *
 * This function must be used by drivers as their &amp;file_operations.read
 * method iff they use DRM events for asynchronous signalling to userspace.
 * Since events are used by the KMS API for vblank and page flip completion this
 * means all modern display drivers must use it.
 *
 * @offset is ignored, DRM events are read like a pipe. Therefore drivers also
 * must set the &amp;file_operation.llseek to no_llseek(). Polling support is
 * provided by drm_poll().
 *
 * This function will only ever read a full event. Therefore userspace must
 * supply a big enough buffer to fit any event to ensure forward progress. Since
 * the maximum event space is currently 4K it&apos;s recommended to just use that for
 * safety.
 *
 * RETURNS:
 *
 * Number of bytes read (always aligned to full events, and can be 0) or a
 * negative error code on failure.
 */</doc>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3131'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3131'/>
