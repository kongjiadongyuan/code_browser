<dec f='linux-5.3.1/include/linux/pm_domain.h' l='364' type='struct device * dev_pm_domain_attach_by_id(struct device * dev, unsigned int index)'/>
<def f='linux-5.3.1/drivers/base/power/common.c' l='143' ll='150' type='struct device * dev_pm_domain_attach_by_id(struct device * dev, unsigned int index)'/>
<dec f='linux-5.3.1/drivers/base/power/common.c' l='151' type='struct device * dev_pm_domain_attach_by_id(struct device * , unsigned int )'/>
<use f='linux-5.3.1/drivers/base/power/common.c' l='151' c='dev_pm_domain_attach_by_id'/>
<use f='linux-5.3.1/drivers/base/power/common.c' l='151' u='a'/>
<doc f='linux-5.3.1/drivers/base/power/common.c' l='117'>/**
 * dev_pm_domain_attach_by_id - Associate a device with one of its PM domains.
 * @dev: The device used to lookup the PM domain.
 * @index: The index of the PM domain.
 *
 * As @dev may only be attached to a single PM domain, the backend PM domain
 * provider creates a virtual device to attach instead. If attachment succeeds,
 * the -&gt;detach() callback in the struct dev_pm_domain are assigned by the
 * corresponding backend attach function, as to deal with detaching of the
 * created virtual device.
 *
 * This function should typically be invoked by a driver during the probe phase,
 * in case its device requires power management through multiple PM domains. The
 * driver may benefit from using the received device, to configure device-links
 * towards its original device. Depending on the use-case and if needed, the
 * links may be dynamically changed by the driver, which allows it to control
 * the power to the PM domains independently from each other.
 *
 * Callers must ensure proper synchronization of this function with power
 * management callbacks.
 *
 * Returns the virtual created device when successfully attached to its PM
 * domain, NULL in case @dev don&apos;t need a PM domain, else an ERR_PTR().
 * Note that, to detach the returned virtual device, the driver shall call
 * dev_pm_domain_detach() on it, typically during the remove phase.
 */</doc>
