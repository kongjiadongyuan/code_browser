<dec f='linux-5.3.1/arch/x86/include/asm/ptrace.h' l='268' type='long probe_kernel_read(void * dst, const void * src, size_t size)'/>
<use f='linux-5.3.1/arch/x86/include/asm/ptrace.h' l='288' u='c' c='regs_get_kernel_stack_nth'/>
<dec f='linux-5.3.1/include/linux/uaccess.h' l='242' type='long probe_kernel_read(void * dst, const void * src, size_t size)'/>
<doc f='linux-5.3.1/arch/x86/include/asm/ptrace.h' l='267'>/* To avoid include hell, we can&apos;t include uaccess.h */</doc>
<doc f='linux-5.3.1/include/linux/uaccess.h' l='233'>/*
 * probe_kernel_read(): safely attempt to read from a location
 * @dst: pointer to the buffer that shall take the data
 * @src: address to read from
 * @size: size of the data chunk
 *
 * Safely read from address @src to the buffer at @dst.  If a kernel fault
 * happens, handle that and return -EFAULT.
 */</doc>
<use f='linux-5.3.1/arch/x86/kernel/dumpstack.c' l='109' u='c' c='show_opcodes'/>
<use f='linux-5.3.1/arch/x86/kernel/kprobes/core.c' l='245' u='c' c='__recover_probed_insn'/>
<use f='linux-5.3.1/arch/x86/kernel/kprobes/core.c' l='348' u='c' c='__copy_instruction'/>
<use f='linux-5.3.1/arch/x86/kernel/kprobes/opt.c' l='59' u='c' c='__recover_optprobed_insn'/>
<use f='linux-5.3.1/arch/x86/kernel/probe_roms.c' l='102' macro='1' u='c' c='probe_list'/>
<use f='linux-5.3.1/arch/x86/kernel/probe_roms.c' l='128' macro='1' u='c' c='find_oprom'/>
<use f='linux-5.3.1/arch/x86/kernel/probe_roms.c' l='131' macro='1' u='c' c='find_oprom'/>
<use f='linux-5.3.1/arch/x86/kernel/probe_roms.c' l='134' macro='1' u='c' c='find_oprom'/>
<use f='linux-5.3.1/arch/x86/kernel/probe_roms.c' l='142' macro='1' u='c' c='find_oprom'/>
<use f='linux-5.3.1/arch/x86/kernel/probe_roms.c' l='143' macro='1' u='c' c='find_oprom'/>
<use f='linux-5.3.1/arch/x86/kernel/probe_roms.c' l='186' macro='1' u='c' c='romsignature'/>
<use f='linux-5.3.1/arch/x86/kernel/probe_roms.c' l='193' macro='1' u='c' c='romchecksum'/>
<use f='linux-5.3.1/arch/x86/kernel/probe_roms.c' l='214' macro='1' u='c' c='probe_roms'/>
<use f='linux-5.3.1/arch/x86/kernel/probe_roms.c' l='252' macro='1' u='c' c='probe_roms'/>
<use f='linux-5.3.1/arch/x86/kernel/traps.c' l='168' macro='1' u='c' c='is_valid_bugaddr'/>
<use f='linux-5.3.1/arch/x86/mm/fault.c' l='100' macro='1' u='c' c='check_prefetch_opcode'/>
<use f='linux-5.3.1/arch/x86/mm/fault.c' l='134' macro='1' u='c' c='is_prefetch'/>
<use f='linux-5.3.1/arch/x86/mm/fault.c' l='421' macro='1' u='c' c='bad_address'/>
<use f='linux-5.3.1/arch/x86/mm/fault.c' l='570' u='c' c='show_ldttss'/>
<use f='linux-5.3.1/drivers/char/mem.c' l='163' u='c' c='read_mem'/>
<use f='linux-5.3.1/fs/proc/kcore.c' l='514' u='c' c='read_kcore'/>
<use f='linux-5.3.1/kernel/exit.c' l='252' macro='1' u='c' c='task_rcu_dereference'/>
<use f='linux-5.3.1/kernel/kthread.c' l='182' u='c' c='kthread_probe_data'/>
<use f='linux-5.3.1/kernel/trace/trace_kprobe.c' l='859' u='c' c='fetch_store_strlen'/>
<use f='linux-5.3.1/kernel/trace/trace_kprobe.c' l='929' u='c' c='probe_mem_read'/>
<use f='linux-5.3.1/kernel/workqueue.c' l='4585' u='c' c='print_worker_info'/>
<use f='linux-5.3.1/kernel/workqueue.c' l='4586' u='c' c='print_worker_info'/>
<use f='linux-5.3.1/kernel/workqueue.c' l='4587' u='c' c='print_worker_info'/>
<use f='linux-5.3.1/kernel/workqueue.c' l='4588' u='c' c='print_worker_info'/>
<use f='linux-5.3.1/kernel/workqueue.c' l='4589' u='c' c='print_worker_info'/>
<def f='linux-5.3.1/mm/maccess.c' l='36' ll='37' type='long probe_kernel_read(void * dst, const void * src, size_t size)'/>
<dec f='linux-5.3.1/mm/maccess.c' l='50' type='long probe_kernel_read(void * , const void * , size_t )'/>
<use f='linux-5.3.1/mm/maccess.c' l='50' c='probe_kernel_read'/>
<use f='linux-5.3.1/mm/maccess.c' l='50' u='a'/>
<doc f='linux-5.3.1/mm/maccess.c' l='21'>/**
 * probe_kernel_read(): safely attempt to read from a kernel-space location
 * @dst: pointer to the buffer that shall take the data
 * @src: address to read from
 * @size: size of the data chunk
 *
 * Safely read from address @src to the buffer at @dst.  If a kernel fault
 * happens, handle that and return -EFAULT.
 *
 * We ensure that the copy_from_user is executed in atomic context so that
 * do_page_fault() doesn&apos;t attempt to take mmap_sem.  This makes
 * probe_kernel_read() suitable for use within regions where the caller
 * already holds mmap_sem, or other locks which nest inside mmap_sem.
 */</doc>
<use f='linux-5.3.1/mm/slub.c' l='297' u='c' c='get_freepointer_safe'/>
