<dec f='linux-5.3.1/include/linux/clk.h' l='259' type='void clk_unprepare(struct clk * clk)'/>
<use f='linux-5.3.1/include/linux/clk.h' l='909' u='c' c='clk_prepare_enable'/>
<use f='linux-5.3.1/include/linux/clk.h' l='918' u='c' c='clk_disable_unprepare'/>
<use f='linux-5.3.1/drivers/base/power/clock_ops.c' l='247' u='c' c='__pm_clk_remove'/>
<use f='linux-5.3.1/drivers/clk/clk-bulk.c' l='161' u='c' c='clk_bulk_unprepare'/>
<def f='linux-5.3.1/drivers/clk/clk.c' l='849' ll='855' type='void clk_unprepare(struct clk * clk)'/>
<dec f='linux-5.3.1/drivers/clk/clk.c' l='856' type='void clk_unprepare(struct clk * )'/>
<use f='linux-5.3.1/drivers/clk/clk.c' l='856' c='clk_unprepare'/>
<use f='linux-5.3.1/drivers/clk/clk.c' l='856' u='a'/>
<doc f='linux-5.3.1/drivers/clk/clk.c' l='838'>/**
 * clk_unprepare - undo preparation of a clock source
 * @clk: the clk being unprepared
 *
 * clk_unprepare may sleep, which differentiates it from clk_disable.  In a
 * simple case, clk_unprepare can be used instead of clk_disable to gate a clk
 * if the operation may sleep.  One example is a clk which is accessed over
 * I2c.  In the complex case a clk gate operation may require a fast and a slow
 * part.  It is this reason that clk_unprepare and clk_disable are not mutually
 * exclusive.  In fact clk_disable must be called before clk_unprepare.
 */</doc>
<use f='linux-5.3.1/include/linux/amba/bus.h' l='153' u='c' c='amba_pclk_unprepare'/>
