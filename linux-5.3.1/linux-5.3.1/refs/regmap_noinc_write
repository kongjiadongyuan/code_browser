<dec f='linux-5.3.1/include/linux/regmap.h' l='1013' type='int regmap_noinc_write(struct regmap * map, unsigned int reg, const void * val, size_t val_len)'/>
<def f='linux-5.3.1/drivers/base/regmap/regmap.c' l='1940' ll='1979' type='int regmap_noinc_write(struct regmap * map, unsigned int reg, const void * val, size_t val_len)'/>
<dec f='linux-5.3.1/drivers/base/regmap/regmap.c' l='1980' type='int regmap_noinc_write(struct regmap * , unsigned int , const void * , size_t )'/>
<use f='linux-5.3.1/drivers/base/regmap/regmap.c' l='1980' c='regmap_noinc_write'/>
<use f='linux-5.3.1/drivers/base/regmap/regmap.c' l='1980' u='a'/>
<doc f='linux-5.3.1/drivers/base/regmap/regmap.c' l='1919'>/**
 * regmap_noinc_write(): Write data from a register without incrementing the
 *			register number
 *
 * @map: Register map to write to
 * @reg: Register to write to
 * @val: Pointer to data buffer
 * @val_len: Length of output buffer in bytes.
 *
 * The regmap API usually assumes that bulk bus write operations will write a
 * range of registers. Some devices have certain registers for which a write
 * operation can write to an internal FIFO.
 *
 * The target register must be volatile but registers after it can be
 * completely unrelated cacheable registers.
 *
 * This will attempt multiple writes as required to write val_len bytes.
 *
 * A value of zero will be returned on success, a negative errno will be
 * returned in error cases.
 */</doc>
