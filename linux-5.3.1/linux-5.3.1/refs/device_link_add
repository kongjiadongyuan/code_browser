<dec f='linux-5.3.1/include/linux/device.h' l='1410' type='struct device_link * device_link_add(struct device * consumer, struct device * supplier, u32 flags)'/>
<doc f='linux-5.3.1/include/linux/device.h' l='1409'>/* Device links interface. */</doc>
<def f='linux-5.3.1/drivers/base/core.c' l='217' ll='401' type='struct device_link * device_link_add(struct device * consumer, struct device * supplier, u32 flags)'/>
<dec f='linux-5.3.1/drivers/base/core.c' l='402' type='struct device_link * device_link_add(struct device * , struct device * , u32 )'/>
<use f='linux-5.3.1/drivers/base/core.c' l='402' c='device_link_add'/>
<use f='linux-5.3.1/drivers/base/core.c' l='402' u='a'/>
<doc f='linux-5.3.1/drivers/base/core.c' l='168'>/**
 * device_link_add - Create a link between two devices.
 * @consumer: Consumer end of the link.
 * @supplier: Supplier end of the link.
 * @flags: Link flags.
 *
 * The caller is responsible for the proper synchronization of the link creation
 * with runtime PM.  First, setting the DL_FLAG_PM_RUNTIME flag will cause the
 * runtime PM framework to take the link into account.  Second, if the
 * DL_FLAG_RPM_ACTIVE flag is set in addition to it, the supplier devices will
 * be forced into the active metastate and reference-counted upon the creation
 * of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
 * ignored.
 *
 * If DL_FLAG_STATELESS is set in @flags, the link is not going to be managed by
 * the driver core and, in particular, the caller of this function is expected
 * to drop the reference to the link acquired by it directly.
 *
 * If that flag is not set, however, the caller of this function is handing the
 * management of the link over to the driver core entirely and its return value
 * can only be used to check whether or not the link is present.  In that case,
 * the DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_AUTOREMOVE_SUPPLIER device link
 * flags can be used to indicate to the driver core when the link can be safely
 * deleted.  Namely, setting one of them in @flags indicates to the driver core
 * that the link is not going to be used (by the given caller of this function)
 * after unbinding the consumer or supplier driver, respectively, from its
 * device, so the link can be deleted at that point.  If none of them is set,
 * the link will be maintained until one of the devices pointed to by it (either
 * the consumer or the supplier) is unregistered.
 *
 * Also, if DL_FLAG_STATELESS, DL_FLAG_AUTOREMOVE_CONSUMER and
 * DL_FLAG_AUTOREMOVE_SUPPLIER are not set in @flags (that is, a persistent
 * managed device link is being added), the DL_FLAG_AUTOPROBE_CONSUMER flag can
 * be used to request the driver core to automaticall probe for a consmer
 * driver after successfully binding a driver to the supplier device.
 *
 * The combination of DL_FLAG_STATELESS and either DL_FLAG_AUTOREMOVE_CONSUMER
 * or DL_FLAG_AUTOREMOVE_SUPPLIER set in @flags at the same time is invalid and
 * will cause NULL to be returned upfront.
 *
 * A side effect of the link creation is re-ordering of dpm_list and the
 * devices_kset list by moving the consumer device and all devices depending
 * on it to the ends of these lists (that does not happen to devices that have
 * not been registered when this function is called).
 *
 * The supplier device is required to be registered when this function is called
 * and NULL will be returned if that is not the case.  The consumer device need
 * not be registered, however.
 */</doc>
<use f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_audio.c' l='998' u='c' c='i915_audio_component_bind'/>
<use f='linux-5.3.1/drivers/pci/quirks.c' l='4961' u='c' c='pci_create_device_link'/>
