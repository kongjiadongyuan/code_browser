<dec f='linux-5.3.1/include/linux/clk.h' l='380' type='int devm_clk_bulk_get_optional(struct device * dev, int num_clks, struct clk_bulk_data * clks)'/>
<doc f='linux-5.3.1/include/linux/clk.h' l='359'>/**
 * devm_clk_bulk_get_optional - managed get multiple optional consumer clocks
 * @dev: device for clock &quot;consumer&quot;
 * @num_clks: the number of clk_bulk_data
 * @clks: pointer to the clk_bulk_data table of consumer
 *
 * Behaves the same as devm_clk_bulk_get() except where there is no clock
 * producer.  In this case, instead of returning -ENOENT, the function returns
 * NULL for given clk. It is assumed all clocks in clk_bulk_data are optional.
 *
 * Returns 0 if all clocks specified in clk_bulk_data table are obtained
 * successfully or for any clk there was no clk provider available, otherwise
 * returns valid IS_ERR() condition containing errno.
 * The implementation uses @dev and @clk_bulk_data.id to determine the
 * clock consumer, and thereby the clock producer.
 * The clock returned is stored in each @clk_bulk_data.clk field.
 *
 * Drivers must assume that the clock source is not enabled.
 *
 * clk_bulk_get should not be called from within interrupt context.
 */</doc>
<def f='linux-5.3.1/drivers/clk/clk-devres.c' l='88' ll='92' type='int devm_clk_bulk_get_optional(struct device * dev, int num_clks, struct clk_bulk_data * clks)'/>
<dec f='linux-5.3.1/drivers/clk/clk-devres.c' l='93' type='int devm_clk_bulk_get_optional(struct device * , int , struct clk_bulk_data * )'/>
<use f='linux-5.3.1/drivers/clk/clk-devres.c' l='93' c='devm_clk_bulk_get_optional'/>
<use f='linux-5.3.1/drivers/clk/clk-devres.c' l='93' u='a'/>
