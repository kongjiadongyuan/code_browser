<dec f='linux-5.3.1/include/linux/ipc_namespace.h' l='133' type='void put_ipc_ns(struct ipc_namespace * ns)'/>
<use f='linux-5.3.1/ipc/mqueue.c' l='375' u='c' c='mqueue_fs_context_free'/>
<use f='linux-5.3.1/ipc/mqueue.c' l='406' u='c' c='mq_create_mount'/>
<use f='linux-5.3.1/ipc/mqueue.c' l='490' u='c' c='mqueue_evict_inode'/>
<use f='linux-5.3.1/ipc/mqueue.c' l='524' u='c' c='mqueue_create_attr'/>
<use f='linux-5.3.1/ipc/mqueue.c' l='534' u='c' c='mqueue_create_attr'/>
<def f='linux-5.3.1/ipc/namespace.c' l='146' ll='154' type='void put_ipc_ns(struct ipc_namespace * ns)'/>
<use f='linux-5.3.1/ipc/namespace.c' l='177' u='c' c='ipcns_put'/>
<use f='linux-5.3.1/ipc/namespace.c' l='189' u='c' c='ipcns_install'/>
<doc f='linux-5.3.1/ipc/namespace.c' l='130'>/*
 * put_ipc_ns - drop a reference to an ipc namespace.
 * @ns: the namespace to put
 *
 * If this is the last task in the namespace exiting, and
 * it is dropping the refcount to 0, then it can race with
 * a task in another ipc namespace but in a mounts namespace
 * which has this ipcns&apos;s mqueuefs mounted, doing some action
 * with one of the mqueuefs files.  That can raise the refcount.
 * So dropping the refcount, and raising the refcount when
 * accessing it through the VFS, are protected with mq_lock.
 *
 * (Clearly, a task raising the refcount on its own ipc_ns
 * needn&apos;t take mq_lock since it can&apos;t race with the last task
 * in the ipcns exiting).
 */</doc>
<use f='linux-5.3.1/ipc/shm.c' l='518' u='c' c='shm_release'/>
<use f='linux-5.3.1/ipc/util.c' l='882' u='c' c='sysvipc_proc_release'/>
<use f='linux-5.3.1/kernel/nsproxy.c' l='118' u='c' c='create_new_namespaces'/>
<use f='linux-5.3.1/kernel/nsproxy.c' l='176' u='c' c='free_nsproxy'/>
