<dec f='linux-5.3.1/arch/x86/include/asm/traps.h' l='89' type='void do_machine_check(struct pt_regs * regs, long error_code)'/>
<dec f='linux-5.3.1/arch/x86/include/asm/mce.h' l='244' type='void do_machine_check(struct pt_regs * , long )'/>
<def f='linux-5.3.1/arch/x86/kernel/cpu/mce/core.c' l='1218' ll='1361' type='void do_machine_check(struct pt_regs * regs, long error_code)'/>
<dec f='linux-5.3.1/arch/x86/kernel/cpu/mce/core.c' l='1362' type='void do_machine_check(struct pt_regs * , long )'/>
<use f='linux-5.3.1/arch/x86/kernel/cpu/mce/core.c' l='1362' c='do_machine_check'/>
<use f='linux-5.3.1/arch/x86/kernel/cpu/mce/core.c' l='1362' u='a'/>
<use f='linux-5.3.1/arch/x86/kernel/cpu/mce/core.c' l='1878' u='r' c='mcheck_cpu_init'/>
<doc f='linux-5.3.1/arch/x86/kernel/cpu/mce/core.c' l='1206'>/*
 * The actual machine check handler. This only handles real
 * exceptions when something got corrupted coming in through int 18.
 *
 * This is executed in NMI context not subject to normal locking rules. This
 * implies that most kernel services cannot be safely used. Don&apos;t even
 * think about putting a printk in there!
 *
 * On Intel systems this is entered on all CPUs in parallel through
 * MCE broadcast. However some CPUs might be broken beyond repair,
 * so be always careful when synchronizing with others.
 */</doc>
