<dec f='linux-5.3.1/include/linux/usb/hcd.h' l='504' type='void usb_hcd_poll_rh_status(struct usb_hcd * hcd)'/>
<def f='linux-5.3.1/drivers/usb/core/hcd.c' l='752' ll='792' type='void usb_hcd_poll_rh_status(struct usb_hcd * hcd)'/>
<dec f='linux-5.3.1/drivers/usb/core/hcd.c' l='793' type='void usb_hcd_poll_rh_status(struct usb_hcd * )'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='793' c='usb_hcd_poll_rh_status'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='793' u='a'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='800' u='c' c='rh_timer_func'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='2798' u='c' c='usb_add_hcd'/>
<doc f='linux-5.3.1/drivers/usb/core/hcd.c' l='744'>/*
 * Root Hub interrupt transfers are polled using a timer if the
 * driver requests it; otherwise the driver is responsible for
 * calling usb_hcd_poll_rh_status() when an event occurs.
 *
 * Completions are called in_interrupt(), but they may or may not
 * be in_irq().
 */</doc>
<use f='linux-5.3.1/drivers/usb/host/ehci-hcd.c' l='834' u='c' c='ehci_irq'/>
<use f='linux-5.3.1/drivers/usb/host/ohci-hub.c' l='339' u='c' c='ohci_bus_resume'/>
<use f='linux-5.3.1/drivers/usb/host/ohci-hcd.c' l='939' u='c' c='ohci_irq'/>
<use f='linux-5.3.1/drivers/usb/host/uhci-hcd.c' l='498' u='c' c='uhci_irq'/>
<use f='linux-5.3.1/drivers/usb/host/uhci-pci.c' l='251' u='c' c='uhci_pci_resume'/>
<use f='linux-5.3.1/drivers/usb/host/xhci-ring.c' l='1738' u='c' c='handle_port_status'/>
<use f='linux-5.3.1/drivers/usb/host/xhci.c' l='503' u='c' c='compliance_mode_recovery'/>
<use f='linux-5.3.1/drivers/usb/host/xhci.c' l='1237' u='c' c='xhci_resume'/>
<use f='linux-5.3.1/drivers/usb/host/xhci.c' l='1239' u='c' c='xhci_resume'/>
