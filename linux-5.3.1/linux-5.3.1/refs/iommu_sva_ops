<def f='linux-5.3.1/include/linux/iommu.h' l='188' ll='190'/>
<use f='linux-5.3.1/include/linux/iommu.h' l='524'/>
<use f='linux-5.3.1/include/linux/iommu.h' l='560' c='iommu_sva_set_ops'/>
<size>8</size>
<doc f='linux-5.3.1/include/linux/iommu.h' l='173'>/**
 * struct iommu_sva_ops - device driver callbacks for an SVA context
 *
 * @mm_exit: called when the mm is about to be torn down by exit_mmap. After
 *           @mm_exit returns, the device must not issue any more transaction
 *           with the PASID given as argument.
 *
 *           The @mm_exit handler is allowed to sleep. Be careful about the
 *           locks taken in @mm_exit, because they might lead to deadlocks if
 *           they are also held when dropping references to the mm. Consider the
 *           following call chain:
 *           mutex_lock(A); mmput(mm) -&gt; exit_mm() -&gt; @mm_exit() -&gt; mutex_lock(A)
 *           Using mmput_async() prevents this scenario.
 *
 */</doc>
<mbr r='iommu_sva_ops::mm_exit' o='0' t='iommu_mm_exit_handler_t'/>
<use f='linux-5.3.1/drivers/iommu/iommu.c' l='2451' c='iommu_sva_set_ops'/>
<size>8</size>
