<dec f='linux-5.3.1/include/linux/usb/hcd.h' l='428' type='int usb_hcd_link_urb_to_ep(struct usb_hcd * hcd, struct urb * urb)'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='493' u='c' c='rh_call_control'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='818' u='c' c='rh_queue_status'/>
<def f='linux-5.3.1/drivers/usb/core/hcd.c' l='1144' ll='1180' type='int usb_hcd_link_urb_to_ep(struct usb_hcd * hcd, struct urb * urb)'/>
<dec f='linux-5.3.1/drivers/usb/core/hcd.c' l='1181' type='int usb_hcd_link_urb_to_ep(struct usb_hcd * , struct urb * )'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='1181' c='usb_hcd_link_urb_to_ep'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='1181' u='a'/>
<doc f='linux-5.3.1/drivers/usb/core/hcd.c' l='1129'>/**
 * usb_hcd_link_urb_to_ep - add an URB to its endpoint queue
 * @hcd: host controller to which @urb was submitted
 * @urb: URB being submitted
 *
 * Host controller drivers should call this routine in their enqueue()
 * method.  The HCD&apos;s private spinlock must be held and interrupts must
 * be disabled.  The actions carried out here are required for URB
 * submission, as well as for endpoint shutdown and for usb_kill_urb.
 *
 * Return: 0 for no error, otherwise a negative error code (in which case
 * the enqueue() method must fail).  If no error occurs but enqueue() fails
 * anyway, it must call usb_hcd_unlink_urb_from_ep() before releasing
 * the private spinlock and returning.
 */</doc>
<use f='linux-5.3.1/drivers/usb/host/ehci-q.c' l='1122' u='c' c='submit_async'/>
<use f='linux-5.3.1/drivers/usb/host/ehci-sched.c' l='938' u='c' c='intr_submit'/>
<use f='linux-5.3.1/drivers/usb/host/ehci-sched.c' l='1966' u='c' c='itd_submit'/>
<use f='linux-5.3.1/drivers/usb/host/ehci-sched.c' l='2343' u='c' c='sitd_submit'/>
<use f='linux-5.3.1/drivers/usb/host/ohci-hcd.c' l='223' u='c' c='ohci_urb_enqueue'/>
<use f='linux-5.3.1/drivers/usb/host/uhci-q.c' l='1419' u='c' c='uhci_urb_enqueue'/>
<use f='linux-5.3.1/drivers/usb/host/xhci-ring.c' l='2983' u='c' c='prepare_transfer'/>
