<dec f='linux-5.3.1/include/linux/efi.h' l='1508' type='int efivar_entry_set_get_size(struct efivar_entry * entry, u32 attributes, unsigned long * size, void * data, bool * set)'/>
<def f='linux-5.3.1/drivers/firmware/efi/vars.c' l='958' ll='1036' type='int efivar_entry_set_get_size(struct efivar_entry * entry, u32 attributes, unsigned long * size, void * data, bool * set)'/>
<dec f='linux-5.3.1/drivers/firmware/efi/vars.c' l='1037' type='int efivar_entry_set_get_size(struct efivar_entry * , u32 , unsigned long * , void * , bool * )'/>
<use f='linux-5.3.1/drivers/firmware/efi/vars.c' l='1037' c='efivar_entry_set_get_size'/>
<use f='linux-5.3.1/drivers/firmware/efi/vars.c' l='1037' u='a'/>
<doc f='linux-5.3.1/drivers/firmware/efi/vars.c' l='936'>/**
 * efivar_entry_set_get_size - call set_variable() and get new size (atomic)
 * @entry: entry containing variable to set and get
 * @attributes: attributes of variable to be written
 * @size: size of data buffer
 * @data: buffer containing data to write
 * @set: did the set_variable() call succeed?
 *
 * This is a pretty special (complex) function. See efivarfs_file_write().
 *
 * Atomically call set_variable() for @entry and if the call is
 * successful, return the new size of the variable from get_variable()
 * in @size. The success of set_variable() is indicated by @set.
 *
 * Returns 0 on success, -EINVAL if the variable data is invalid,
 * -ENOSPC if the firmware does not have enough available space, or a
 * converted EFI status code if either of set_variable() or
 * get_variable() fail.
 *
 * If the EFI variable does not exist when calling set_variable()
 * (EFI_NOT_FOUND), @entry is removed from the variable list.
 */</doc>
<use f='linux-5.3.1/fs/efivarfs/file.c' l='39' u='c' c='efivarfs_file_write'/>
