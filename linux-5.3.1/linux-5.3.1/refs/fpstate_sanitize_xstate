<dec f='linux-5.3.1/arch/x86/include/asm/fpu/internal.h' l='103' type='void fpstate_sanitize_xstate(struct fpu * fpu)'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/regset.c' l='39' u='c' c='xfpregs_get'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/regset.c' l='56' u='c' c='xfpregs_set'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/regset.c' l='97' u='c' c='xstateregs_get'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/regset.c' l='312' u='c' c='fpregs_get'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/regset.c' l='333' u='c' c='fpregs_set'/>
<def f='linux-5.3.1/arch/x86/kernel/fpu/xstate.c' l='146' ll='208' type='void fpstate_sanitize_xstate(struct fpu * fpu)'/>
<doc f='linux-5.3.1/arch/x86/kernel/fpu/xstate.c' l='131'>/*
 * When executing XSAVEOPT (or other optimized XSAVE instructions), if
 * a processor implementation detects that an FPU state component is still
 * (or is again) in its initialized state, it may clear the corresponding
 * bit in the header.xfeatures field, and can skip the writeout of registers
 * to the corresponding memory layout.
 *
 * This means that when the bit is zero, the state component might still contain
 * some previous - non-initialized register state.
 *
 * Before writing xstate information to user-space we sanitize those components,
 * to always ensure that the memory layout of a feature will be in the init state
 * if the corresponding header bit is zero. This is to ensure that user-space doesn&apos;t
 * see some stale state in the memory layout during signal handling, debugging etc.
 */</doc>
