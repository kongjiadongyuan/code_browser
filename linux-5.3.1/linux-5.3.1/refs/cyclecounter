<def f='linux-5.3.1/include/linux/timecounter.h' l='30' ll='35'/>
<use f='linux-5.3.1/include/linux/timecounter.h' l='31'/>
<use f='linux-5.3.1/include/linux/timecounter.h' l='56'/>
<use f='linux-5.3.1/include/linux/timecounter.h' l='70' c='cyclecounter_cyc2ns'/>
<use f='linux-5.3.1/include/linux/timecounter.h' l='100' c='timecounter_init'/>
<use f='linux-5.3.1/drivers/net/ethernet/intel/e1000e/e1000.h' l='326'/>
<size>24</size>
<doc f='linux-5.3.1/include/linux/timecounter.h' l='16'>/**
 * struct cyclecounter - hardware abstraction for a free running counter
 *	Provides completely state-free accessors to the underlying hardware.
 *	Depending on which hardware it reads, the cycle counter may wrap
 *	around quickly. Locking rules (if necessary) have to be defined
 *	by the implementor and user of specific instances of this API.
 *
 * @read:		returns the current cycle value
 * @mask:		bitmask for two&apos;s complement
 *			subtraction of non 64 bit counters,
 *			see CYCLECOUNTER_MASK() helper macro
 * @mult:		cycle to nanosecond multiplier
 * @shift:		cycle to nanosecond divisor (power of two)
 */</doc>
<mbr r='cyclecounter::read' o='0' t='u64 (*)(const struct cyclecounter *)'/>
<mbr r='cyclecounter::mask' o='64' t='u64'/>
<mbr r='cyclecounter::mult' o='128' t='u32'/>
<mbr r='cyclecounter::shift' o='160' t='u32'/>
<use f='linux-5.3.1/drivers/net/ethernet/intel/e1000e/netdev.c' l='4410' c='e1000e_cyclecounter_read'/>
<size>24</size>
<use f='linux-5.3.1/kernel/time/timecounter.c' l='9' c='timecounter_init'/>
<use f='linux-5.3.1/kernel/time/timecounter.c' l='69' c='cc_cyc2ns_backwards'/>
<size>24</size>
<use f='linux-5.3.1/include/sound/hdaudio.h' l='512'/>
<size>24</size>
<use f='linux-5.3.1/sound/hda/hdac_stream.c' l='514' c='azx_cc_read'/>
<use f='linux-5.3.1/sound/hda/hdac_stream.c' l='525' c='azx_timecounter_init'/>
<size>24</size>
