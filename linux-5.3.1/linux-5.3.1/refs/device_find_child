<dec f='linux-5.3.1/include/linux/device.h' l='1264' type='struct device * device_find_child(struct device * dev, void * data, int (*)(struct device *, void *) match)'/>
<def f='linux-5.3.1/drivers/base/core.c' l='2524' ll='2539' type='struct device * device_find_child(struct device * parent, void * data, int (*)(struct device *, void *) match)'/>
<dec f='linux-5.3.1/drivers/base/core.c' l='2540' type='struct device * device_find_child(struct device * , void * , int (*)(struct device *, void *) )'/>
<use f='linux-5.3.1/drivers/base/core.c' l='2540' c='device_find_child'/>
<use f='linux-5.3.1/drivers/base/core.c' l='2540' u='a'/>
<doc f='linux-5.3.1/drivers/base/core.c' l='2507'>/**
 * device_find_child - device iterator for locating a particular device.
 * @parent: parent struct device
 * @match: Callback function to check device
 * @data: Data to pass to match function
 *
 * This is similar to the device_for_each_child() function above, but it
 * returns a reference to a device that is &apos;found&apos; for later use, as
 * determined by the @match callback.
 *
 * The callback should return 0 if the device doesn&apos;t match and non-zero
 * if it does.  If the callback returns non-zero and a reference to the
 * current device can be obtained, this function will return to the caller
 * and not iterate over any more devices.
 *
 * NOTE: you will need to drop the reference with put_device() after use.
 */</doc>
<use f='linux-5.3.1/drivers/tty/serial/serial_core.c' l='2152' u='c' c='uart_suspend_port'/>
<use f='linux-5.3.1/drivers/tty/serial/serial_core.c' l='2215' u='c' c='uart_resume_port'/>
