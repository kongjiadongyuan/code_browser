<dec f='linux-5.3.1/include/linux/mmu_notifier.h' l='237' type='int mmu_notifier_register(struct mmu_notifier * mn, struct mm_struct * mm)'/>
<def f='linux-5.3.1/mm/mmu_notifier.c' l='303' ll='306' type='int mmu_notifier_register(struct mmu_notifier * mn, struct mm_struct * mm)'/>
<dec f='linux-5.3.1/mm/mmu_notifier.c' l='307' type='int mmu_notifier_register(struct mmu_notifier * , struct mm_struct * )'/>
<use f='linux-5.3.1/mm/mmu_notifier.c' l='307' c='mmu_notifier_register'/>
<use f='linux-5.3.1/mm/mmu_notifier.c' l='307' u='a'/>
<doc f='linux-5.3.1/mm/mmu_notifier.c' l='290'>/*
 * Must not hold mmap_sem nor any other VM related lock when calling
 * this registration function. Must also ensure mm_users can&apos;t go down
 * to zero while this runs to avoid races with mmu_notifier_release,
 * so mm has to be current-&gt;mm or the mm should be pinned safely such
 * as with get_task_mm(). If the mm is not current-&gt;mm, the mm_users
 * pin should be released by calling mmput after mmu_notifier_register
 * returns. mmu_notifier_unregister must be always called to
 * unregister the notifier. mm_count is automatically pinned to allow
 * mmu_notifier_unregister to safely run at any time later, before or
 * after exit_mmap. -&gt;release will always be called before exit_mmap
 * frees the pages.
 */</doc>
