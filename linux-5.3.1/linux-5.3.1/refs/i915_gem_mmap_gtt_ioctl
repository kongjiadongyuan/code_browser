<dec f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_ioctls.h' l='31' type='int i915_gem_mmap_gtt_ioctl(struct drm_device * dev, void * data, struct drm_file * file)'/>
<def f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_mman.c' l='497' ll='504' type='int i915_gem_mmap_gtt_ioctl(struct drm_device * dev, void * data, struct drm_file * file)'/>
<doc f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_mman.c' l='482'>/**
 * i915_gem_mmap_gtt_ioctl - prepare an object for GTT mmap&apos;ing
 * @dev: DRM device
 * @data: GTT mapping ioctl data
 * @file: GEM object info
 *
 * Simply returns the fake offset to userspace so it can mmap it.
 * The mmap call will end up in drm_gem_mmap(), which will set things
 * up so we can get faults in the handler above.
 *
 * The fault handler will take care of binding the object into the GTT
 * (since it may have been evicted to make room for something), allocating
 * a fence register, and mapping the appropriate aperture address into
 * userspace.
 */</doc>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3176'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3176'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3176'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_drv.c' l='3176'/>
