<dec f='linux-5.3.1/include/net/mac80211.h' l='4887' type='void ieee80211_ctstoself_get(struct ieee80211_hw * hw, struct ieee80211_vif * vif, const void * frame, size_t frame_len, const struct ieee80211_tx_info * frame_txctl, struct ieee80211_cts * cts)'/>
<doc f='linux-5.3.1/include/net/mac80211.h' l='4873'>/**
 * ieee80211_ctstoself_get - CTS-to-self frame generation function
 * @hw: pointer obtained from ieee80211_alloc_hw().
 * @vif: &amp;struct ieee80211_vif pointer from the add_interface callback.
 * @frame: pointer to the frame that is going to be protected by the CTS-to-self.
 * @frame_len: the frame length (in octets).
 * @frame_txctl: &amp;struct ieee80211_tx_info of the frame.
 * @cts: The buffer where to store the CTS-to-self frame.
 *
 * If the CTS-to-self frames are generated by the host system (i.e., not in
 * hardware/firmware), the low-level driver uses this function to receive
 * the next CTS-to-self frame from the 802.11 code. The low-level is responsible
 * for calling this function before and CTS-to-self frame is needed.
 */</doc>
<def f='linux-5.3.1/net/mac80211/tx.c' l='4840' ll='4852' type='void ieee80211_ctstoself_get(struct ieee80211_hw * hw, struct ieee80211_vif * vif, const void * frame, size_t frame_len, const struct ieee80211_tx_info * frame_txctl, struct ieee80211_cts * cts)'/>
<dec f='linux-5.3.1/net/mac80211/tx.c' l='4853' type='void ieee80211_ctstoself_get(struct ieee80211_hw * , struct ieee80211_vif * , const void * , size_t , const struct ieee80211_tx_info * , struct ieee80211_cts * )'/>
<use f='linux-5.3.1/net/mac80211/tx.c' l='4853' c='ieee80211_ctstoself_get'/>
<use f='linux-5.3.1/net/mac80211/tx.c' l='4853' u='a'/>
