<dec f='linux-5.3.1/include/net/tcp.h' l='380' type='int tcp_child_process(struct sock * parent, struct sock * child, struct sk_buff * skb)'/>
<use f='linux-5.3.1/net/ipv4/tcp_ipv4.c' l='1555' u='c' c='tcp_v4_do_rcv'/>
<use f='linux-5.3.1/net/ipv4/tcp_ipv4.c' l='1881' u='c' c='tcp_v4_rcv'/>
<def f='linux-5.3.1/net/ipv4/tcp_minisocks.c' l='812' ll='838' type='int tcp_child_process(struct sock * parent, struct sock * child, struct sk_buff * skb)'/>
<dec f='linux-5.3.1/net/ipv4/tcp_minisocks.c' l='839' type='int tcp_child_process(struct sock * , struct sock * , struct sk_buff * )'/>
<use f='linux-5.3.1/net/ipv4/tcp_minisocks.c' l='839' c='tcp_child_process'/>
<use f='linux-5.3.1/net/ipv4/tcp_minisocks.c' l='839' u='a'/>
<doc f='linux-5.3.1/net/ipv4/tcp_minisocks.c' l='800'>/*
 * Queue segment on the new socket if the new socket is active,
 * otherwise we just shortcircuit this and continue with
 * the new socket.
 *
 * For the vast majority of cases child-&gt;sk_state will be TCP_SYN_RECV
 * when entering. But other states are possible due to a race condition
 * where after __inet_lookup_established() fails but before the listener
 * locked is obtained, other packets cause the same connection to
 * be created.
 */</doc>
<use f='linux-5.3.1/net/ipv6/tcp_ipv6.c' l='1372' u='c' c='tcp_v6_do_rcv'/>
<use f='linux-5.3.1/net/ipv6/tcp_ipv6.c' l='1548' u='c' c='tcp_v6_rcv'/>
