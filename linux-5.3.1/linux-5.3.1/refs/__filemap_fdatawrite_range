<dec f='linux-5.3.1/include/linux/fs.h' l='2717' type='int __filemap_fdatawrite_range(struct address_space * mapping, loff_t start, loff_t end, int sync_mode)'/>
<use f='linux-5.3.1/fs/sync.c' l='301' u='c' c='sync_file_range'/>
<use f='linux-5.3.1/mm/fadvise.c' l='116' u='c' c='generic_fadvise'/>
<def f='linux-5.3.1/mm/filemap.c' l='400' ll='418' type='int __filemap_fdatawrite_range(struct address_space * mapping, loff_t start, loff_t end, int sync_mode)'/>
<use f='linux-5.3.1/mm/filemap.c' l='423' u='c' c='__filemap_fdatawrite'/>
<use f='linux-5.3.1/mm/filemap.c' l='435' u='c' c='filemap_fdatawrite_range'/>
<use f='linux-5.3.1/mm/filemap.c' l='672' u='c' c='filemap_write_and_wait_range'/>
<use f='linux-5.3.1/mm/filemap.c' l='773' u='c' c='file_write_and_wait_range'/>
<doc f='linux-5.3.1/mm/filemap.c' l='383'>/**
 * __filemap_fdatawrite_range - start writeback on mapping dirty pages in range
 * @mapping:	address space structure to write
 * @start:	offset in bytes where the range starts
 * @end:	offset in bytes where the range ends (inclusive)
 * @sync_mode:	enable synchronous operation
 *
 * Start writeback against all of a mapping&apos;s dirty pages that lie
 * within the byte offsets &lt;start, end&gt; inclusive.
 *
 * If sync_mode is WB_SYNC_ALL then this is a &quot;data integrity&quot; operation, as
 * opposed to a regular memory cleansing writeback.  The difference between
 * these two operations is that if a dirty page/buffer is encountered, it must
 * be waited upon, and not just skipped over.
 *
 * Return: %0 on success, negative error code otherwise.
 */</doc>
