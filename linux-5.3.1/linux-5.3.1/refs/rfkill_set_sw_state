<dec f='linux-5.3.1/include/linux/rfkill.h' l='181' type='bool rfkill_set_sw_state(struct rfkill * rfkill, bool blocked)'/>
<use f='linux-5.3.1/drivers/platform/x86/eeepc-laptop.c' l='571' u='c' c='eeepc_rfkill_hotplug'/>
<use f='linux-5.3.1/drivers/platform/x86/eeepc-laptop.c' l='920' u='c' c='eeepc_hotk_restore'/>
<use f='linux-5.3.1/drivers/platform/x86/eeepc-laptop.c' l='923' u='c' c='eeepc_hotk_restore'/>
<use f='linux-5.3.1/drivers/platform/x86/eeepc-laptop.c' l='926' u='c' c='eeepc_hotk_restore'/>
<doc f='linux-5.3.1/include/linux/rfkill.h' l='161'>/**
 * rfkill_set_sw_state - Set the internal rfkill software block state
 * @rfkill: pointer to the rfkill class to modify.
 * @blocked: the current software block state to set
 *
 * rfkill drivers that get events when the soft-blocked state changes
 * (yes, some platforms directly act on input but allow changing again)
 * use this function to notify the rfkill core (and through that also
 * userspace) of the current state.
 *
 * Drivers should also call this function after resume if the state has
 * been changed by the user.  This only makes sense for &quot;persistent&quot;
 * devices (see rfkill_init_sw_state()).
 *
 * This function can be called in any context, even from within rfkill
 * callbacks.
 *
 * The function returns the combined block state (true if transmitter
 * should be blocked).
 */</doc>
<def f='linux-5.3.1/net/rfkill/core.c' l='565' ll='589' type='bool rfkill_set_sw_state(struct rfkill * rfkill, bool blocked)'/>
<dec f='linux-5.3.1/net/rfkill/core.c' l='590' type='bool rfkill_set_sw_state(struct rfkill * , bool )'/>
<use f='linux-5.3.1/net/rfkill/core.c' l='590' c='rfkill_set_sw_state'/>
<use f='linux-5.3.1/net/rfkill/core.c' l='590' u='a'/>
