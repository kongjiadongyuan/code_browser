<dec f='linux-5.3.1/include/linux/uio.h' l='190' type='size_t _copy_to_iter_mcsafe(const void * addr, size_t bytes, struct iov_iter * i)'/>
<use f='linux-5.3.1/include/linux/uio.h' l='210' u='c' c='copy_to_iter_mcsafe'/>
<def f='linux-5.3.1/lib/iov_iter.c' l='701' ll='733' type='size_t _copy_to_iter_mcsafe(const void * addr, size_t bytes, struct iov_iter * i)'/>
<dec f='linux-5.3.1/lib/iov_iter.c' l='734' type='size_t _copy_to_iter_mcsafe(const void * , size_t , struct iov_iter * )'/>
<use f='linux-5.3.1/lib/iov_iter.c' l='734' c='_copy_to_iter_mcsafe'/>
<use f='linux-5.3.1/lib/iov_iter.c' l='734' u='a'/>
<doc f='linux-5.3.1/lib/iov_iter.c' l='675'>/**
 * _copy_to_iter_mcsafe - copy to user with source-read error exception handling
 * @addr: source kernel address
 * @bytes: total transfer length
 * @iter: destination iterator
 *
 * The pmem driver arranges for filesystem-dax to use this facility via
 * dax_copy_to_iter() for protecting read/write to persistent memory.
 * Unless / until an architecture can guarantee identical performance
 * between _copy_to_iter_mcsafe() and _copy_to_iter() it would be a
 * performance regression to switch more users to the mcsafe version.
 *
 * Otherwise, the main differences between this and typical _copy_to_iter().
 *
 * * Typical tail/residue handling after a fault retries the copy
 *   byte-by-byte until the fault happens again. Re-triggering machine
 *   checks is potentially fatal so the implementation uses source
 *   alignment and poison alignment assumptions to avoid re-triggering
 *   hardware exceptions.
 *
 * * ITER_KVEC, ITER_PIPE, and ITER_BVEC can return short copies.
 *   Compare to copy_to_iter() where only ITER_IOVEC attempts might return
 *   a short copy.
 *
 * See MCSAFE_TEST for self-test.
 */</doc>
