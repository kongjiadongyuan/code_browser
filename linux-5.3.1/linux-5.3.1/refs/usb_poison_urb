<dec f='linux-5.3.1/include/linux/usb.h' l='1708' type='void usb_poison_urb(struct urb * urb)'/>
<def f='linux-5.3.1/drivers/usb/core/urb.c' l='728' ll='740' type='void usb_poison_urb(struct urb * urb)'/>
<dec f='linux-5.3.1/drivers/usb/core/urb.c' l='741' type='void usb_poison_urb(struct urb * )'/>
<use f='linux-5.3.1/drivers/usb/core/urb.c' l='741' c='usb_poison_urb'/>
<use f='linux-5.3.1/drivers/usb/core/urb.c' l='741' u='a'/>
<use f='linux-5.3.1/drivers/usb/core/urb.c' l='828' u='c' c='usb_poison_anchored_urbs'/>
<doc f='linux-5.3.1/drivers/usb/core/urb.c' l='701'>/**
 * usb_poison_urb - reliably kill a transfer and prevent further use of an URB
 * @urb: pointer to URB describing a previously submitted request,
 *	may be NULL
 *
 * This routine cancels an in-progress request.  It is guaranteed that
 * upon return all completion handlers will have finished and the URB
 * will be totally idle and cannot be reused.  These features make
 * this an ideal way to stop I/O in a disconnect() callback.
 * If the request has not already finished or been unlinked
 * the completion handler will see urb-&gt;status == -ENOENT.
 *
 * After and while the routine runs, attempts to resubmit the URB will fail
 * with error -EPERM.  Thus even if the URB&apos;s completion handler always
 * tries to resubmit, it will not succeed and the URB will become idle.
 *
 * The URB must not be deallocated while this routine is running.  In
 * particular, when a driver calls this routine, it must insure that the
 * completion handler cannot deallocate the URB.
 *
 * This routine may not be used in an interrupt context (such as a bottom
 * half or a completion handler), or when holding a spinlock, or in other
 * situations where the caller can&apos;t schedule().
 *
 * This routine should not be called by a driver after its disconnect
 * method has returned.
 */</doc>
