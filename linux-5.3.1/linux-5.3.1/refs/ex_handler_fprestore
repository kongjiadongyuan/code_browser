<def f='linux-5.3.1/arch/x86/mm/extable.c' l='106' ll='118' type='bool ex_handler_fprestore(const struct exception_table_entry * fixup, struct pt_regs * regs, int trapnr, unsigned long error_code, unsigned long fault_addr)'/>
<dec f='linux-5.3.1/arch/x86/mm/extable.c' l='119' type='bool ex_handler_fprestore(const struct exception_table_entry * , struct pt_regs * , int , unsigned long , unsigned long )'/>
<use f='linux-5.3.1/arch/x86/mm/extable.c' l='119' c='ex_handler_fprestore'/>
<use f='linux-5.3.1/arch/x86/mm/extable.c' l='119' u='a'/>
<doc f='linux-5.3.1/arch/x86/mm/extable.c' l='96'>/*
 * Handler for when we fail to restore a task&apos;s FPU state.  We should never get
 * here because the FPU state of a task using the FPU (task-&gt;thread.fpu.state)
 * should always be valid.  However, past bugs have allowed userspace to set
 * reserved bits in the XSAVE area using PTRACE_SETREGSET or sys_rt_sigreturn().
 * These caused XRSTOR to fail when switching to the task, leaking the FPU
 * registers of the task previously executing on the CPU.  Mitigate this class
 * of vulnerability by restoring from the initial state (essentially, zeroing
 * out all the FPU registers) if we can&apos;t restore from the task&apos;s FPU state.
 */</doc>
