<def f='linux-5.3.1/arch/x86/kernel/hpet.c' l='671' ll='677'/>
<use f='linux-5.3.1/arch/x86/kernel/hpet.c' l='679'/>
<use f='linux-5.3.1/arch/x86/kernel/hpet.c' l='686' c='read_hpet'/>
<use f='linux-5.3.1/arch/x86/kernel/hpet.c' l='686' c='read_hpet'/>
<use f='linux-5.3.1/arch/x86/kernel/hpet.c' l='688' c='read_hpet'/>
<size>8</size>
<doc f='linux-5.3.1/arch/x86/kernel/hpet.c' l='650'>/*
 * Reading the HPET counter is a very slow operation. If a large number of
 * CPUs are trying to access the HPET counter simultaneously, it can cause
 * massive delays and slow down system performance dramatically. This may
 * happen when HPET is the default clock source instead of TSC. For a
 * really large system with hundreds of CPUs, the slowdown may be so
 * severe, that it can actually crash the system because of a NMI watchdog
 * soft lockup, for example.
 *
 * If multiple CPUs are trying to access the HPET counter at the same time,
 * we don&apos;t actually need to read the counter multiple times. Instead, the
 * other CPUs can use the counter value read by the first CPU in the group.
 *
 * This special feature is only enabled on x86-64 systems. It is unlikely
 * that 32-bit x86 systems will have enough CPUs to require this feature
 * with its associated locking overhead. We also need 64-bit atomic read.
 *
 * The lock and the HPET value are stored together and can be read in a
 * single atomic 64-bit read. It is explicitly assumed that arch_spinlock_t
 * is 32 bits in size.
 */</doc>
