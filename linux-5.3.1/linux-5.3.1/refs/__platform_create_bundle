<dec f='linux-5.3.1/include/linux/platform_device.h' l='278' type='struct platform_device * __platform_create_bundle(struct platform_driver * driver, int (*)(struct platform_device *) probe, struct resource * res, unsigned int n_res, const void * data, size_t size, struct module * module)'/>
<def f='linux-5.3.1/drivers/base/platform.c' l='775' ll='814' type='struct platform_device * __platform_create_bundle(struct platform_driver * driver, int (*)(struct platform_device *) probe, struct resource * res, unsigned int n_res, const void * data, size_t size, struct module * module)'/>
<dec f='linux-5.3.1/drivers/base/platform.c' l='815' type='struct platform_device * __platform_create_bundle(struct platform_driver * , int (*)(struct platform_device *) , struct resource * , unsigned int , const void * , size_t , struct module * )'/>
<use f='linux-5.3.1/drivers/base/platform.c' l='815' c='__platform_create_bundle'/>
<use f='linux-5.3.1/drivers/base/platform.c' l='815' u='a'/>
<doc f='linux-5.3.1/drivers/base/platform.c' l='760'>/**
 * __platform_create_bundle - register driver and create corresponding device
 * @driver: platform driver structure
 * @probe: the driver probe routine, probably from an __init section
 * @res: set of resources that needs to be allocated for the device
 * @n_res: number of resources
 * @data: platform specific data for this platform device
 * @size: size of platform specific data
 * @module: module which will be the owner of the driver
 *
 * Use this in legacy-style modules that probe hardware directly and
 * register a single platform device and corresponding platform driver.
 *
 * Returns &amp;struct platform_device pointer on success, or ERR_PTR() on error.
 */</doc>
<use f='linux-5.3.1/drivers/input/serio/i8042.c' l='1615' macro='1' u='c' c='i8042_init'/>
<use f='linux-5.3.1/drivers/mailbox/pcc.c' l='595' macro='1' u='c' c='pcc_init'/>
