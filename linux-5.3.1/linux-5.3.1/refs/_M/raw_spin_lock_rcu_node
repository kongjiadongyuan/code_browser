<dec f='linux-5.3.1/kernel/rcu/rcu.h' l='380'/>
<doc f='linux-5.3.1/kernel/rcu/rcu.h' l='366'>/*
 * Wrappers for the rcu_node::lock acquire and release.
 *
 * Because the rcu_nodes form a tree, the tree traversal locking will observe
 * different lock values, this in turn means that an UNLOCK of one level
 * followed by a LOCK of another level does not imply a full memory barrier;
 * and most importantly transitivity is lost.
 *
 * In order to restore full ordering between tree levels, augment the regular
 * lock acquire functions with smp_mb__after_unlock_lock().
 *
 * As -&gt;lock of struct rcu_node is a __private field, therefore one should use
 * these wrappers rather than directly call raw_spin_{lock,unlock}* on -&gt;lock.
 */</doc>
<use f='linux-5.3.1/kernel/rcu/tree.c' l='1142' u='c'/>
<use f='linux-5.3.1/kernel/rcu/tree.c' l='1302' u='c'/>
<use f='linux-5.3.1/kernel/rcu/tree.c' l='1906' u='c'/>
<use f='linux-5.3.1/kernel/rcu/tree.c' l='2039' u='c'/>
<use f='linux-5.3.1/kernel/rcu/tree.c' l='2925' u='c'/>
<use f='linux-5.3.1/kernel/rcu/tree.c' l='2987' u='c'/>
<use f='linux-5.3.1/kernel/rcu/tree.c' l='3167' u='c'/>
<use f='linux-5.3.1/kernel/rcu/tree_stall.h' l='154' u='c'/>
<use f='linux-5.3.1/kernel/rcu/tree_stall.h' l='626' u='c'/>
<use f='linux-5.3.1/kernel/rcu/tree_exp.h' l='212' u='c'/>
