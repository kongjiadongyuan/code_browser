<def f='linux-5.3.1/include/linux/usb.h' l='1848' ll='1866'/>
<use f='linux-5.3.1/include/linux/usb.h' l='1869' c='usb_sg_init'/>
<use f='linux-5.3.1/include/linux/usb.h' l='1878' c='usb_sg_cancel'/>
<use f='linux-5.3.1/include/linux/usb.h' l='1879' c='usb_sg_wait'/>
<size>88</size>
<doc f='linux-5.3.1/include/linux/usb.h' l='1832'>/**
 * struct usb_sg_request - support for scatter/gather I/O
 * @status: zero indicates success, else negative errno
 * @bytes: counts bytes transferred.
 *
 * These requests are initialized using usb_sg_init(), and then are used
 * as request handles passed to usb_sg_wait() or usb_sg_cancel().  Most
 * members of the request object aren&apos;t for driver access.
 *
 * The status and bytecount values are valid only after usb_sg_wait()
 * returns.  If the status is zero, then the bytecount matches the total
 * from the request.
 *
 * After an error completion, drivers may need to clear a halt condition
 * on the endpoint.
 */</doc>
<mbr r='usb_sg_request::status' o='0' t='int'/>
<mbr r='usb_sg_request::bytes' o='64' t='size_t'/>
<mbr r='usb_sg_request::lock' o='128' t='spinlock_t'/>
<mbr r='usb_sg_request::dev' o='192' t='struct usb_device *'/>
<mbr r='usb_sg_request::pipe' o='256' t='int'/>
<mbr r='usb_sg_request::entries' o='288' t='int'/>
<mbr r='usb_sg_request::urbs' o='320' t='struct urb **'/>
<mbr r='usb_sg_request::count' o='384' t='int'/>
<mbr r='usb_sg_request::complete' o='448' t='struct completion'/>
<use f='linux-5.3.1/drivers/usb/core/message.c' l='259' c='sg_clean'/>
<use f='linux-5.3.1/drivers/usb/core/message.c' l='273' c='sg_complete'/>
<use f='linux-5.3.1/drivers/usb/core/message.c' l='367' c='usb_sg_init'/>
<use f='linux-5.3.1/drivers/usb/core/message.c' l='515' c='usb_sg_wait'/>
<use f='linux-5.3.1/drivers/usb/core/message.c' l='585' c='usb_sg_cancel'/>
<size>88</size>
<use f='linux-5.3.1/drivers/usb/storage/usb.h' l='129'/>
<size>88</size>
