<dec f='linux-5.3.1/include/linux/mmzone.h' l='806' type='void wakeup_kswapd(struct zone * zone, gfp_t gfp_mask, int order, enum zone_type classzone_idx)'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='3295' u='c' c='rmqueue'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='4160' u='c' c='wake_all_kswapds'/>
<def f='linux-5.3.1/mm/vmscan.c' l='3890' ll='3930' type='void wakeup_kswapd(struct zone * zone, gfp_t gfp_flags, int order, enum zone_type classzone_idx)'/>
<doc f='linux-5.3.1/mm/vmscan.c' l='3883'>/*
 * A zone is low on free memory or too fragmented for high-order memory.  If
 * kswapd should reclaim (direct reclaim is deferred), wake it up for the zone&apos;s
 * pgdat.  It will wake up kcompactd after reclaiming memory.  If kswapd reclaim
 * has failed or is not needed, still wake up kcompactd if only compaction is
 * needed.
 */</doc>
