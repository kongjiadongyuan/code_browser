<dec f='linux-5.3.1/block/blk-rq-qos.h' l='124' type='void rq_qos_wait(struct rq_wait * rqw, void * private_data, acquire_inflight_cb_t * acquire_inflight_cb, cleanup_cb_t * cleanup_cb)'/>
<def f='linux-5.3.1/block/blk-rq-qos.c' l='227' ll='271' type='void rq_qos_wait(struct rq_wait * rqw, void * private_data, acquire_inflight_cb_t * acquire_inflight_cb, cleanup_cb_t * cleanup_cb)'/>
<doc f='linux-5.3.1/block/blk-rq-qos.c' l='211'>/**
 * rq_qos_wait - throttle on a rqw if we need to
 * @rqw: rqw to throttle on
 * @private_data: caller provided specific data
 * @acquire_inflight_cb: inc the rqw-&gt;inflight counter if we can
 * @cleanup_cb: the callback to cleanup in case we race with a waker
 *
 * This provides a uniform place for the rq_qos users to do their throttling.
 * Since you can end up with a lot of things sleeping at once, this manages the
 * waking up based on the resources available.  The acquire_inflight_cb should
 * inc the rqw-&gt;inflight if we have the ability to do so, or return false if not
 * and then we will sleep until the room becomes available.
 *
 * cleanup_cb is in case that we race with a waker and need to cleanup the
 * inflight count accordingly.
 */</doc>
