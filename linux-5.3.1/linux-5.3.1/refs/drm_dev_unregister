<dec f='linux-5.3.1/include/drm/drm_drv.h' l='736' type='void drm_dev_unregister(struct drm_device * dev)'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_drv.c' l='450' u='c' c='drm_put_dev'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_drv.c' l='514' u='c' c='drm_dev_unplug'/>
<def f='linux-5.3.1/drivers/gpu/drm/drm_drv.c' l='1026' ll='1049' type='void drm_dev_unregister(struct drm_device * dev)'/>
<dec f='linux-5.3.1/drivers/gpu/drm/drm_drv.c' l='1050' type='void drm_dev_unregister(struct drm_device * )'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_drv.c' l='1050' c='drm_dev_unregister'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_drv.c' l='1050' u='a'/>
<doc f='linux-5.3.1/drivers/gpu/drm/drm_drv.c' l='1012'>/**
 * drm_dev_unregister - Unregister DRM device
 * @dev: Device to unregister
 *
 * Unregister the DRM device from the system. This does the reverse of
 * drm_dev_register() but does not deallocate the device. The caller must call
 * drm_dev_put() to drop their final reference.
 *
 * A special form of unregistering for hotpluggable devices is drm_dev_unplug(),
 * which can be called while there are still open users of @dev.
 *
 * This should be called first in the device teardown code to make sure
 * userspace can&apos;t access the device instance any more.
 */</doc>
