<dec f='linux-5.3.1/include/net/udp.h' l='295' type='__poll_t udp_poll(struct file * file, struct socket * sock, poll_table * wait)'/>
<use f='linux-5.3.1/net/ipv4/af_inet.c' l='1028'/>
<use f='linux-5.3.1/net/ipv4/af_inet.c' l='1028'/>
<def f='linux-5.3.1/net/ipv4/udp.c' l='2707' ll='2722' type='__poll_t udp_poll(struct file * file, struct socket * sock, poll_table * wait)'/>
<dec f='linux-5.3.1/net/ipv4/udp.c' l='2723' type='__poll_t udp_poll(struct file * , struct socket * , poll_table * )'/>
<use f='linux-5.3.1/net/ipv4/udp.c' l='2723' c='udp_poll'/>
<use f='linux-5.3.1/net/ipv4/udp.c' l='2723' u='a'/>
<doc f='linux-5.3.1/net/ipv4/udp.c' l='2694'>/**
 * 	udp_poll - wait for a UDP event.
 *	@file - file struct
 *	@sock - socket
 *	@wait - poll table
 *
 *	This is same as datagram poll, except for the special case of
 *	blocking sockets. If application is using a blocking fd
 *	and a packet with checksum error is in the queue;
 *	then it could get return from select indicating data available
 *	but then block when reading it. Add special case code
 *	to work around these arguably broken applications.
 */</doc>
<use f='linux-5.3.1/net/ipv6/af_inet6.c' l='643'/>
<use f='linux-5.3.1/net/ipv6/af_inet6.c' l='643'/>
