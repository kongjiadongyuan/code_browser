<dec f='linux-5.3.1/mm/internal.h' l='298' type='void munlock_vma_pages_range(struct vm_area_struct * vma, unsigned long start, unsigned long end)'/>
<use f='linux-5.3.1/mm/internal.h' l='302' u='c' c='munlock_vma_pages_all'/>
<def f='linux-5.3.1/mm/mlock.c' l='445' ll='508' type='void munlock_vma_pages_range(struct vm_area_struct * vma, unsigned long start, unsigned long end)'/>
<use f='linux-5.3.1/mm/mlock.c' l='576' u='c' c='mlock_fixup'/>
<doc f='linux-5.3.1/mm/mlock.c' l='427'>/*
 * munlock_vma_pages_range() - munlock all pages in the vma range.&apos;
 * @vma - vma containing range to be munlock()ed.
 * @start - start address in @vma of the range
 * @end - end of range in @vma.
 *
 *  For mremap(), munmap() and exit().
 *
 * Called with @vma VM_LOCKED.
 *
 * Returns with VM_LOCKED cleared.  Callers must be prepared to
 * deal with this.
 *
 * We don&apos;t save and restore VM_LOCKED here because pages are
 * still on lru.  In unmap path, pages might be scanned by reclaim
 * and re-mlocked by try_to_{munlock|unmap} before we unmap and
 * free them.  This will result in freeing mlocked pages.
 */</doc>
<use f='linux-5.3.1/mm/mmap.c' l='2962' u='c' c='__do_sys_remap_file_pages'/>
