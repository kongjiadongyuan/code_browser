<dec f='linux-5.3.1/include/linux/usb.h' l='768' type='void usb_autopm_put_interface_async(struct usb_interface * intf)'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='221' u='c' c='usbhid_restart_out_queue'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='260' u='c' c='usbhid_restart_ctrl_queue'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='468' u='c' c='hid_irq_out'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='519' u='c' c='hid_ctrl'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='577' u='c' c='__usbhid_submit_report'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='628' u='c' c='__usbhid_submit_report'/>
<def f='linux-5.3.1/drivers/usb/core/driver.c' l='1653' ll='1663' type='void usb_autopm_put_interface_async(struct usb_interface * intf)'/>
<dec f='linux-5.3.1/drivers/usb/core/driver.c' l='1664' type='void usb_autopm_put_interface_async(struct usb_interface * )'/>
<use f='linux-5.3.1/drivers/usb/core/driver.c' l='1664' c='usb_autopm_put_interface_async'/>
<use f='linux-5.3.1/drivers/usb/core/driver.c' l='1664' u='a'/>
<doc f='linux-5.3.1/drivers/usb/core/driver.c' l='1638'>/**
 * usb_autopm_put_interface_async - decrement a USB interface&apos;s PM-usage counter
 * @intf: the usb_interface whose counter should be decremented
 *
 * This routine does much the same thing as usb_autopm_put_interface():
 * It decrements @intf&apos;s usage counter and schedules a delayed
 * autosuspend request if the counter is &lt;= 0.  The difference is that it
 * does not perform any synchronization; callers should hold a private
 * lock and handle all synchronization issues themselves.
 *
 * Typically a driver would call this routine during an URB&apos;s completion
 * handler, if no more URBs were pending.
 *
 * This routine can run in atomic context.
 */</doc>
<use f='linux-5.3.1/drivers/usb/core/hub.c' l='665' u='c' c='kick_hub_wq'/>
<use f='linux-5.3.1/drivers/usb/core/hub.c' l='1270' u='c' c='hub_activate'/>
