<dec f='linux-5.3.1/include/linux/clk.h' l='696' type='int clk_set_parent(struct clk * clk, struct clk * parent)'/>
<doc f='linux-5.3.1/include/linux/clk.h' l='689'>/**
 * clk_set_parent - set the parent clock source for this clock
 * @clk: clock source
 * @parent: parent clock source
 *
 * Returns success (0) or negative errno.
 */</doc>
<def f='linux-5.3.1/drivers/clk/clk.c' l='2530' ll='2551' type='int clk_set_parent(struct clk * clk, struct clk * parent)'/>
<dec f='linux-5.3.1/drivers/clk/clk.c' l='2552' type='int clk_set_parent(struct clk * , struct clk * )'/>
<use f='linux-5.3.1/drivers/clk/clk.c' l='2552' c='clk_set_parent'/>
<use f='linux-5.3.1/drivers/clk/clk.c' l='2552' u='a'/>
<doc f='linux-5.3.1/drivers/clk/clk.c' l='2513'>/**
 * clk_set_parent - switch the parent of a mux clk
 * @clk: the mux clk whose input we are switching
 * @parent: the new input to clk
 *
 * Re-parent clk to use parent as its new input source.  If clk is in
 * prepared state, the clk will get enabled for the duration of this call. If
 * that&apos;s not acceptable for a specific clk (Eg: the consumer can&apos;t handle
 * that, the reparenting is glitchy in hardware, etc), use the
 * CLK_SET_PARENT_GATE flag to allow reparenting only when clk is unprepared.
 *
 * After successfully changing clk&apos;s parent clk_set_parent will update the
 * clk topology, sysfs topology and propagate rate recalculation via
 * __clk_recalc_rates.
 *
 * Returns 0 on success, -EERROR otherwise.
 */</doc>
