<dec f='linux-5.3.1/include/linux/percpu.h' l='137' type='phys_addr_t per_cpu_ptr_to_phys(void * addr)'/>
<use f='linux-5.3.1/arch/x86/include/asm/desc.h' l='81' u='c' c='get_cpu_gdt_paddr'/>
<use f='linux-5.3.1/arch/x86/kernel/irq_64.c' l='50' u='c' c='map_irq_stack'/>
<use f='linux-5.3.1/arch/x86/mm/cpu_entry_area.c' l='52' u='c' c='cea_map_percpu_pages'/>
<use f='linux-5.3.1/arch/x86/mm/pti.c' l='458' u='c' c='pti_clone_user_shared'/>
<use f='linux-5.3.1/drivers/base/cpu.c' l='158' u='c' c='show_crash_notes'/>
<def f='linux-5.3.1/mm/percpu.c' l='2061' ll='2103' type='phys_addr_t per_cpu_ptr_to_phys(void * addr)'/>
<doc f='linux-5.3.1/mm/percpu.c' l='2038'>/**
 * per_cpu_ptr_to_phys - convert translated percpu address to physical address
 * @addr: the address to be converted to physical address
 *
 * Given @addr which is dereferenceable address obtained via one of
 * percpu access macros, this function translates it into its physical
 * address.  The caller is responsible for ensuring @addr stays valid
 * until this function finishes.
 *
 * percpu allocator has special setup for the first chunk, which currently
 * supports either embedding in linear address space or vmalloc mapping,
 * and, from the second one, the backing allocator (currently either vm or
 * km) provides translation.
 *
 * The addr can be translated simply without checking if it falls into the
 * first chunk. But the current code reflects better how percpu allocator
 * actually works, and the verification can discover both bugs in percpu
 * allocator itself and per_cpu_ptr_to_phys() callers. So we keep current
 * code.
 *
 * RETURNS:
 * The physical address for @addr.
 */</doc>
