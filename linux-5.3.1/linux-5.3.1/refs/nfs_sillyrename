<dec f='linux-5.3.1/fs/nfs/internal.h' l='558' type='int nfs_sillyrename(struct inode * dir, struct dentry * dentry)'/>
<use f='linux-5.3.1/fs/nfs/dir.c' l='1892' u='c' c='nfs_unlink'/>
<use f='linux-5.3.1/fs/nfs/dir.c' l='2073' u='c' c='nfs_rename'/>
<def f='linux-5.3.1/fs/nfs/unlink.c' l='430' ll='521' type='int nfs_sillyrename(struct inode * dir, struct dentry * dentry)'/>
<doc f='linux-5.3.1/fs/nfs/unlink.c' l='409'>/**
 * nfs_sillyrename - Perform a silly-rename of a dentry
 * @dir: inode of directory that contains dentry
 * @dentry: dentry to be sillyrenamed
 *
 * NFSv2/3 is stateless and the server doesn&apos;t know when the client is
 * holding a file open. To prevent application problems when a file is
 * unlinked while it&apos;s still open, the client performs a &quot;silly-rename&quot;.
 * That is, it renames the file to a hidden file in the same directory,
 * and only performs the unlink once the last reference to it is put.
 *
 * The final cleanup is done during dentry_iput.
 *
 * (Note: NFSv4 is stateful, and has opens, so in theory an NFSv4 server
 * could take responsibility for keeping open files referenced.  The server
 * would also need to ensure that opened-but-deleted files were kept over
 * reboots.  However, we may not assume a server does so.  (RFC 5661
 * does provide an OPEN4_RESULT_PRESERVE_UNLINKED flag that a server can
 * use to advertise that it does this; some day we may take advantage of
 * it.))
 */</doc>
