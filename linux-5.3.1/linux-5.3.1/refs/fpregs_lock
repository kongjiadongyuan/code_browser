<def f='linux-5.3.1/arch/x86/include/asm/fpu/api.h' l='33' ll='37' type='void fpregs_lock()'/>
<use f='linux-5.3.1/arch/x86/include/asm/pgtable.h' l='150' u='c' c='write_pkru'/>
<doc f='linux-5.3.1/arch/x86/include/asm/fpu/api.h' l='27'>/*
 * Use fpregs_lock() while editing CPU&apos;s FPU registers or fpu-&gt;state.
 * A context switch will (and softirq might) save CPU&apos;s FPU registers to
 * fpu-&gt;state and set TIF_NEED_FPU_LOAD leaving CPU&apos;s FPU registers in
 * a random state.
 */</doc>
<use f='linux-5.3.1/arch/x86/kernel/fpu/core.c' l='125' u='c' c='fpu__save'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/core.c' l='193' u='c' c='fpu__copy'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/core.c' l='299' u='c' c='copy_init_fpstate_to_fpregs'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/signal.c' l='65' u='c' c='save_fsave_header'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/signal.c' l='188' u='c' c='copy_fpstate_to_sigframe'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/signal.c' l='346' u='c' c='__fpu__restore_sig'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/signal.c' l='375' u='c' c='__fpu__restore_sig'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/signal.c' l='389' u='c' c='__fpu__restore_sig'/>
<use f='linux-5.3.1/arch/x86/kernel/fpu/signal.c' l='401' u='c' c='__fpu__restore_sig'/>
