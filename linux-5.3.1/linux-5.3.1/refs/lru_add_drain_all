<dec f='linux-5.3.1/include/linux/swap.h' l='340' type='void lru_add_drain_all()'/>
<use f='linux-5.3.1/fs/block_dev.c' l='97' u='c' c='invalidate_bdev'/>
<use f='linux-5.3.1/mm/compaction.c' l='2445' u='c' c='compact_nodes'/>
<use f='linux-5.3.1/mm/compaction.c' l='2476' u='c' c='sysfs_compact_node'/>
<use f='linux-5.3.1/mm/fadvise.c' l='170' u='c' c='generic_fadvise'/>
<use f='linux-5.3.1/mm/memfd.c' l='81' u='c' c='memfd_wait_for_pins'/>
<use f='linux-5.3.1/mm/migrate.c' l='71' u='c' c='migrate_prep'/>
<def f='linux-5.3.1/mm/swap.c' l='668' ll='702' type='void lru_add_drain_all()'/>
<doc f='linux-5.3.1/mm/swap.c' l='661'>/*
 * Doesn&apos;t need any cpu hotplug locking because we do rely on per-cpu
 * kworkers being shut down before our page_alloc_cpu_dead callback is
 * executed on the offlined cpu.
 * Calling this function with cpu hotplug locks held can actually lead
 * to obscure indirect dependencies via WQ context.
 */</doc>
