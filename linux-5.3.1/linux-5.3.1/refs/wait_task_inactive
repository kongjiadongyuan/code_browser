<dec f='linux-5.3.1/include/linux/sched.h' l='1705' type='unsigned long wait_task_inactive(struct task_struct * , long match_state)'/>
<use f='linux-5.3.1/fs/coredump.c' l='466' u='c' c='coredump_wait'/>
<use f='linux-5.3.1/kernel/kthread.c' l='399' u='c' c='__kthread_bind_mask'/>
<use f='linux-5.3.1/kernel/kthread.c' l='525' u='c' c='kthread_park'/>
<use f='linux-5.3.1/kernel/ptrace.c' l='253' u='c' c='ptrace_check_attach'/>
<def f='linux-5.3.1/kernel/sched/core.c' l='1772' ll='1862' type='unsigned long wait_task_inactive(struct task_struct * p, long match_state)'/>
<doc f='linux-5.3.1/kernel/sched/core.c' l='1756'>/*
 * wait_task_inactive - wait for a thread to unschedule.
 *
 * If @match_state is nonzero, it&apos;s the @p-&gt;state value just checked and
 * not expected to change.  If it changes, i.e. @p might have woken up,
 * then return zero.  When we succeed in waiting for @p to be off its CPU,
 * we return a positive number (its total switch count).  If a second call
 * a short while later returns the same number, the caller can be sure that
 * @p has remained unscheduled the whole time.
 *
 * The caller must ensure that the task *will* unschedule sometime soon,
 * else this function might spin for a *long* time. This function can&apos;t
 * be called with interrupts off, or it may introduce deadlock with
 * smp_call_function() if an IPI is sent by the same process we are
 * waiting to become inactive.
 */</doc>
<use f='linux-5.3.1/kernel/smpboot.c' l='205' u='c' c='__smpboot_create_thread'/>
<use f='linux-5.3.1/lib/syscall.c' l='74' u='c' c='task_current_syscall'/>
<use f='linux-5.3.1/lib/syscall.c' l='77' u='c' c='task_current_syscall'/>
