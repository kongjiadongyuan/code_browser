<dec f='linux-5.3.1/include/linux/mm.h' l='2562' type='int vm_map_pages(struct vm_area_struct * vma, struct page ** pages, unsigned long num)'/>
<def f='linux-5.3.1/mm/memory.c' l='1549' ll='1553' type='int vm_map_pages(struct vm_area_struct * vma, struct page ** pages, unsigned long num)'/>
<dec f='linux-5.3.1/mm/memory.c' l='1554' type='int vm_map_pages(struct vm_area_struct * , struct page ** , unsigned long )'/>
<use f='linux-5.3.1/mm/memory.c' l='1554' c='vm_map_pages'/>
<use f='linux-5.3.1/mm/memory.c' l='1554' u='a'/>
<doc f='linux-5.3.1/mm/memory.c' l='1531'>/**
 * vm_map_pages - maps range of kernel pages starts with non zero offset
 * @vma: user vma to map to
 * @pages: pointer to array of source kernel pages
 * @num: number of pages in page array
 *
 * Maps an object consisting of @num pages, catering for the user&apos;s
 * requested vm_pgoff
 *
 * If we fail to insert any page into the vma, the function will return
 * immediately leaving any previously inserted pages present.  Callers
 * from the mmap handler may immediately return the error as their caller
 * will destroy the vma, removing any successfully inserted pages. Other
 * callers should make their own arrangements for calling unmap_region().
 *
 * Context: Process context. Called by mmap handlers.
 * Return: 0 on success and error code otherwise.
 */</doc>
