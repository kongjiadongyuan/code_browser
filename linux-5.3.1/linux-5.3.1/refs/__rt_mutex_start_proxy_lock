<dec f='linux-5.3.1/kernel/locking/rtmutex_common.h' l='139' type='int __rt_mutex_start_proxy_lock(struct rt_mutex * lock, struct rt_mutex_waiter * waiter, struct task_struct * task)'/>
<use f='linux-5.3.1/kernel/futex.c' l='2892' u='c' c='futex_lock_pi'/>
<def f='linux-5.3.1/kernel/locking/rtmutex.c' l='1749' ll='1777' type='int __rt_mutex_start_proxy_lock(struct rt_mutex * lock, struct rt_mutex_waiter * waiter, struct task_struct * task)'/>
<use f='linux-5.3.1/kernel/locking/rtmutex.c' l='1805' u='c' c='rt_mutex_start_proxy_lock'/>
<doc f='linux-5.3.1/kernel/locking/rtmutex.c' l='1730'>/**
 * __rt_mutex_start_proxy_lock() - Start lock acquisition for another task
 * @lock:		the rt_mutex to take
 * @waiter:		the pre-initialized rt_mutex_waiter
 * @task:		the task to prepare
 *
 * Starts the rt_mutex acquire; it enqueues the @waiter and does deadlock
 * detection. It does not wait, see rt_mutex_wait_proxy_lock() for that.
 *
 * NOTE: does _NOT_ remove the @waiter on failure; must either call
 * rt_mutex_wait_proxy_lock() or rt_mutex_cleanup_proxy_lock() after this.
 *
 * Returns:
 *  0 - task blocked on lock
 *  1 - acquired the lock for task, caller should wake it up
 * &lt;0 - error
 *
 * Special API call for PI-futex support.
 */</doc>
