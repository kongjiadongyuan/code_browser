<dec f='linux-5.3.1/include/linux/blkdev.h' l='1689' type='int bdev_write_page(struct block_device * , sector_t , struct page * , struct writeback_control * )'/>
<def f='linux-5.3.1/fs/block_dev.c' l='737' ll='760' type='int bdev_write_page(struct block_device * bdev, sector_t sector, struct page * page, struct writeback_control * wbc)'/>
<dec f='linux-5.3.1/fs/block_dev.c' l='761' type='int bdev_write_page(struct block_device * , sector_t , struct page * , struct writeback_control * )'/>
<use f='linux-5.3.1/fs/block_dev.c' l='761' c='bdev_write_page'/>
<use f='linux-5.3.1/fs/block_dev.c' l='761' u='a'/>
<doc f='linux-5.3.1/fs/block_dev.c' l='718'>/**
 * bdev_write_page() - Start writing a page to a block device
 * @bdev: The device to write the page to
 * @sector: The offset on the device to write the page to (need not be aligned)
 * @page: The page to write
 * @wbc: The writeback_control for the write
 *
 * On entry, the page should be locked and not currently under writeback.
 * On exit, if the write started successfully, the page will be unlocked and
 * under writeback.  If the write failed already (eg the driver failed to
 * queue the page to the device), the page will still be locked.  If the
 * caller is a -&gt;writepage implementation, it will need to unlock the page.
 *
 * Errors returned by this function are usually &quot;soft&quot;, eg out of memory, or
 * queue full; callers should try a different route to write this page rather
 * than propagate an error back up the stack.
 *
 * Return: negative errno if an error occurs, 0 if submission was successful.
 */</doc>
<use f='linux-5.3.1/fs/mpage.c' l='632' u='c' c='__mpage_writepage'/>
<use f='linux-5.3.1/mm/page_io.c' l='326' u='c' c='__swap_writepage'/>
