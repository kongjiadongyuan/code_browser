<def f='linux-5.3.1/include/linux/rhashtable.h' l='327' ll='333' type='void rht_lock(struct bucket_table * tbl, struct rhash_lock_head ** bkt)'/>
<use f='linux-5.3.1/include/linux/rhashtable.h' l='730' u='c' c='__rhashtable_insert_fast'/>
<use f='linux-5.3.1/include/linux/rhashtable.h' l='1009' u='c' c='__rhashtable_remove_fast_one'/>
<use f='linux-5.3.1/include/linux/rhashtable.h' l='1168' u='c' c='__rhashtable_replace_fast'/>
<doc f='linux-5.3.1/include/linux/rhashtable.h' l='308'>/*
 * We lock a bucket by setting BIT(0) in the pointer - this is always
 * zero in real pointers.  The NULLS mark is never stored in the bucket,
 * rather we store NULL if the bucket is empty.
 * bit_spin_locks do not handle contention well, but the whole point
 * of the hashtable design is to achieve minimum per-bucket contention.
 * A nested hash table might not have a bucket pointer.  In that case
 * we cannot get a lock.  For remove and replace the bucket cannot be
 * interesting and doesn&apos;t need locking.
 * For insert we allocate the bucket if this is the last bucket_table,
 * and then take the lock.
 * Sometimes we unlock a bucket by writing a new pointer there.  In that
 * case we don&apos;t need to unlock, but we do need to reset state such as
 * local_bh. For that we have rht_assign_unlock().  As rcu_assign_pointer()
 * provides the same release semantics that bit_spin_unlock() provides,
 * this is safe.
 * When we write to a bucket without unlocking, we use rht_assign_locked().
 */</doc>
<use f='linux-5.3.1/lib/rhashtable.c' l='274' u='c' c='rhashtable_rehash_chain'/>
<use f='linux-5.3.1/lib/rhashtable.c' l='603' u='c' c='rhashtable_try_insert'/>
