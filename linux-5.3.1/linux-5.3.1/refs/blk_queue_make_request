<dec f='linux-5.3.1/include/linux/blkdev.h' l='1046' type='void blk_queue_make_request(struct request_queue * , make_request_fn * )'/>
<use f='linux-5.3.1/block/blk-mq.c' l='2888' u='c' c='blk_mq_init_allocated_queue'/>
<def f='linux-5.3.1/block/blk-settings.c' l='110' ll='121' type='void blk_queue_make_request(struct request_queue * q, make_request_fn * mfn)'/>
<dec f='linux-5.3.1/block/blk-settings.c' l='122' type='void blk_queue_make_request(struct request_queue * , make_request_fn * )'/>
<use f='linux-5.3.1/block/blk-settings.c' l='122' c='blk_queue_make_request'/>
<use f='linux-5.3.1/block/blk-settings.c' l='122' u='a'/>
<doc f='linux-5.3.1/block/blk-settings.c' l='88'>/**
 * blk_queue_make_request - define an alternate make_request function for a device
 * @q:  the request queue for the device to be affected
 * @mfn: the alternate make_request function
 *
 * Description:
 *    The normal way for &amp;struct bios to be passed to a device
 *    driver is for them to be collected into requests on a request
 *    queue, and then to allow the device driver to select requests
 *    off that queue when it is ready.  This works well for many block
 *    devices. However some block devices (typically virtual devices
 *    such as md or lvm) do not benefit from the processing on the
 *    request queue, and are served best by having the requests passed
 *    directly to them.  This can be achieved by providing a function
 *    to blk_queue_make_request().
 *
 * Caveat:
 *    The driver that does this *must* be able to deal appropriately
 *    with buffers in &quot;highmemory&quot;. This can be accomplished by either calling
 *    kmap_atomic() to get a temporary kernel mapping, or by calling
 *    blk_queue_bounce() to create a buffer in normal memory.
 **/</doc>
<use f='linux-5.3.1/drivers/md/dm.c' l='2288' u='c' c='dm_setup_md_queue'/>
<use f='linux-5.3.1/drivers/md/md.c' l='5390' u='c' c='md_alloc'/>
