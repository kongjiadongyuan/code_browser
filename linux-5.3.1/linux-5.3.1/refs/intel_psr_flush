<dec f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_psr.h' l='27' type='void intel_psr_flush(struct drm_i915_private * dev_priv, unsigned int frontbuffer_bits, enum fb_op_origin origin)'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_frontbuffer.c' l='111' u='c' c='intel_frontbuffer_flush'/>
<def f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_psr.c' l='1175' ll='1200' type='void intel_psr_flush(struct drm_i915_private * dev_priv, unsigned int frontbuffer_bits, enum fb_op_origin origin)'/>
<doc f='linux-5.3.1/drivers/gpu/drm/i915/display/intel_psr.c' l='1162'>/**
 * intel_psr_flush - Flush PSR
 * @dev_priv: i915 device
 * @frontbuffer_bits: frontbuffer plane tracking bits
 * @origin: which operation caused the flush
 *
 * Since the hardware frontbuffer tracking has gaps we need to integrate
 * with the software frontbuffer tracking. This function gets called every
 * time frontbuffer rendering has completed and flushed out to memory. PSR
 * can be enabled again if no other frontbuffer relevant to PSR is dirty.
 *
 * Dirty frontbuffers relevant to PSR are tracked in busy_frontbuffer_bits.
 */</doc>
