<dec f='linux-5.3.1/include/linux/netdevice.h' l='2614' type='int dev_open(struct net_device * dev, struct netlink_ext_ack * extack)'/>
<def f='linux-5.3.1/net/core/dev.c' l='1434' ll='1449' type='int dev_open(struct net_device * dev, struct netlink_ext_ack * extack)'/>
<dec f='linux-5.3.1/net/core/dev.c' l='1450' type='int dev_open(struct net_device * , struct netlink_ext_ack * )'/>
<use f='linux-5.3.1/net/core/dev.c' l='1450' c='dev_open'/>
<use f='linux-5.3.1/net/core/dev.c' l='1450' u='a'/>
<doc f='linux-5.3.1/net/core/dev.c' l='1421'>/**
 *	dev_open	- prepare an interface for use.
 *	@dev: device to open
 *	@extack: netlink extended ack
 *
 *	Takes a device from down to up state. The device&apos;s private open
 *	function is invoked and then the multicast lists are loaded. Finally
 *	the device is moved into the up state and a %NETDEV_UP message is
 *	sent to the netdev notifier chain.
 *
 *	Calling this function on an active interface is a nop. On a failure
 *	a negative errno code is returned.
 */</doc>
<use f='linux-5.3.1/net/core/netpoll.c' l='667' u='c' c='netpoll_setup'/>
<use f='linux-5.3.1/net/ipv4/ipmr.c' l='505' u='c' c='ipmr_new_tunnel'/>
<use f='linux-5.3.1/net/ipv4/ipmr.c' l='588' u='c' c='ipmr_reg_vif'/>
<use f='linux-5.3.1/net/ipv6/addrconf.c' l='2864' u='c' c='addrconf_set_dstaddr'/>
