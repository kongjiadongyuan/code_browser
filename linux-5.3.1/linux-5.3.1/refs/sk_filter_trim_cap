<dec f='linux-5.3.1/include/linux/filter.h' l='793' type='int sk_filter_trim_cap(struct sock * sk, struct sk_buff * skb, unsigned int cap)'/>
<use f='linux-5.3.1/include/linux/filter.h' l='796' u='c' c='sk_filter'/>
<def f='linux-5.3.1/net/core/filter.c' l='90' ll='126' type='int sk_filter_trim_cap(struct sock * sk, struct sk_buff * skb, unsigned int cap)'/>
<dec f='linux-5.3.1/net/core/filter.c' l='127' type='int sk_filter_trim_cap(struct sock * , struct sk_buff * , unsigned int )'/>
<use f='linux-5.3.1/net/core/filter.c' l='127' c='sk_filter_trim_cap'/>
<use f='linux-5.3.1/net/core/filter.c' l='127' u='a'/>
<doc f='linux-5.3.1/net/core/filter.c' l='77'>/**
 *	sk_filter_trim_cap - run a packet through a socket filter
 *	@sk: sock associated with &amp;sk_buff
 *	@skb: buffer to filter
 *	@cap: limit on how short the eBPF program may trim the packet
 *
 * Run the eBPF program and then cut skb-&gt;data to correct size returned by
 * the program. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller
 * than pkt_len we keep whole skb-&gt;data. This is the socket level
 * wrapper to BPF_PROG_RUN. It returns 0 if the packet should
 * be accepted or -EPERM if the packet should be tossed.
 *
 */</doc>
<use f='linux-5.3.1/net/core/sock.c' l='503' u='c' c='__sk_receive_skb'/>
<use f='linux-5.3.1/net/ipv4/tcp_ipv4.c' l='1750' u='c' c='tcp_filter'/>
<use f='linux-5.3.1/net/ipv4/udp.c' l='2048' u='c' c='udp_queue_rcv_one_skb'/>
<use f='linux-5.3.1/net/ipv6/udp.c' l='665' u='c' c='udpv6_queue_rcv_one_skb'/>
