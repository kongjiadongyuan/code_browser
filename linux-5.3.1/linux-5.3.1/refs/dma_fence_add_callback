<dec f='linux-5.3.1/include/linux/dma-fence.h' l='344' type='int dma_fence_add_callback(struct dma_fence * fence, struct dma_fence_cb * cb, dma_fence_func_t func)'/>
<use f='linux-5.3.1/drivers/dma-buf/dma-buf.c' l='251' u='c' c='dma_buf_poll'/>
<use f='linux-5.3.1/drivers/dma-buf/dma-buf.c' l='295' u='c' c='dma_buf_poll'/>
<use f='linux-5.3.1/drivers/dma-buf/dma-fence-array.c' l='64' u='c' c='dma_fence_array_enable_signaling'/>
<use f='linux-5.3.1/drivers/dma-buf/dma-fence-chain.c' l='153' u='c' c='dma_fence_chain_enable_signaling'/>
<def f='linux-5.3.1/drivers/dma-buf/dma-fence.c' l='344' ll='383' type='int dma_fence_add_callback(struct dma_fence * fence, struct dma_fence_cb * cb, dma_fence_func_t func)'/>
<dec f='linux-5.3.1/drivers/dma-buf/dma-fence.c' l='384' type='int dma_fence_add_callback(struct dma_fence * , struct dma_fence_cb * , dma_fence_func_t )'/>
<use f='linux-5.3.1/drivers/dma-buf/dma-fence.c' l='384' c='dma_fence_add_callback'/>
<use f='linux-5.3.1/drivers/dma-buf/dma-fence.c' l='384' u='a'/>
<use f='linux-5.3.1/drivers/dma-buf/dma-fence.c' l='608' u='c' c='dma_fence_wait_any_timeout'/>
<doc f='linux-5.3.1/drivers/dma-buf/dma-fence.c' l='319'>/**
 * dma_fence_add_callback - add a callback to be called when the fence
 * is signaled
 * @fence: the fence to wait on
 * @cb: the callback to register
 * @func: the function to call
 *
 * @cb will be initialized by dma_fence_add_callback(), no initialization
 * by the caller is required. Any number of callbacks can be registered
 * to a fence, but a callback can only be registered to one fence at a time.
 *
 * Note that the callback can be called from an atomic context.  If
 * fence is already signaled, this function will return -ENOENT (and
 * *not* call the callback).
 *
 * Add a software callback to the fence. Same restrictions apply to
 * refcount as it does to dma_fence_wait(), however the caller doesn&apos;t need to
 * keep a refcount to fence afterward dma_fence_add_callback() has returned:
 * when software access is enabled, the creator of the fence is required to keep
 * the fence alive until after it signals with dma_fence_signal(). The callback
 * itself can be called from irq context.
 *
 * Returns 0 in case of success, -ENOENT if the fence is already signaled
 * and -EINVAL in case of error.
 */</doc>
<use f='linux-5.3.1/drivers/dma-buf/sync_file.c' l='315' u='c' c='sync_file_poll'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_syncobj.c' l='886' u='c' c='drm_syncobj_array_wait_timeout'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_client_blt.c' l='186' u='c' c='clear_pages_worker'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_request.c' l='1444' u='c' c='i915_request_wait'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_sw_fence.c' l='466' u='c' c='i915_sw_fence_await_dma_fence'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_sw_fence.c' l='500' u='c' c='__i915_sw_fence_await_dma_fence'/>
