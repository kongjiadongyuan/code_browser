<dec f='linux-5.3.1/include/linux/hrtimer.h' l='469' type='int schedule_hrtimeout_range(ktime_t * expires, u64 delta, const enum hrtimer_mode mode)'/>
<use f='linux-5.3.1/include/linux/freezer.h' l='239' u='c' c='freezable_schedule_hrtimeout_range'/>
<use f='linux-5.3.1/fs/eventpoll.c' l='1915' u='c' c='ep_poll'/>
<use f='linux-5.3.1/fs/select.c' l='243' u='c' c='poll_schedule_timeout'/>
<def f='linux-5.3.1/kernel/time/hrtimer.c' l='1980' ll='1985' type='int schedule_hrtimeout_range(ktime_t * expires, u64 delta, const enum hrtimer_mode mode)'/>
<dec f='linux-5.3.1/kernel/time/hrtimer.c' l='1986' type='int schedule_hrtimeout_range(ktime_t * , u64 , const enum hrtimer_mode )'/>
<use f='linux-5.3.1/kernel/time/hrtimer.c' l='1986' c='schedule_hrtimeout_range'/>
<use f='linux-5.3.1/kernel/time/hrtimer.c' l='1986' u='a'/>
<use f='linux-5.3.1/kernel/time/hrtimer.c' l='2017' u='c' c='schedule_hrtimeout'/>
<doc f='linux-5.3.1/kernel/time/hrtimer.c' l='1948'>/**
 * schedule_hrtimeout_range - sleep until timeout
 * @expires:	timeout value (ktime_t)
 * @delta:	slack in expires timeout (ktime_t)
 * @mode:	timer mode
 *
 * Make the current task sleep until the given expiry time has
 * elapsed. The routine will return immediately unless
 * the current task state has been set (see set_current_state()).
 *
 * The @delta argument gives the kernel the freedom to schedule the
 * actual wakeup to a time that is both power and performance friendly.
 * The kernel give the normal best effort behavior for &quot;@expires+@delta&quot;,
 * but may decide to fire the timer earlier, but no earlier than @expires.
 *
 * You can set the task state as follows -
 *
 * %TASK_UNINTERRUPTIBLE - at least @timeout time is guaranteed to
 * pass before the routine returns unless the current task is explicitly
 * woken up, (e.g. by wake_up_process()).
 *
 * %TASK_INTERRUPTIBLE - the routine may return early if a signal is
 * delivered to the current task or the current task is explicitly woken
 * up.
 *
 * The current task state is guaranteed to be TASK_RUNNING when this
 * routine returns.
 *
 * Returns 0 when the timer has expired. If the task was woken before the
 * timer expired by a signal (only possible in state TASK_INTERRUPTIBLE) or
 * by an explicit wakeup, it returns -EINTR.
 */</doc>
<use f='linux-5.3.1/kernel/time/timer.c' l='1998' u='c' c='usleep_range'/>
