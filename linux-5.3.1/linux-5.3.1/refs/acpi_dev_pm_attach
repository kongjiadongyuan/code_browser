<dec f='linux-5.3.1/include/linux/acpi.h' l='914' type='int acpi_dev_pm_attach(struct device * dev, bool power_on)'/>
<def f='linux-5.3.1/drivers/acpi/device_pm.c' l='1310' ll='1334' type='int acpi_dev_pm_attach(struct device * dev, bool power_on)'/>
<dec f='linux-5.3.1/drivers/acpi/device_pm.c' l='1335' type='int acpi_dev_pm_attach(struct device * , bool )'/>
<use f='linux-5.3.1/drivers/acpi/device_pm.c' l='1335' c='acpi_dev_pm_attach'/>
<use f='linux-5.3.1/drivers/acpi/device_pm.c' l='1335' u='a'/>
<doc f='linux-5.3.1/drivers/acpi/device_pm.c' l='1294'>/**
 * acpi_dev_pm_attach - Prepare device for ACPI power management.
 * @dev: Device to prepare.
 * @power_on: Whether or not to power on the device.
 *
 * If @dev has a valid ACPI handle that has a valid struct acpi_device object
 * attached to it, install a wakeup notification handler for the device and
 * add it to the general ACPI PM domain.  If @power_on is set, the device will
 * be put into the ACPI D0 state before the function returns.
 *
 * This assumes that the @dev&apos;s bus type uses generic power management callbacks
 * (or doesn&apos;t use any power management callbacks at all).
 *
 * Callers must ensure proper synchronization of this function with power
 * management callbacks.
 */</doc>
<use f='linux-5.3.1/drivers/base/power/common.c' l='109' u='c' c='dev_pm_domain_attach'/>
