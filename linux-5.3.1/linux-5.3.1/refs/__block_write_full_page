<dec f='linux-5.3.1/include/linux/buffer_head.h' l='219' type='int __block_write_full_page(struct inode * inode, struct page * page, get_block_t * get_block, struct writeback_control * wbc, bh_end_io_t * handler)'/>
<def f='linux-5.3.1/fs/buffer.c' l='1669' ll='1830' type='int __block_write_full_page(struct inode * inode, struct page * page, get_block_t * get_block, struct writeback_control * wbc, bh_end_io_t * handler)'/>
<dec f='linux-5.3.1/fs/buffer.c' l='1831' type='int __block_write_full_page(struct inode * , struct page * , get_block_t * , struct writeback_control * , bh_end_io_t * )'/>
<use f='linux-5.3.1/fs/buffer.c' l='1831' c='__block_write_full_page'/>
<use f='linux-5.3.1/fs/buffer.c' l='1831' u='a'/>
<use f='linux-5.3.1/fs/buffer.c' l='2756' u='c' c='nobh_writepage'/>
<use f='linux-5.3.1/fs/buffer.c' l='2929' u='c' c='block_write_full_page'/>
<use f='linux-5.3.1/fs/buffer.c' l='2953' u='c' c='block_write_full_page'/>
<doc f='linux-5.3.1/fs/buffer.c' l='1653'>/*
 * While block_write_full_page is writing back the dirty buffers under
 * the page lock, whoever dirtied the buffers may decide to clean them
 * again at any time.  We handle that by only looking at the buffer
 * state inside lock_buffer().
 *
 * If block_write_full_page() is called for regular writeback
 * (wbc-&gt;sync_mode == WB_SYNC_NONE) then it will redirty a page which has a
 * locked buffer.   This only can happen if someone has written the buffer
 * directly, with submit_bh().  At the address_space level PageWriteback
 * prevents this contention from occurring.
 *
 * If block_write_full_page() is called with wbc-&gt;sync_mode ==
 * WB_SYNC_ALL, the writes are posted using REQ_SYNC; this
 * causes the writes to be flagged as synchronous writes.
 */</doc>
