<dec f='linux-5.3.1/include/linux/slab.h' l='150' type='struct kmem_cache * kmem_cache_create_usercopy(const char * name, unsigned int size, unsigned int align, slab_flags_t flags, unsigned int useroffset, unsigned int usersize, void (*)(void *) ctor)'/>
<use f='linux-5.3.1/drivers/scsi/scsi_lib.c' l='101' u='c' c='scsi_init_sense_cache'/>
<use f='linux-5.3.1/fs/dcache.c' l='3168' macro='1' u='c' c='dcache_init'/>
<use f='linux-5.3.1/fs/dcache.c' l='3206' u='c' c='vfs_caches_init'/>
<use f='linux-5.3.1/fs/ext4/super.c' l='1146' u='c' c='init_inodecache'/>
<use f='linux-5.3.1/fs/proc/inode.c' l='98' u='c' c='proc_init_kmemcache'/>
<use f='linux-5.3.1/kernel/fork.c' l='798' u='c' c='fork_init'/>
<use f='linux-5.3.1/kernel/fork.c' l='2701' u='c' c='proc_caches_init'/>
<use f='linux-5.3.1/kernel/utsname.c' l='173' u='c' c='uts_ns_init'/>
<def f='linux-5.3.1/mm/slab_common.c' l='452' ll='531' type='struct kmem_cache * kmem_cache_create_usercopy(const char * name, unsigned int size, unsigned int align, slab_flags_t flags, unsigned int useroffset, unsigned int usersize, void (*)(void *) ctor)'/>
<dec f='linux-5.3.1/mm/slab_common.c' l='532' type='struct kmem_cache * kmem_cache_create_usercopy(const char * , unsigned int , unsigned int , slab_flags_t , unsigned int , unsigned int , void (*)(void *) )'/>
<use f='linux-5.3.1/mm/slab_common.c' l='532' c='kmem_cache_create_usercopy'/>
<use f='linux-5.3.1/mm/slab_common.c' l='532' u='a'/>
<use f='linux-5.3.1/mm/slab_common.c' l='563' u='c' c='kmem_cache_create'/>
<doc f='linux-5.3.1/mm/slab_common.c' l='424'>/**
 * kmem_cache_create_usercopy - Create a cache with a region suitable
 * for copying to userspace
 * @name: A string which is used in /proc/slabinfo to identify this cache.
 * @size: The size of objects to be created in this cache.
 * @align: The required alignment for the objects.
 * @flags: SLAB flags
 * @useroffset: Usercopy region offset
 * @usersize: Usercopy region size
 * @ctor: A constructor for the objects.
 *
 * Cannot be called within a interrupt, but can be interrupted.
 * The @ctor is run when new pages are allocated by the cache.
 *
 * The flags are
 *
 * %SLAB_POISON - Poison the slab with a known test pattern (a5a5a5a5)
 * to catch references to uninitialised memory.
 *
 * %SLAB_RED_ZONE - Insert `Red` zones around the allocated memory to check
 * for buffer overruns.
 *
 * %SLAB_HWCACHE_ALIGN - Align the objects in this cache to a hardware
 * cacheline.  This can be beneficial if you&apos;re counting cycles as closely
 * as davem.
 *
 * Return: a pointer to the cache on success, NULL on failure.
 */</doc>
<use f='linux-5.3.1/net/core/skbuff.c' l='4134' u='c' c='skb_init'/>
<use f='linux-5.3.1/net/core/sock.c' l='3363' u='c' c='proto_register'/>
