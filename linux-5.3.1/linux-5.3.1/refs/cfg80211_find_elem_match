<dec f='linux-5.3.1/include/net/cfg80211.h' l='5157' type='const struct element * cfg80211_find_elem_match(u8 eid, const u8 * ies, unsigned int len, const u8 * match, unsigned int match_len, unsigned int match_offset)'/>
<use f='linux-5.3.1/include/net/cfg80211.h' l='5197' u='c' c='cfg80211_find_ie_match'/>
<use f='linux-5.3.1/include/net/cfg80211.h' l='5221' u='c' c='cfg80211_find_elem'/>
<use f='linux-5.3.1/include/net/cfg80211.h' l='5262' u='c' c='cfg80211_find_ext_elem'/>
<doc f='linux-5.3.1/include/net/cfg80211.h' l='5134'>/**
 * cfg80211_find_elem_match - match information element and byte array in data
 *
 * @eid: element ID
 * @ies: data consisting of IEs
 * @len: length of data
 * @match: byte array to match
 * @match_len: number of bytes in the match array
 * @match_offset: offset in the IE data where the byte array should match.
 *	Note the difference to cfg80211_find_ie_match() which considers
 *	the offset to start from the element ID byte, but here we take
 *	the data portion instead.
 *
 * Return: %NULL if the element ID could not be found or if
 * the element is invalid (claims to be longer than the given
 * data) or if the byte array doesn&apos;t match; otherwise return the
 * requested element struct.
 *
 * Note: There are no checks on the element length other than
 * having to fit into the given data and being large enough for the
 * byte array to match.
 */</doc>
<def f='linux-5.3.1/net/wireless/scan.c' l='716' ll='730' type='const struct element * cfg80211_find_elem_match(u8 eid, const u8 * ies, unsigned int len, const u8 * match, unsigned int match_len, unsigned int match_offset)'/>
<dec f='linux-5.3.1/net/wireless/scan.c' l='731' type='const struct element * cfg80211_find_elem_match(u8 , const u8 * , unsigned int , const u8 * , unsigned int , unsigned int )'/>
<use f='linux-5.3.1/net/wireless/scan.c' l='731' c='cfg80211_find_elem_match'/>
<use f='linux-5.3.1/net/wireless/scan.c' l='731' u='a'/>
<use f='linux-5.3.1/net/wireless/scan.c' l='744' u='c' c='cfg80211_find_vendor_elem'/>
