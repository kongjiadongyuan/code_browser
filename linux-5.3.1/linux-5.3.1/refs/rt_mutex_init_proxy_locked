<dec f='linux-5.3.1/kernel/locking/rtmutex_common.h' l='134' type='void rt_mutex_init_proxy_locked(struct rt_mutex * lock, struct task_struct * proxy_owner)'/>
<use f='linux-5.3.1/kernel/futex.c' l='1289' u='c' c='attach_to_pi_owner'/>
<def f='linux-5.3.1/kernel/locking/rtmutex.c' l='1703' ll='1709' type='void rt_mutex_init_proxy_locked(struct rt_mutex * lock, struct task_struct * proxy_owner)'/>
<doc f='linux-5.3.1/kernel/locking/rtmutex.c' l='1689'>/**
 * rt_mutex_init_proxy_locked - initialize and lock a rt_mutex on behalf of a
 *				proxy owner
 *
 * @lock:	the rt_mutex to be locked
 * @proxy_owner:the task to set as owner
 *
 * No locking. Caller has to do serializing itself
 *
 * Special API call for PI-futex support. This initializes the rtmutex and
 * assigns it to @proxy_owner. Concurrent operations on the rtmutex are not
 * possible at this point because the pi_state which contains the rtmutex
 * is not yet visible to other tasks.
 */</doc>
