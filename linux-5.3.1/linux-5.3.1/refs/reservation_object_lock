<def f='linux-5.3.1/include/linux/reservation.h' l='158' ll='163' type='int reservation_object_lock(struct reservation_object * obj, struct ww_acquire_ctx * ctx)'/>
<doc f='linux-5.3.1/include/linux/reservation.h' l='143'>/**
 * reservation_object_lock - lock the reservation object
 * @obj: the reservation object
 * @ctx: the locking context
 *
 * Locks the reservation object for exclusive access and modification. Note,
 * that the lock is only against other writers, readers will run concurrently
 * with a writer under RCU. The seqlock is used to notify readers if they
 * overlap with a writer.
 *
 * As the reservation object may be locked by multiple parties in an
 * undefined order, a #ww_acquire_ctx is passed to unwind if a cycle
 * is detected. See ww_mutex_lock() and ww_acquire_init(). A reservation
 * object may be locked by itself by passing NULL as @ctx.
 */</doc>
<use f='linux-5.3.1/drivers/gpu/drm/i915/gem/i915_gem_object.h' l='106' u='c' c='i915_gem_object_lock'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_vma.h' l='306' u='c' c='i915_vma_lock'/>
<use f='linux-5.3.1/drivers/gpu/drm/i915/i915_gem_batch_pool.c' l='116' u='c' c='i915_gem_batch_pool_get'/>
