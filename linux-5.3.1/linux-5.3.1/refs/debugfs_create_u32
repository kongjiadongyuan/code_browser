<dec f='linux-5.3.1/include/linux/debugfs.h' l='104' type='struct dentry * debugfs_create_u32(const char * name, umode_t mode, struct dentry * parent, u32 * value)'/>
<use f='linux-5.3.1/drivers/clk/clk.c' l='3102' u='c' c='clk_debug_create_one'/>
<use f='linux-5.3.1/drivers/clk/clk.c' l='3104' u='c' c='clk_debug_create_one'/>
<use f='linux-5.3.1/drivers/clk/clk.c' l='3105' u='c' c='clk_debug_create_one'/>
<use f='linux-5.3.1/drivers/clk/clk.c' l='3106' u='c' c='clk_debug_create_one'/>
<use f='linux-5.3.1/drivers/clk/clk.c' l='3107' u='c' c='clk_debug_create_one'/>
<use f='linux-5.3.1/drivers/thermal/intel/x86_pkg_temp_thermal.c' l='82' u='c' c='pkg_temp_debugfs_init'/>
<use f='linux-5.3.1/drivers/thermal/intel/x86_pkg_temp_thermal.c' l='84' u='c' c='pkg_temp_debugfs_init'/>
<def f='linux-5.3.1/fs/debugfs/file.c' l='493' ll='498' type='struct dentry * debugfs_create_u32(const char * name, umode_t mode, struct dentry * parent, u32 * value)'/>
<dec f='linux-5.3.1/fs/debugfs/file.c' l='499' type='struct dentry * debugfs_create_u32(const char * , umode_t , struct dentry * , u32 * )'/>
<use f='linux-5.3.1/fs/debugfs/file.c' l='499' c='debugfs_create_u32'/>
<use f='linux-5.3.1/fs/debugfs/file.c' l='499' u='a'/>
<doc f='linux-5.3.1/fs/debugfs/file.c' l='470'>/**
 * debugfs_create_u32 - create a debugfs file that is used to read and write an unsigned 32-bit value
 * @name: a pointer to a string containing the name of the file to create.
 * @mode: the permission that the file should have
 * @parent: a pointer to the parent dentry for this file.  This should be a
 *          directory dentry if set.  If this parameter is %NULL, then the
 *          file will be created in the root of the debugfs filesystem.
 * @value: a pointer to the variable that the file should read to and write
 *         from.
 *
 * This function creates a file in debugfs with the given name that
 * contains the value of the variable @value.  If the @mode variable is so
 * set, it can be read from, and written to.
 *
 * This function will return a pointer to a dentry if it succeeds.  This
 * pointer must be passed to the debugfs_remove() function when the file is
 * to be removed (no automatic cleanup happens if your module is unloaded,
 * you are responsible here.)  If an error occurs, %ERR_PTR(-ERROR) will be
 * returned.
 *
 * If debugfs is not enabled in the kernel, the value %ERR_PTR(-ENODEV) will
 * be returned.
 */</doc>
