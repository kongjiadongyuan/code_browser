<dec f='linux-5.3.1/include/linux/mempolicy.h' l='151' type='int huge_node(struct vm_area_struct * vma, unsigned long addr, gfp_t gfp_flags, struct mempolicy ** mpol, nodemask_t ** nodemask)'/>
<use f='linux-5.3.1/mm/hugetlb.c' l='963' u='c' c='dequeue_huge_page_vma'/>
<use f='linux-5.3.1/mm/hugetlb.c' l='1666' u='c' c='alloc_buddy_huge_page_with_mpol'/>
<use f='linux-5.3.1/mm/hugetlb.c' l='1725' u='c' c='alloc_huge_page_vma'/>
<def f='linux-5.3.1/mm/mempolicy.c' l='1940' ll='1957' type='int huge_node(struct vm_area_struct * vma, unsigned long addr, gfp_t gfp_flags, struct mempolicy ** mpol, nodemask_t ** nodemask)'/>
<doc f='linux-5.3.1/mm/mempolicy.c' l='1925'>/*
 * huge_node(@vma, @addr, @gfp_flags, @mpol)
 * @vma: virtual memory area whose policy is sought
 * @addr: address in @vma for shared policy lookup and interleave policy
 * @gfp_flags: for requested zone
 * @mpol: pointer to mempolicy pointer for reference counted mempolicy
 * @nodemask: pointer to nodemask pointer for MPOL_BIND nodemask
 *
 * Returns a nid suitable for a huge page allocation and a pointer
 * to the struct mempolicy for conditional unref after allocation.
 * If the effective policy is &apos;BIND, returns a pointer to the mempolicy&apos;s
 * @nodemask for filtering the zonelist.
 *
 * Must be protected by read_mems_allowed_begin()
 */</doc>
