<dec f='linux-5.3.1/include/linux/rmap.h' l='177' type='void page_add_new_anon_rmap(struct page * , struct vm_area_struct * , unsigned long , bool )'/>
<use f='linux-5.3.1/kernel/events/uprobes.c' l='186' u='c' c='__replace_page'/>
<use f='linux-5.3.1/mm/memory.c' l='2358' u='c' c='wp_page_copy'/>
<use f='linux-5.3.1/mm/memory.c' l='2882' u='c' c='do_swap_page'/>
<use f='linux-5.3.1/mm/memory.c' l='3030' u='c' c='do_anonymous_page'/>
<use f='linux-5.3.1/mm/memory.c' l='3293' u='c' c='alloc_set_pte'/>
<def f='linux-5.3.1/mm/rmap.c' l='1153' ll='1173' type='void page_add_new_anon_rmap(struct page * page, struct vm_area_struct * vma, unsigned long address, bool compound)'/>
<doc f='linux-5.3.1/mm/rmap.c' l='1142'>/**
 * page_add_new_anon_rmap - add pte mapping to a new anonymous page
 * @page:	the page to add the mapping to
 * @vma:	the vm area in which the mapping is added
 * @address:	the user virtual address mapped
 * @compound:	charge the page as compound or small page
 *
 * Same as page_add_anon_rmap but must only be called on *new* pages.
 * This means the inc-and-test can be bypassed.
 * Page does not have to be locked.
 */</doc>
<use f='linux-5.3.1/mm/swapfile.c' l='1889' u='c' c='unuse_pte'/>
