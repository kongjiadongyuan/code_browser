<use f='linux-5.3.1/include/linux/input.h' l='148'/>
<def f='linux-5.3.1/include/linux/input.h' l='507' ll='527'/>
<use f='linux-5.3.1/include/linux/input.h' l='516'/>
<size>120</size>
<doc f='linux-5.3.1/include/linux/input.h' l='480'>/**
 * struct ff_device - force-feedback part of an input device
 * @upload: Called to upload an new effect into device
 * @erase: Called to erase an effect from device
 * @playback: Called to request device to start playing specified effect
 * @set_gain: Called to set specified gain
 * @set_autocenter: Called to auto-center device
 * @destroy: called by input core when parent input device is being
 *	destroyed
 * @private: driver-specific data, will be freed automatically
 * @ffbit: bitmap of force feedback capabilities truly supported by
 *	device (not emulated like ones in input_dev-&gt;ffbit)
 * @mutex: mutex for serializing access to the device
 * @max_effects: maximum number of effects supported by device
 * @effects: pointer to an array of effects currently loaded into device
 * @effect_owners: array of effect owners; when file handle owning
 *	an effect gets closed the effect is automatically erased
 *
 * Every force-feedback device must implement upload() and playback()
 * methods; erase() is optional. set_gain() and set_autocenter() need
 * only be implemented if driver sets up FF_GAIN and FF_AUTOCENTER
 * bits.
 *
 * Note that playback(), set_gain() and set_autocenter() are called with
 * dev-&gt;event_lock spinlock held and interrupts off and thus may not
 * sleep.
 */</doc>
<mbr r='ff_device::upload' o='0' t='int (*)(struct input_dev *, struct ff_effect *, struct ff_effect *)'/>
<mbr r='ff_device::erase' o='64' t='int (*)(struct input_dev *, int)'/>
<mbr r='ff_device::playback' o='128' t='int (*)(struct input_dev *, int, int)'/>
<mbr r='ff_device::set_gain' o='192' t='void (*)(struct input_dev *, u16)'/>
<mbr r='ff_device::set_autocenter' o='256' t='void (*)(struct input_dev *, u16)'/>
<mbr r='ff_device::destroy' o='320' t='void (*)(struct ff_device *)'/>
<mbr r='ff_device::private' o='384' t='void *'/>
<mbr r='ff_device::ffbit' o='448' t='unsigned long [2]'/>
<mbr r='ff_device::mutex' o='576' t='struct mutex'/>
<mbr r='ff_device::max_effects' o='832' t='int'/>
<mbr r='ff_device::effects' o='896' t='struct ff_effect *'/>
<mbr r='ff_device::effect_owners' o='960' t='struct file *[]'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-pidff.c' l='1232' c='hid_pidff_init'/>
<size>120</size>
<use f='linux-5.3.1/drivers/input/ff-core.c' l='24' c='check_effect_access'/>
<use f='linux-5.3.1/drivers/input/ff-core.c' l='51' c='compat_effect'/>
<use f='linux-5.3.1/drivers/input/ff-core.c' l='95' c='input_ff_upload'/>
<use f='linux-5.3.1/drivers/input/ff-core.c' l='175' c='erase_effect'/>
<use f='linux-5.3.1/drivers/input/ff-core.c' l='213' c='input_ff_erase'/>
<use f='linux-5.3.1/drivers/input/ff-core.c' l='238' c='input_ff_flush'/>
<use f='linux-5.3.1/drivers/input/ff-core.c' l='264' c='input_ff_event'/>
<use f='linux-5.3.1/drivers/input/ff-core.c' l='307' c='input_ff_create'/>
<use f='linux-5.3.1/drivers/input/ff-core.c' l='321' c='input_ff_create'/>
<use f='linux-5.3.1/drivers/input/ff-core.c' l='367' c='input_ff_destroy'/>
<size>120</size>
<use f='linux-5.3.1/drivers/input/ff-memless.c' l='198' c='get_compatible_type'/>
<use f='linux-5.3.1/drivers/input/ff-memless.c' l='488' c='ml_ff_destroy'/>
<use f='linux-5.3.1/drivers/input/ff-memless.c' l='505' c='input_ff_create_memless'/>
<size>120</size>
