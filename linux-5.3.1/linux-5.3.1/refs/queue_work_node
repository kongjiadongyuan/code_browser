<dec f='linux-5.3.1/include/linux/workqueue.h' l='442' type='bool queue_work_node(int node, struct workqueue_struct * wq, struct work_struct * work)'/>
<use f='linux-5.3.1/kernel/async.c' l='212' u='c' c='async_schedule_node_domain'/>
<def f='linux-5.3.1/kernel/workqueue.c' l='1580' ll='1608' type='bool queue_work_node(int node, struct workqueue_struct * wq, struct work_struct * work)'/>
<dec f='linux-5.3.1/kernel/workqueue.c' l='1609' type='bool queue_work_node(int , struct workqueue_struct * , struct work_struct * )'/>
<use f='linux-5.3.1/kernel/workqueue.c' l='1609' c='queue_work_node'/>
<use f='linux-5.3.1/kernel/workqueue.c' l='1609' u='a'/>
<doc f='linux-5.3.1/kernel/workqueue.c' l='1560'>/**
 * queue_work_node - queue work on a &quot;random&quot; cpu for a given NUMA node
 * @node: NUMA node that we are targeting the work for
 * @wq: workqueue to use
 * @work: work to queue
 *
 * We queue the work to a &quot;random&quot; CPU within a given NUMA node. The basic
 * idea here is to provide a way to somehow associate work with a given
 * NUMA node.
 *
 * This function will only make a best effort attempt at getting this onto
 * the right NUMA node. If no node is requested or the requested node is
 * offline then we just fall back to standard queue_work behavior.
 *
 * Currently the &quot;random&quot; CPU ends up being the first available CPU in the
 * intersection of cpu_online_mask and the cpumask of the node, unless we
 * are running on the node. In that case we just use the current CPU.
 *
 * Return: %false if @work was already on a queue, %true otherwise.
 */</doc>
