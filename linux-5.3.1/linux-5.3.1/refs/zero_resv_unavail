<dec f='linux-5.3.1/include/linux/mm.h' l='2220' type='void zero_resv_unavail()'/>
<def f='linux-5.3.1/mm/page_alloc.c' l='6905' ll='6929' type='void zero_resv_unavail()'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='7359' u='c' c='free_area_init_nodes'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='7554' u='c' c='free_area_init'/>
<doc f='linux-5.3.1/mm/page_alloc.c' l='6893'>/*
 * Only struct pages that are backed by physical memory are zeroed and
 * initialized by going through __init_single_page(). But, there are some
 * struct pages which are reserved in memblock allocator and their fields
 * may be accessed (for example page_to_pfn() on some configuration accesses
 * flags). We must explicitly zero those struct pages.
 *
 * This function also addresses a similar issue where struct pages are left
 * uninitialized because the physical address range is not covered by
 * memblock.memory or memblock.reserved. That could happen when memblock
 * layout is manually configured via memmap=.
 */</doc>
