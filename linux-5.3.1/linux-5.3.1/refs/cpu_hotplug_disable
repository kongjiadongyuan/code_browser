<dec f='linux-5.3.1/include/linux/cpu.h' l='112' type='void cpu_hotplug_disable()'/>
<use f='linux-5.3.1/arch/x86/power/hibernate.c' l='278' u='c' c='arch_resume_nosmt'/>
<use f='linux-5.3.1/drivers/acpi/processor_driver.c' l='258' u='c' c='acpi_processor_start'/>
<use f='linux-5.3.1/drivers/pci/pci-driver.c' l='345' u='c' c='pci_call_probe'/>
<def f='linux-5.3.1/kernel/cpu.c' l='346' ll='351' type='void cpu_hotplug_disable()'/>
<dec f='linux-5.3.1/kernel/cpu.c' l='352' type='void cpu_hotplug_disable()'/>
<use f='linux-5.3.1/kernel/cpu.c' l='352' c='cpu_hotplug_disable'/>
<use f='linux-5.3.1/kernel/cpu.c' l='352' u='a'/>
<use f='linux-5.3.1/kernel/cpu.c' l='1325' u='c' c='cpu_hotplug_pm_callback'/>
<doc f='linux-5.3.1/kernel/cpu.c' l='339'>/*
 * Wait for currently running CPU hotplug operations to complete (if any) and
 * disable future CPU hotplug (from sysfs). The &apos;cpu_add_remove_lock&apos; protects
 * the &apos;cpu_hotplug_disabled&apos; flag. The same lock is also acquired by the
 * hotplug path before performing hotplug operations. So acquiring that lock
 * guarantees mutual exclusion from any currently running hotplug operations.
 */</doc>
<use f='linux-5.3.1/kernel/reboot.c' l='223' u='c' c='migrate_to_reboot_cpu'/>
