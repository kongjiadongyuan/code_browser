<use f='linux-5.3.1/include/drm/drm_crtc.h' l='1109'/>
<def f='linux-5.3.1/drivers/gpu/drm/drm_self_refresh_helper.c' l='53' ll='58'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_self_refresh_helper.c' l='62' c='drm_self_refresh_helper_entry_work'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_self_refresh_helper.c' l='64' c='drm_self_refresh_helper_entry_work'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_self_refresh_helper.c' l='64' c='drm_self_refresh_helper_entry_work'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_self_refresh_helper.c' l='64' c='drm_self_refresh_helper_entry_work'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_self_refresh_helper.c' l='155' c='drm_self_refresh_helper_alter_state'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_self_refresh_helper.c' l='181' c='drm_self_refresh_helper_init'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_self_refresh_helper.c' l='207' c='drm_self_refresh_helper_cleanup'/>
<size>112</size>
<doc f='linux-5.3.1/drivers/gpu/drm/drm_self_refresh_helper.c' l='22'>/**
 * DOC: overview
 *
 * This helper library provides an easy way for drivers to leverage the atomic
 * framework to implement panel self refresh (SR) support. Drivers are
 * responsible for initializing and cleaning up the SR helpers on load/unload
 * (see &amp;drm_self_refresh_helper_init/&amp;drm_self_refresh_helper_cleanup).
 * The connector is responsible for setting
 * &amp;drm_connector_state.self_refresh_aware to true at runtime if it is SR-aware
 * (meaning it knows how to initiate self refresh on the panel).
 *
 * Once a crtc has enabled SR using &amp;drm_self_refresh_helper_init, the
 * helpers will monitor activity and call back into the driver to enable/disable
 * SR as appropriate. The best way to think about this is that it&apos;s a DPMS
 * on/off request with &amp;drm_crtc_state.self_refresh_active set in crtc state
 * that tells you to disable/enable SR on the panel instead of power-cycling it.
 *
 * During SR, drivers may choose to fully disable their crtc/encoder/bridge
 * hardware (in which case no driver changes are necessary), or they can inspect
 * &amp;drm_crtc_state.self_refresh_active if they want to enter low power mode
 * without full disable (in case full disable/enable is too slow).
 *
 * SR will be deactivated if there are any atomic updates affecting the
 * pipe that is in SR mode. If a crtc is driving multiple connectors, all
 * connectors must be SR aware and all will enter/exit SR mode at the same time.
 *
 * If the crtc and connector are SR aware, but the panel connected does not
 * support it (or is otherwise unable to enter SR), the driver should fail
 * atomic_check when &amp;drm_crtc_state.self_refresh_active is true.
 */</doc>
<mbr r='drm_self_refresh_data::crtc' o='0' t='struct drm_crtc *'/>
<mbr r='drm_self_refresh_data::entry_work' o='64' t='struct delayed_work'/>
<mbr r='drm_self_refresh_data::save_state' o='768' t='struct drm_atomic_state *'/>
<mbr r='drm_self_refresh_data::entry_delay_ms' o='832' t='unsigned int'/>
