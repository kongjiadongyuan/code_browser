<dec f='linux-5.3.1/include/net/tcp.h' l='1999' type='void tcp_rack_update_reo_wnd(struct sock * sk, struct rate_sample * rs)'/>
<use f='linux-5.3.1/net/ipv4/tcp_input.c' l='3690' u='c' c='tcp_ack'/>
<def f='linux-5.3.1/net/ipv4/tcp_recovery.c' l='202' ll='224' type='void tcp_rack_update_reo_wnd(struct sock * sk, struct rate_sample * rs)'/>
<doc f='linux-5.3.1/net/ipv4/tcp_recovery.c' l='185'>/* Updates the RACK&apos;s reo_wnd based on DSACK and no. of recoveries.
 *
 * If DSACK is received, increment reo_wnd by min_rtt/4 (upper bounded
 * by srtt), since there is possibility that spurious retransmission was
 * due to reordering delay longer than reo_wnd.
 *
 * Persist the current reo_wnd value for TCP_RACK_RECOVERY_THRESH (16)
 * no. of successful recoveries (accounts for full DSACK-based loss
 * recovery undo). After that, reset it to default (min_rtt/4).
 *
 * At max, reo_wnd is incremented only once per rtt. So that the new
 * DSACK on which we are reacting, is due to the spurious retx (approx)
 * after the reo_wnd has been updated last time.
 *
 * reo_wnd is tracked in terms of steps (of min_rtt/4), rather than
 * absolute value to account for change in rtt.
 */</doc>
