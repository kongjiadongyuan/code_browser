<dec f='linux-5.3.1/include/linux/vmalloc.h' l='188' type='long vread(char * buf, char * addr, unsigned long count)'/>
<doc f='linux-5.3.1/include/linux/vmalloc.h' l='187'>/* for /dev/kmem */</doc>
<use f='linux-5.3.1/drivers/char/mem.c' l='484' u='c' c='read_kmem'/>
<use f='linux-5.3.1/fs/proc/kcore.c' l='496' u='c' c='read_kcore'/>
<def f='linux-5.3.1/mm/vmalloc.c' l='2837' ll='2890' type='long vread(char * buf, char * addr, unsigned long count)'/>
<doc f='linux-5.3.1/mm/vmalloc.c' l='2813'>/**
 * vread() - read vmalloc area in a safe way.
 * @buf:     buffer for reading data
 * @addr:    vm address.
 * @count:   number of bytes to be read.
 *
 * This function checks that addr is a valid vmalloc&apos;ed area, and
 * copy data from that area to a given buffer. If the given memory range
 * of [addr...addr+count) includes some valid address, data is copied to
 * proper area of @buf. If there are memory holes, they&apos;ll be zero-filled.
 * IOREMAP area is treated as memory hole and no copy is done.
 *
 * If [addr...addr+count) doesn&apos;t includes any intersects with alive
 * vm_struct area, returns 0. @buf should be kernel&apos;s buffer.
 *
 * Note: In usual ops, vread() is never necessary because the caller
 * should know vmalloc() area is valid and can use memcpy().
 * This is for routines which have to access vmalloc area without
 * any information, as /dev/kmem.
 *
 * Return: number of bytes for which addr and buf should be increased
 * (same number as @count) or %0 if [addr...addr+count) doesn&apos;t
 * include any intersection with valid vmalloc area
 */</doc>
