<dec f='linux-5.3.1/include/linux/blkdev.h' l='1688' type='int bdev_read_page(struct block_device * , sector_t , struct page * )'/>
<def f='linux-5.3.1/fs/block_dev.c' l='699' ll='715' type='int bdev_read_page(struct block_device * bdev, sector_t sector, struct page * page)'/>
<dec f='linux-5.3.1/fs/block_dev.c' l='716' type='int bdev_read_page(struct block_device * , sector_t , struct page * )'/>
<use f='linux-5.3.1/fs/block_dev.c' l='716' c='bdev_read_page'/>
<use f='linux-5.3.1/fs/block_dev.c' l='716' u='a'/>
<doc f='linux-5.3.1/fs/block_dev.c' l='683'>/**
 * bdev_read_page() - Start reading a page from a block device
 * @bdev: The device to read the page from
 * @sector: The offset on the device to read the page to (need not be aligned)
 * @page: The page to read
 *
 * On entry, the page should be locked.  It will be unlocked when the page
 * has been read.  If the block driver implements rw_page synchronously,
 * that will be true on exit from this function, but it need not be.
 *
 * Errors returned by this function are usually &quot;soft&quot;, eg out of memory, or
 * queue full; callers should try a different route to read this page rather
 * than propagate an error back up the stack.
 *
 * Return: negative errno if an error occurs, 0 if submission was successful.
 */</doc>
<use f='linux-5.3.1/fs/mpage.c' l='302' u='c' c='do_mpage_readpage'/>
<use f='linux-5.3.1/mm/page_io.c' l='377' u='c' c='swap_readpage'/>
