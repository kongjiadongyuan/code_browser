<dec f='linux-5.3.1/include/linux/mmzone.h' l='488' type='atomic_long_t'/>
<use f='linux-5.3.1/include/linux/mmzone.h' l='587' u='a' c='zone_managed_pages'/>
<offset>832</offset>
<doc f='linux-5.3.1/include/linux/mmzone.h' l='453'>/*
	 * spanned_pages is the total pages spanned by the zone, including
	 * holes, which is calculated as:
	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;
	 *
	 * present_pages is physical pages existing within the zone, which
	 * is calculated as:
	 *	present_pages = spanned_pages - absent_pages(pages in holes);
	 *
	 * managed_pages is present pages managed by the buddy system, which
	 * is calculated as (reserved_pages includes pages allocated by the
	 * bootmem allocator):
	 *	managed_pages = present_pages - reserved_pages;
	 *
	 * So present_pages may be used by memory hotplug or memory power
	 * management logic to figure out unmanaged pages by checking
	 * (present_pages - managed_pages). And managed_pages should be used
	 * by page allocator and vm scanner to calculate all kinds of watermarks
	 * and thresholds.
	 *
	 * Locking rules:
	 *
	 * zone_start_pfn and spanned_pages are protected by span_seqlock.
	 * It is a seqlock because it has to be read outside of zone-&gt;lock,
	 * and it is done in the main allocator path.  But, it is written
	 * quite infrequently.
	 *
	 * The span_seq lock is declared along with zone-&gt;lock because it is
	 * frequently read in proximity to zone-&gt;lock.  It&apos;s good to
	 * give them a chance of being in the same cacheline.
	 *
	 * Write access to present_pages at runtime should be protected by
	 * mem_hotplug_begin/end(). Any reader who can&apos;t tolerant drift of
	 * present_pages should get_online_mems() to get a stable value.
	 */</doc>
<use f='linux-5.3.1/mm/memblock.c' l='1953' u='a' c='reset_node_managed_pages'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='1445' u='a' c='__free_pages_core'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='6676' u='a' c='zone_init_internals'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='7432' u='a' c='adjust_managed_page_count'/>
