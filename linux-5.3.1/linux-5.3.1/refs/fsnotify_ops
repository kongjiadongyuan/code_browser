<def f='linux-5.3.1/include/linux/fsnotify_backend.h' l='116' ll='127'/>
<use f='linux-5.3.1/include/linux/fsnotify_backend.h' l='147'/>
<use f='linux-5.3.1/include/linux/fsnotify_backend.h' l='396' c='fsnotify_alloc_group'/>
<size>40</size>
<doc f='linux-5.3.1/include/linux/fsnotify_backend.h' l='105'>/*
 * Each group much define these ops.  The fsnotify infrastructure will call
 * these operations for each relevant group.
 *
 * handle_event - main call for a group to handle an fs event
 * free_group_priv - called when a group refcnt hits 0 to clean up the private union
 * freeing_mark - called when a mark is being destroyed for some reason.  The group
 * 		MUST be holding a reference on each mark and that reference must be
 * 		dropped in this function.  inotify uses this function to send
 * 		userspace messages that marks have been removed.
 */</doc>
<mbr r='fsnotify_ops::handle_event' o='0' t='int (*)(struct fsnotify_group *, struct inode *, u32, const void *, int, const struct qstr *, u32, struct fsnotify_iter_info *)'/>
<mbr r='fsnotify_ops::free_group_priv' o='64' t='void (*)(struct fsnotify_group *)'/>
<mbr r='fsnotify_ops::freeing_mark' o='128' t='void (*)(struct fsnotify_mark *, struct fsnotify_group *)'/>
<mbr r='fsnotify_ops::free_event' o='192' t='void (*)(struct fsnotify_event *)'/>
<mbr r='fsnotify_ops::free_mark' o='256' t='void (*)(struct fsnotify_mark *)'/>
<use f='linux-5.3.1/fs/notify/dnotify/dnotify.c' l='128'/>
<size>40</size>
<use f='linux-5.3.1/fs/notify/inotify/inotify.h' l='33'/>
<size>40</size>
<use f='linux-5.3.1/fs/notify/group.c' l='115' c='fsnotify_alloc_group'/>
<size>40</size>
<use f='linux-5.3.1/fs/notify/inotify/inotify_fsnotify.c' l='205'/>
<size>40</size>
<use f='linux-5.3.1/kernel/audit_fsnotify.c' l='191'/>
<size>40</size>
<use f='linux-5.3.1/kernel/audit_tree.c' l='1072'/>
<size>40</size>
<use f='linux-5.3.1/kernel/audit_watch.c' l='506'/>
<size>40</size>
