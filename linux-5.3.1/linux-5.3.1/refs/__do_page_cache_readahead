<dec f='linux-5.3.1/mm/internal.h' l='52' type='unsigned int __do_page_cache_readahead(struct address_space * mapping, struct file * filp, unsigned long offset, unsigned long nr_to_read, unsigned long lookahead_size)'/>
<use f='linux-5.3.1/mm/internal.h' l='62' u='c' c='ra_submit'/>
<def f='linux-5.3.1/mm/readahead.c' l='155' ll='216' type='unsigned int __do_page_cache_readahead(struct address_space * mapping, struct file * filp, unsigned long offset, unsigned long nr_to_read, unsigned long lookahead_size)'/>
<use f='linux-5.3.1/mm/readahead.c' l='243' u='c' c='force_page_cache_readahead'/>
<use f='linux-5.3.1/mm/readahead.c' l='467' u='c' c='ondemand_readahead'/>
<doc f='linux-5.3.1/mm/readahead.c' l='147'>/*
 * __do_page_cache_readahead() actually reads a chunk of disk.  It allocates
 * the pages first, then submits them for I/O. This avoids the very bad
 * behaviour which would occur if page allocations are causing VM writeback.
 * We really don&apos;t want to intermingle reads and writes like that.
 *
 * Returns the number of pages requested, or the maximum amount of I/O allowed.
 */</doc>
