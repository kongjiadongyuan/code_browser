<def f='linux-5.3.1/include/linux/mm.h' l='2645' ll='2654' type='int vm_fault_to_errno(vm_fault_t vm_fault, int foll_flags)'/>
<doc f='linux-5.3.1/include/linux/mm.h' l='2618'>/*
 * NOTE on FOLL_LONGTERM:
 *
 * FOLL_LONGTERM indicates that the page will be held for an indefinite time
 * period _often_ under userspace control.  This is contrasted with
 * iov_iter_get_pages() where usages which are transient.
 *
 * FIXME: For pages which are part of a filesystem, mappings are subject to the
 * lifetime enforced by the filesystem and we need guarantees that longterm
 * users like RDMA and V4L2 only establish mappings which coordinate usage with
 * the filesystem.  Ideas for this coordination include revoking the longterm
 * pin, delaying writeback, bounce buffer page writeback, etc.  As FS DAX was
 * added after the problem with filesystems was found FS DAX VMAs are
 * specifically failed.  Filesystem pages are still subject to bugs and use of
 * FOLL_LONGTERM should be avoided on those pages.
 *
 * FIXME: Also NOTE that FOLL_LONGTERM is not supported in every GUP call.
 * Currently only get_user_pages() and get_user_pages_fast() support this flag
 * and calls to get_user_pages_[un]locked are specifically not allowed.  This
 * is due to an incompatibility with the FS DAX check and
 * FAULT_FLAG_ALLOW_RETRY
 *
 * In the CMA case: longterm pins in a CMA region would unnecessarily fragment
 * that region.  And so CMA attempts to migrate the page before pinning when
 * FOLL_LONGTERM is specified.
 */</doc>
<use f='linux-5.3.1/mm/gup.c' l='653' u='c' c='faultin_page'/>
<use f='linux-5.3.1/mm/gup.c' l='978' u='c' c='fixup_user_fault'/>
<use f='linux-5.3.1/mm/hugetlb.c' l='4356' u='c' c='follow_hugetlb_page'/>
