<def f='linux-5.3.1/include/linux/fs.h' l='1652' ll='1655' type='void sb_start_pagefault(struct super_block * sb)'/>
<doc f='linux-5.3.1/include/linux/fs.h' l='1633'>/**
 * sb_start_pagefault - get write access to a superblock from a page fault
 * @sb: the super we write to
 *
 * When a process starts handling write page fault, it should embed the
 * operation into sb_start_pagefault() - sb_end_pagefault() pair to get
 * exclusion against file system freezing. This is needed since the page fault
 * is going to dirty a page. This function increments number of running page
 * faults preventing freezing. If the file system is already frozen, the
 * function waits until the file system is thawed.
 *
 * Since page fault freeze protection behaves as a lock, users have to preserve
 * ordering of freeze protection and other filesystem locks. It is advised to
 * put sb_start_pagefault() close to mmap_sem in lock ordering. Page fault
 * handling code implies lock dependency:
 *
 * mmap_sem
 *   -&gt; sb_start_pagefault
 */</doc>
<use f='linux-5.3.1/fs/ext4/inode.c' l='6224' u='c' c='ext4_page_mkwrite'/>
<use f='linux-5.3.1/fs/nfs/file.c' l='545' u='c' c='nfs_vm_page_mkwrite'/>
<use f='linux-5.3.1/mm/filemap.c' l='2723' u='c' c='filemap_page_mkwrite'/>
