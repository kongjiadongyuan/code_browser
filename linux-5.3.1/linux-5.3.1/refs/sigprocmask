<dec f='linux-5.3.1/include/linux/signal.h' l='275' type='int sigprocmask(int , sigset_t * , sigset_t * )'/>
<def f='linux-5.3.1/kernel/signal.c' l='2927' ll='2952' type='int sigprocmask(int how, sigset_t * set, sigset_t * oldset)'/>
<dec f='linux-5.3.1/kernel/signal.c' l='2953' type='int sigprocmask(int , sigset_t * , sigset_t * )'/>
<use f='linux-5.3.1/kernel/signal.c' l='2953' c='sigprocmask'/>
<use f='linux-5.3.1/kernel/signal.c' l='2953' u='a'/>
<use f='linux-5.3.1/kernel/signal.c' l='3027' u='c' c='__do_sys_rt_sigprocmask'/>
<use f='linux-5.3.1/kernel/signal.c' l='3057' u='c' c='__do_compat_sys_rt_sigprocmask'/>
<doc f='linux-5.3.1/kernel/signal.c' l='2919'>/*
 * This is also useful for kernel threads that want to temporarily
 * (or permanently) block certain signals.
 *
 * NOTE! Unlike the user-mode sys_sigprocmask(), the kernel
 * interface happily blocks &quot;unblockable&quot; signals like SIGKILL
 * and friends.
 */</doc>
<dec f='include/signal.h' l='229' type='int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)'/>
<doc f='include/signal.h' l='228'>/* Get and/or change the set of blocked signals.  */</doc>
