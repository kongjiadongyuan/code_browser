<dec f='linux-5.3.1/include/linux/usb.h' l='1707' type='void usb_kill_urb(struct urb * urb)'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='750' u='c' c='usbhid_close'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='778' u='c' c='usbhid_init_reports'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='780' u='c' c='usbhid_init_reports'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='1209' u='c' c='usbhid_stop'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='1210' u='c' c='usbhid_stop'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='1211' u='c' c='usbhid_stop'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='1426' u='c' c='hid_cease_io'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='1427' u='c' c='hid_cease_io'/>
<use f='linux-5.3.1/drivers/hid/usbhid/hid-core.c' l='1428' u='c' c='hid_cease_io'/>
<use f='linux-5.3.1/drivers/usb/core/devio.c' l='634' u='c' c='destroy_async'/>
<use f='linux-5.3.1/drivers/usb/core/devio.c' l='1855' u='c' c='proc_unlinkurb'/>
<use f='linux-5.3.1/drivers/usb/core/hcd.c' l='1806' u='c' c='usb_hcd_flush_endpoint'/>
<use f='linux-5.3.1/drivers/usb/core/hub.c' l='1317' u='c' c='hub_quiesce'/>
<use f='linux-5.3.1/drivers/usb/core/message.c' l='63' u='c' c='usb_start_wait_urb'/>
<def f='linux-5.3.1/drivers/usb/core/urb.c' l='687' ll='698' type='void usb_kill_urb(struct urb * urb)'/>
<dec f='linux-5.3.1/drivers/usb/core/urb.c' l='699' type='void usb_kill_urb(struct urb * )'/>
<use f='linux-5.3.1/drivers/usb/core/urb.c' l='699' c='usb_kill_urb'/>
<use f='linux-5.3.1/drivers/usb/core/urb.c' l='699' u='a'/>
<use f='linux-5.3.1/drivers/usb/core/urb.c' l='795' u='c' c='usb_kill_anchored_urbs'/>
<doc f='linux-5.3.1/drivers/usb/core/urb.c' l='660'>/**
 * usb_kill_urb - cancel a transfer request and wait for it to finish
 * @urb: pointer to URB describing a previously submitted request,
 *	may be NULL
 *
 * This routine cancels an in-progress request.  It is guaranteed that
 * upon return all completion handlers will have finished and the URB
 * will be totally idle and available for reuse.  These features make
 * this an ideal way to stop I/O in a disconnect() callback or close()
 * function.  If the request has not already finished or been unlinked
 * the completion handler will see urb-&gt;status == -ENOENT.
 *
 * While the routine is running, attempts to resubmit the URB will fail
 * with error -EPERM.  Thus even if the URB&apos;s completion handler always
 * tries to resubmit, it will not succeed and the URB will become idle.
 *
 * The URB must not be deallocated while this routine is running.  In
 * particular, when a driver calls this routine, it must insure that the
 * completion handler cannot deallocate the URB.
 *
 * This routine may not be used in an interrupt context (such as a bottom
 * half or a completion handler), or when holding a spinlock, or in other
 * situations where the caller can&apos;t schedule().
 *
 * This routine should not be called by a driver after its disconnect
 * method has returned.
 */</doc>
<use f='linux-5.3.1/drivers/usb/storage/transport.c' l='174' u='c' c='usb_stor_msg_common'/>
