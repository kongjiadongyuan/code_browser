<dec f='linux-5.3.1/drivers/scsi/scsi_priv.h' l='92' type='void scsi_io_completion(struct scsi_cmnd * , unsigned int )'/>
<use f='linux-5.3.1/drivers/scsi/scsi.c' l='228' u='c' c='scsi_finish_command'/>
<def f='linux-5.3.1/drivers/scsi/scsi_lib.c' l='932' ll='983' type='void scsi_io_completion(struct scsi_cmnd * cmd, unsigned int good_bytes)'/>
<doc f='linux-5.3.1/drivers/scsi/scsi_lib.c' l='903'>/*
 * Function:    scsi_io_completion()
 *
 * Purpose:     Completion processing for block device I/O requests.
 *
 * Arguments:   cmd   - command that is finished.
 *
 * Lock status: Assumed that no lock is held upon entry.
 *
 * Returns:     Nothing
 *
 * Notes:       We will finish off the specified number of sectors.  If we
 *		are done, the command block will be released and the queue
 *		function will be goosed.  If we are not done then we have to
 *		figure out what to do next:
 *
 *		a) We can call scsi_requeue_command().  The request
 *		   will be unprepared and put back on the queue.  Then
 *		   a new command will be created for it.  This should
 *		   be used if we made forward progress, or if we want
 *		   to switch from READ(10) to READ(6) for example.
 *
 *		b) We can call __scsi_queue_insert().  The request will
 *		   be put back on the queue and retried using the same
 *		   command as before, possibly after a delay.
 *
 *		c) We can call scsi_end_request() with blk_stat other than
 *		   BLK_STS_OK, to fail the remainder of the request.
 */</doc>
