<dec f='linux-5.3.1/include/linux/timekeeping.h' l='52' type='time64_t ktime_get_seconds()'/>
<doc f='linux-5.3.1/include/linux/timekeeping.h' l='49'>/*
 * time64_t base interfaces
 */</doc>
<use f='linux-5.3.1/kernel/cgroup/cpuset.c' l='1992' u='c' c='fmeter_update'/>
<def f='linux-5.3.1/kernel/time/timekeeping.c' l='912' ll='918' type='time64_t ktime_get_seconds()'/>
<dec f='linux-5.3.1/kernel/time/timekeeping.c' l='919' type='time64_t ktime_get_seconds()'/>
<use f='linux-5.3.1/kernel/time/timekeeping.c' l='919' c='ktime_get_seconds'/>
<use f='linux-5.3.1/kernel/time/timekeeping.c' l='919' u='a'/>
<doc f='linux-5.3.1/kernel/time/timekeeping.c' l='903'>/**
 * ktime_get_seconds - Get the seconds portion of CLOCK_MONOTONIC
 *
 * Returns the seconds portion of CLOCK_MONOTONIC with a single non
 * serialized read. tk-&gt;ktime_sec is of type &apos;unsigned long&apos; so this
 * works on both 32 and 64 bit systems. On 32 bit systems the readout
 * covers ~136 years of uptime which should be enough to prevent
 * premature wrap arounds.
 */</doc>
<use f='linux-5.3.1/include/net/tcp.h' l='1434' u='c' c='tcp_paws_check'/>
<use f='linux-5.3.1/include/net/tcp.h' l='1465' u='c' c='tcp_paws_reject'/>
<use f='linux-5.3.1/net/ipv4/tcp_input.c' l='3482' u='c' c='tcp_store_ts_recent'/>
<use f='linux-5.3.1/net/ipv4/tcp_ipv4.c' l='153' u='c' c='tcp_twsk_unique'/>
<use f='linux-5.3.1/net/ipv4/tcp_minisocks.c' l='148' u='c' c='tcp_timewait_state_process'/>
<use f='linux-5.3.1/net/ipv4/tcp_minisocks.c' l='194' u='c' c='tcp_timewait_state_process'/>
<use f='linux-5.3.1/net/ipv4/tcp_minisocks.c' l='521' u='c' c='tcp_create_openreq_child'/>
<use f='linux-5.3.1/net/ipv4/tcp_minisocks.c' l='585' u='c' c='tcp_check_req'/>
<use f='linux-5.3.1/net/mac80211/sta_info.c' l='367' u='c' c='sta_info_alloc'/>
<use f='linux-5.3.1/net/mac80211/sta_info.c' l='2205' u='c' c='sta_set_sinfo'/>
