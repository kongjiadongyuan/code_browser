<dec f='linux-5.3.1/include/linux/trace_clock.h' l='19' type='u64 trace_clock()'/>
<use f='linux-5.3.1/kernel/trace/trace.c' l='1337'/>
<use f='linux-5.3.1/kernel/trace/trace.c' l='1337'/>
<use f='linux-5.3.1/kernel/trace/trace.c' l='1337'/>
<use f='linux-5.3.1/kernel/trace/trace.c' l='1337'/>
<def f='linux-5.3.1/kernel/trace/trace_clock.c' l='57' ll='60' type='u64 trace_clock()'/>
<dec f='linux-5.3.1/kernel/trace/trace_clock.c' l='61' type='u64 trace_clock()'/>
<use f='linux-5.3.1/kernel/trace/trace_clock.c' l='61' c='trace_clock'/>
<use f='linux-5.3.1/kernel/trace/trace_clock.c' l='61' u='a'/>
<doc f='linux-5.3.1/kernel/trace/trace_clock.c' l='49'>/*
 * trace_clock(): &apos;between&apos; trace clock. Not completely serialized,
 * but not completely incorrect when crossing CPUs either.
 *
 * This is based on cpu_clock(), which will allow at most ~1 jiffy of
 * jitter between CPUs. So it&apos;s a pretty scalable clock, but there
 * can be offsets in the trace data.
 */</doc>
