<dec f='linux-5.3.1/include/drm/drm_gem.h' l='378' type='int drm_gem_create_mmap_offset_size(struct drm_gem_object * obj, size_t size)'/>
<def f='linux-5.3.1/drivers/gpu/drm/drm_gem.c' l='491' ll='498' type='int drm_gem_create_mmap_offset_size(struct drm_gem_object * obj, size_t size)'/>
<dec f='linux-5.3.1/drivers/gpu/drm/drm_gem.c' l='499' type='int drm_gem_create_mmap_offset_size(struct drm_gem_object * , size_t )'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_gem.c' l='499' c='drm_gem_create_mmap_offset_size'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_gem.c' l='499' u='a'/>
<use f='linux-5.3.1/drivers/gpu/drm/drm_gem.c' l='517' u='c' c='drm_gem_create_mmap_offset'/>
<doc f='linux-5.3.1/drivers/gpu/drm/drm_gem.c' l='474'>/**
 * drm_gem_create_mmap_offset_size - create a fake mmap offset for an object
 * @obj: obj in question
 * @size: the virtual size
 *
 * GEM memory mapping works by handing back to userspace a fake mmap offset
 * it can use in a subsequent mmap(2) call.  The DRM core code then looks
 * up the object based on the offset and sets up the various memory mapping
 * structures.
 *
 * This routine allocates and attaches a fake offset for @obj, in cases where
 * the virtual size differs from the physical size (ie. &amp;drm_gem_object.size).
 * Otherwise just use drm_gem_create_mmap_offset().
 *
 * This function is idempotent and handles an already allocated mmap offset
 * transparently. Drivers do not need to check for this case.
 */</doc>
