<dec f='linux-5.3.1/include/linux/blk-pm.h' l='14' type='int blk_pre_runtime_suspend(struct request_queue * q)'/>
<def f='linux-5.3.1/block/blk-pm.c' l='61' ll='103' type='int blk_pre_runtime_suspend(struct request_queue * q)'/>
<dec f='linux-5.3.1/block/blk-pm.c' l='104' type='int blk_pre_runtime_suspend(struct request_queue * )'/>
<use f='linux-5.3.1/block/blk-pm.c' l='104' c='blk_pre_runtime_suspend'/>
<use f='linux-5.3.1/block/blk-pm.c' l='104' u='a'/>
<doc f='linux-5.3.1/block/blk-pm.c' l='40'>/**
 * blk_pre_runtime_suspend - Pre runtime suspend check
 * @q: the queue of the device
 *
 * Description:
 *    This function will check if runtime suspend is allowed for the device
 *    by examining if there are any requests pending in the queue. If there
 *    are requests pending, the device can not be runtime suspended; otherwise,
 *    the queue&apos;s status will be updated to SUSPENDING and the driver can
 *    proceed to suspend the device.
 *
 *    For the not allowed case, we mark last busy for the device so that
 *    runtime PM core will try to autosuspend it some time later.
 *
 *    This function should be called near the start of the device&apos;s
 *    runtime_suspend callback.
 *
 * Return:
 *    0		- OK to runtime suspend the device
 *    -EBUSY	- Device should not be runtime suspended
 */</doc>
<use f='linux-5.3.1/drivers/scsi/scsi_pm.c' l='234' u='c' c='sdev_runtime_suspend'/>
