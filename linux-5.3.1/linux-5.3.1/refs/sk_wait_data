<dec f='linux-5.3.1/include/net/sock.h' l='1038' type='int sk_wait_data(struct sock * sk, long * timeo, const struct sk_buff * skb)'/>
<def f='linux-5.3.1/net/core/sock.c' l='2462' ll='2473' type='int sk_wait_data(struct sock * sk, long * timeo, const struct sk_buff * skb)'/>
<dec f='linux-5.3.1/net/core/sock.c' l='2474' type='int sk_wait_data(struct sock * , long * , const struct sk_buff * )'/>
<use f='linux-5.3.1/net/core/sock.c' l='2474' c='sk_wait_data'/>
<use f='linux-5.3.1/net/core/sock.c' l='2474' u='a'/>
<doc f='linux-5.3.1/net/core/sock.c' l='2451'>/**
 * sk_wait_data - wait for data to arrive at sk_receive_queue
 * @sk:    sock to wait on
 * @timeo: for how long
 * @skb:   last skb seen on sk_receive_queue
 *
 * Now socket state including sk-&gt;sk_err is changed only under lock,
 * hence we may omit checks after joining wait queue.
 * We check receive queue before schedule() only as optimization;
 * it is very likely that release_sock() added new data.
 */</doc>
<use f='linux-5.3.1/net/ipv4/tcp.c' l='822' u='c' c='tcp_splice_read'/>
<use f='linux-5.3.1/net/ipv4/tcp.c' l='2095' u='c' c='tcp_recvmsg'/>
