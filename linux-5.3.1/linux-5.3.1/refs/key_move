<dec f='linux-5.3.1/include/linux/key.h' l='365' type='int key_move(struct key * key, struct key * from_keyring, struct key * to_keyring, unsigned int flags)'/>
<use f='linux-5.3.1/security/keys/keyctl.c' l='620' u='c' c='keyctl_keyring_move'/>
<def f='linux-5.3.1/security/keys/keyring.c' l='1589' ll='1635' type='int key_move(struct key * key, struct key * from_keyring, struct key * to_keyring, unsigned int flags)'/>
<dec f='linux-5.3.1/security/keys/keyring.c' l='1636' type='int key_move(struct key * , struct key * , struct key * , unsigned int )'/>
<use f='linux-5.3.1/security/keys/keyring.c' l='1636' c='key_move'/>
<use f='linux-5.3.1/security/keys/keyring.c' l='1636' u='a'/>
<doc f='linux-5.3.1/security/keys/keyring.c' l='1564'>/**
 * key_move - Move a key from one keyring to another
 * @key: The key to move
 * @from_keyring: The keyring to remove the link from.
 * @to_keyring: The keyring to make the link in.
 * @flags: Qualifying flags, such as KEYCTL_MOVE_EXCL.
 *
 * Make a link in @to_keyring to a key, such that the keyring holds a reference
 * on that key and the key can potentially be found by searching that keyring
 * whilst simultaneously removing a link to the key from @from_keyring.
 *
 * This function will write-lock both keyring&apos;s semaphores and will consume
 * some of the user&apos;s key data quota to hold the link on @to_keyring.
 *
 * Returns 0 if successful, -ENOTDIR if either keyring isn&apos;t a keyring,
 * -EKEYREVOKED if either keyring has been revoked, -ENFILE if the second
 * keyring is full, -EDQUOT if there is insufficient key data quota remaining
 * to add another link or -ENOMEM if there&apos;s insufficient memory.  If
 * KEYCTL_MOVE_EXCL is set, then -EEXIST will be returned if there&apos;s already a
 * matching key in @to_keyring.
 *
 * It is assumed that the caller has checked that it is permitted for a link to
 * be made (the keyring should have Write permission and the key Link
 * permission).
 */</doc>
