<dec f='linux-5.3.1/include/linux/kthread.h' l='181' type='bool kthread_queue_work(struct kthread_worker * worker, struct kthread_work * work)'/>
<use f='linux-5.3.1/drivers/block/loop.c' l='1911' u='c' c='loop_queue_rq'/>
<def f='linux-5.3.1/kernel/kthread.c' l='818' ll='831' type='bool kthread_queue_work(struct kthread_worker * worker, struct kthread_work * work)'/>
<dec f='linux-5.3.1/kernel/kthread.c' l='832' type='bool kthread_queue_work(struct kthread_worker * , struct kthread_work * )'/>
<use f='linux-5.3.1/kernel/kthread.c' l='832' c='kthread_queue_work'/>
<use f='linux-5.3.1/kernel/kthread.c' l='832' u='a'/>
<use f='linux-5.3.1/kernel/kthread.c' l='1165' u='c' c='kthread_flush_worker'/>
<doc f='linux-5.3.1/kernel/kthread.c' l='806'>/**
 * kthread_queue_work - queue a kthread_work
 * @worker: target kthread_worker
 * @work: kthread_work to queue
 *
 * Queue @work to work processor @task for async execution.  @task
 * must have been created with kthread_worker_create().  Returns %true
 * if @work was successfully queued, %false if it was already pending.
 *
 * Reinitialize the work if it needs to be used by another worker.
 * For example, when the worker was stopped and started again.
 */</doc>
