<dec f='linux-5.3.1/mm/internal.h' l='223' type='int find_suitable_fallback(struct free_area * area, unsigned int order, int migratetype, bool only_stealable, bool * can_steal)'/>
<use f='linux-5.3.1/mm/compaction.c' l='1907' u='c' c='__compact_finished'/>
<def f='linux-5.3.1/mm/page_alloc.c' l='2463' ll='2492' type='int find_suitable_fallback(struct free_area * area, unsigned int order, int migratetype, bool only_stealable, bool * can_steal)'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='2649' u='c' c='__rmqueue_fallback'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='2675' u='c' c='__rmqueue_fallback'/>
<doc f='linux-5.3.1/mm/page_alloc.c' l='2457'>/*
 * Check whether there is a suitable fallback freepage with requested order.
 * If only_stealable is true, this function returns fallback_mt only if
 * we can steal other freepages all together. This would help to reduce
 * fragmentation due to mixed migratetype pages in one pageblock.
 */</doc>
