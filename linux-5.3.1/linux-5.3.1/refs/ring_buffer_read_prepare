<dec f='linux-5.3.1/include/linux/ring_buffer.h' l='131' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * buffer, int cpu, gfp_t flags)'/>
<def f='linux-5.3.1/kernel/trace/ring_buffer.c' l='4202' ll='4223' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * buffer, int cpu, gfp_t flags)'/>
<dec f='linux-5.3.1/kernel/trace/ring_buffer.c' l='4224' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * , int , gfp_t )'/>
<use f='linux-5.3.1/kernel/trace/ring_buffer.c' l='4224' c='ring_buffer_read_prepare'/>
<use f='linux-5.3.1/kernel/trace/ring_buffer.c' l='4224' u='a'/>
<doc f='linux-5.3.1/kernel/trace/ring_buffer.c' l='4181'>/**
 * ring_buffer_read_prepare - Prepare for a non consuming read of the buffer
 * @buffer: The ring buffer to read from
 * @cpu: The cpu buffer to iterate over
 * @flags: gfp flags to use for memory allocation
 *
 * This performs the initial preparations necessary to iterate
 * through the buffer.  Memory is allocated, buffer recording
 * is disabled, and the iterator pointer is returned to the caller.
 *
 * Disabling buffer recording prevents the reading from being
 * corrupted. This is not a consuming read, so a producer is not
 * expected.
 *
 * After a sequence of ring_buffer_read_prepare calls, the user is
 * expected to make at least one call to ring_buffer_read_prepare_sync.
 * Afterwards, ring_buffer_read_start is invoked to get things going
 * for real.
 *
 * This overall must be paired with ring_buffer_read_finish.
 */</doc>
<use f='linux-5.3.1/kernel/trace/trace.c' l='4110' u='c' c='__tracing_open'/>
<use f='linux-5.3.1/kernel/trace/trace.c' l='4121' u='c' c='__tracing_open'/>
