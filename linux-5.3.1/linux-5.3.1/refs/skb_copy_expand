<dec f='linux-5.3.1/include/linux/skbuff.h' l='1125' type='struct sk_buff * skb_copy_expand(const struct sk_buff * skb, int newheadroom, int newtailroom, gfp_t priority)'/>
<use f='linux-5.3.1/drivers/net/ethernet/broadcom/tg3.c' l='7818' u='c' c='tigon3_dma_hwbug_workaround'/>
<use f='linux-5.3.1/lib/kobject_uevent.c' l='702' u='c' c='uevent_net_broadcast'/>
<def f='linux-5.3.1/net/core/skbuff.c' l='1738' ll='1775' type='struct sk_buff * skb_copy_expand(const struct sk_buff * skb, int newheadroom, int newtailroom, gfp_t gfp_mask)'/>
<dec f='linux-5.3.1/net/core/skbuff.c' l='1776' type='struct sk_buff * skb_copy_expand(const struct sk_buff * , int , int , gfp_t )'/>
<use f='linux-5.3.1/net/core/skbuff.c' l='1776' c='skb_copy_expand'/>
<use f='linux-5.3.1/net/core/skbuff.c' l='1776' u='a'/>
<use f='linux-5.3.1/net/core/skbuff.c' l='4357' u='c' c='skb_cow_data'/>
<doc f='linux-5.3.1/net/core/skbuff.c' l='1720'>/**
 *	skb_copy_expand	-	copy and expand sk_buff
 *	@skb: buffer to copy
 *	@newheadroom: new free bytes at head
 *	@newtailroom: new free bytes at tail
 *	@gfp_mask: allocation priority
 *
 *	Make a copy of both an &amp;sk_buff and its data and while doing so
 *	allocate additional space.
 *
 *	This is used when the caller wishes to modify the data and needs a
 *	private copy of the data to alter as well as more space for new fields.
 *	Returns %NULL on failure or the pointer to the buffer
 *	on success. The returned buffer has a reference count of 1.
 *
 *	You must pass %GFP_ATOMIC as the allocation priority if this function
 *	is called from an interrupt.
 */</doc>
<use f='linux-5.3.1/net/mac80211/rx.c' l='737' u='c' c='ieee80211_make_monitor_skb'/>
<use f='linux-5.3.1/net/mac80211/rx.c' l='3420' u='c' c='ieee80211_rx_h_action_return'/>
