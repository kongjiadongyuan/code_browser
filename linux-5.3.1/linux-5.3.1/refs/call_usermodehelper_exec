<dec f='linux-5.3.1/include/linux/umh.h' l='57' type='int call_usermodehelper_exec(struct subprocess_info * info, int wait)'/>
<use f='linux-5.3.1/fs/coredump.c' l='685' u='c' c='do_coredump'/>
<use f='linux-5.3.1/init/do_mounts_initrd.c' l='87' u='c' c='handle_initrd'/>
<use f='linux-5.3.1/kernel/kmod.c' l='99' u='c' c='call_modprobe'/>
<use f='linux-5.3.1/kernel/umh.c' l='524' u='c' c='fork_usermode_blob'/>
<def f='linux-5.3.1/kernel/umh.c' l='548' ll='602' type='int call_usermodehelper_exec(struct subprocess_info * sub_info, int wait)'/>
<dec f='linux-5.3.1/kernel/umh.c' l='603' type='int call_usermodehelper_exec(struct subprocess_info * , int )'/>
<use f='linux-5.3.1/kernel/umh.c' l='603' c='call_usermodehelper_exec'/>
<use f='linux-5.3.1/kernel/umh.c' l='603' u='a'/>
<use f='linux-5.3.1/kernel/umh.c' l='628' u='c' c='call_usermodehelper'/>
<doc f='linux-5.3.1/kernel/umh.c' l='536'>/**
 * call_usermodehelper_exec - start a usermode application
 * @sub_info: information about the subprocessa
 * @wait: wait for the application to finish and return status.
 *        when UMH_NO_WAIT don&apos;t wait at all, but you get no useful error back
 *        when the program couldn&apos;t be exec&apos;ed. This makes it safe to call
 *        from interrupt context.
 *
 * Runs a user-space application.  The application is started
 * asynchronously if wait is not set, and runs as a child of system workqueues.
 * (ie. it runs with full root capabilities and optimized affinity).
 */</doc>
<use f='linux-5.3.1/security/keys/request_key.c' l='108' u='c' c='call_usermodehelper_keys'/>
