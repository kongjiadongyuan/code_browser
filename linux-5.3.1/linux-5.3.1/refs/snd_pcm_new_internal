<dec f='linux-5.3.1/include/sound/pcm.h' l='530' type='int snd_pcm_new_internal(struct snd_card * card, const char * id, int device, int playback_count, int capture_count, struct snd_pcm ** rpcm)'/>
<def f='linux-5.3.1/sound/core/pcm.c' l='801' ll='807' type='int snd_pcm_new_internal(struct snd_card * card, const char * id, int device, int playback_count, int capture_count, struct snd_pcm ** rpcm)'/>
<dec f='linux-5.3.1/sound/core/pcm.c' l='808' type='int snd_pcm_new_internal(struct snd_card * , const char * , int , int , int , struct snd_pcm ** )'/>
<use f='linux-5.3.1/sound/core/pcm.c' l='808' c='snd_pcm_new_internal'/>
<use f='linux-5.3.1/sound/core/pcm.c' l='808' u='a'/>
<doc f='linux-5.3.1/sound/core/pcm.c' l='781'>/**
 * snd_pcm_new_internal - create a new internal PCM instance
 * @card: the card instance
 * @id: the id string
 * @device: the device index (zero based - shared with normal PCMs)
 * @playback_count: the number of substreams for playback
 * @capture_count: the number of substreams for capture
 * @rpcm: the pointer to store the new pcm instance
 *
 * Creates a new internal PCM instance with no userspace device or procfs
 * entries. This is used by ASoC Back End PCMs in order to create a PCM that
 * will only be used internally by kernel drivers. i.e. it cannot be opened
 * by userspace. It provides existing ASoC components drivers with a substream
 * and access to any private data.
 *
 * The pcm operators have to be set afterwards to the new instance
 * via snd_pcm_set_ops().
 *
 * Return: Zero if successful, or a negative error code on failure.
 */</doc>
