<def f='linux-5.3.1/include/linux/rfkill.h' l='61' ll='65'/>
<use f='linux-5.3.1/include/linux/rfkill.h' l='82' c='rfkill_alloc'/>
<use f='linux-5.3.1/drivers/platform/x86/eeepc-laptop.c' l='763'/>
<size>24</size>
<doc f='linux-5.3.1/include/linux/rfkill.h' l='43'>/**
 * struct rfkill_ops - rfkill driver methods
 *
 * @poll: poll the rfkill block state(s) -- only assign this method
 *	when you need polling. When called, simply call one of the
 *	rfkill_set{,_hw,_sw}_state family of functions. If the hw
 *	is getting unblocked you need to take into account the return
 *	value of those functions to make sure the software block is
 *	properly used.
 * @query: query the rfkill block state(s) and call exactly one of the
 *	rfkill_set{,_hw,_sw}_state family of functions. Assign this
 *	method if input events can cause hardware state changes to make
 *	the rfkill core query your driver before setting a requested
 *	block.
 * @set_block: turn the transmitter on (blocked == false) or off
 *	(blocked == true) -- ignore and return 0 when hard blocked.
 *	This callback must be assigned.
 */</doc>
<mbr r='rfkill_ops::poll' o='0' t='void (*)(struct rfkill *, void *)'/>
<mbr r='rfkill_ops::query' o='64' t='void (*)(struct rfkill *, void *)'/>
<mbr r='rfkill_ops::set_block' o='128' t='int (*)(void *, bool)'/>
<use f='linux-5.3.1/net/rfkill/core.c' l='51'/>
<use f='linux-5.3.1/net/rfkill/core.c' l='922' c='rfkill_alloc'/>
<size>24</size>
<use f='linux-5.3.1/net/wireless/core.h' l='29'/>
<size>24</size>
