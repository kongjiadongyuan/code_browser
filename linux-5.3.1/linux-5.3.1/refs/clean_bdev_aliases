<dec f='linux-5.3.1/include/linux/buffer_head.h' l='175' type='void clean_bdev_aliases(struct block_device * bdev, sector_t block, sector_t len)'/>
<use f='linux-5.3.1/include/linux/buffer_head.h' l='179' u='c' c='clean_bdev_bh_alias'/>
<def f='linux-5.3.1/fs/buffer.c' l='1563' ll='1614' type='void clean_bdev_aliases(struct block_device * bdev, sector_t block, sector_t len)'/>
<dec f='linux-5.3.1/fs/buffer.c' l='1615' type='void clean_bdev_aliases(struct block_device * , sector_t , sector_t )'/>
<use f='linux-5.3.1/fs/buffer.c' l='1615' c='clean_bdev_aliases'/>
<use f='linux-5.3.1/fs/buffer.c' l='1615' u='a'/>
<doc f='linux-5.3.1/fs/buffer.c' l='1543'>/**
 * clean_bdev_aliases: clean a range of buffers in block device
 * @bdev: Block device to clean buffers in
 * @block: Start of a range of blocks to clean
 * @len: Number of blocks to clean
 *
 * We are taking a range of blocks for data and we don&apos;t want writeback of any
 * buffer-cache aliases starting from return from this function and until the
 * moment when something will explicitly mark the buffer dirty (hopefully that
 * will not happen until we will free that block ;-) We don&apos;t even need to mark
 * it not-uptodate - nobody can expect anything from a newly allocated buffer
 * anyway. We used to use unmap_buffer() for such invalidation, but that was
 * wrong. We definitely don&apos;t want to mark the alias unmapped, for example - it
 * would confuse anyone who might pick it with bread() afterwards...
 *
 * Also..  Note that bforget() doesn&apos;t lock the buffer.  So there can be
 * writeout I/O going on against recently-freed buffers.  We don&apos;t wait on that
 * I/O in bforget() - it&apos;s more efficient to wait on the I/O only if we really
 * need to.  That happens here.
 */</doc>
<use f='linux-5.3.1/fs/direct-io.c' l='1008' u='c' c='do_direct_IO'/>
