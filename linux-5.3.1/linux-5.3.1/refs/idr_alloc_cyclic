<dec f='linux-5.3.1/include/linux/idr.h' l='117' type='int idr_alloc_cyclic(struct idr * , void * ptr, int start, int end, gfp_t )'/>
<use f='linux-5.3.1/fs/kernfs/dir.c' l='638' u='c' c='__kernfs_new_node'/>
<use f='linux-5.3.1/fs/notify/inotify/inotify_user.c' l='356' u='c' c='inotify_add_to_idr'/>
<use f='linux-5.3.1/ipc/util.c' l='229' u='c' c='ipc_idr_alloc'/>
<use f='linux-5.3.1/kernel/cgroup/cgroup.c' l='1295' u='c' c='cgroup_init_root_id'/>
<use f='linux-5.3.1/kernel/pid.c' l='193' u='c' c='alloc_pid'/>
<def f='linux-5.3.1/lib/idr.c' l='117' ll='135' type='int idr_alloc_cyclic(struct idr * idr, void * ptr, int start, int end, gfp_t gfp)'/>
<dec f='linux-5.3.1/lib/idr.c' l='136' type='int idr_alloc_cyclic(struct idr * , void * , int , int , gfp_t )'/>
<use f='linux-5.3.1/lib/idr.c' l='136' c='idr_alloc_cyclic'/>
<use f='linux-5.3.1/lib/idr.c' l='136' u='a'/>
<doc f='linux-5.3.1/lib/idr.c' l='95'>/**
 * idr_alloc_cyclic() - Allocate an ID cyclically.
 * @idr: IDR handle.
 * @ptr: Pointer to be associated with the new ID.
 * @start: The minimum ID (inclusive).
 * @end: The maximum ID (exclusive).
 * @gfp: Memory allocation flags.
 *
 * Allocates an unused ID in the range specified by @nextid and @end.  If
 * @end is &lt;= 0, it is treated as one larger than %INT_MAX.  This allows
 * callers to use @start + N as @end as long as N is within integer range.
 * The search for an unused ID will start at the last ID allocated and will
 * wrap around to @start if no free IDs are found before reaching @end.
 *
 * The caller should provide their own locking to ensure that two
 * concurrent modifications to the IDR are not possible.  Read-only
 * accesses to the IDR may be done under the RCU read lock or may
 * exclude simultaneous writers.
 *
 * Return: The newly allocated ID, -ENOMEM if memory allocation failed,
 * or -ENOSPC if no free IDs could be found.
 */</doc>
<use f='linux-5.3.1/net/netlink/genetlink.c' l='365' u='c' c='genl_register_family'/>
