<dec f='linux-5.3.1/include/net/tcp.h' l='288' type='void sk_forced_mem_schedule(struct sock * sk, int size)'/>
<use f='linux-5.3.1/net/ipv4/tcp.c' l='881' u='c' c='sk_stream_alloc_skb'/>
<use f='linux-5.3.1/net/ipv4/tcp_fastopen.c' l='184' u='c' c='tcp_fastopen_add_skb'/>
<use f='linux-5.3.1/net/ipv4/tcp_input.c' l='4739' u='c' c='tcp_data_queue'/>
<def f='linux-5.3.1/net/ipv4/tcp_output.c' l='3093' ll='3105' type='void sk_forced_mem_schedule(struct sock * sk, int size)'/>
<use f='linux-5.3.1/net/ipv4/tcp_output.c' l='3144' u='c' c='tcp_send_fin'/>
<doc f='linux-5.3.1/net/ipv4/tcp_output.c' l='3086'>/* We allow to exceed memory limits for FIN packets to expedite
 * connection tear down and (memory) recovery.
 * Otherwise tcp_send_fin() could be tempted to either delay FIN
 * or even be forced to close flow without any FIN.
 * In general, we want to allow one skb per socket to avoid hangs
 * with edge trigger epoll()
 */</doc>
