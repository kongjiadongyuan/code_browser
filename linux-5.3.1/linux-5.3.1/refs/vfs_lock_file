<dec f='linux-5.3.1/include/linux/fs.h' l='1150' type='int vfs_lock_file(struct file * , unsigned int , struct file_lock * , struct file_lock * )'/>
<use f='linux-5.3.1/fs/lockd/svclock.c' l='545' u='c' c='nlmsvc_lock'/>
<use f='linux-5.3.1/fs/lockd/svclock.c' l='675' u='c' c='nlmsvc_unlock'/>
<use f='linux-5.3.1/fs/lockd/svclock.c' l='837' u='c' c='nlmsvc_grant_blocked'/>
<use f='linux-5.3.1/fs/lockd/svcsubs.c' l='191' u='c' c='nlm_traverse_locks'/>
<def f='linux-5.3.1/fs/locks.c' l='2332' ll='2338' type='int vfs_lock_file(struct file * filp, unsigned int cmd, struct file_lock * fl, struct file_lock * conf)'/>
<dec f='linux-5.3.1/fs/locks.c' l='2339' type='int vfs_lock_file(struct file * , unsigned int , struct file_lock * , struct file_lock * )'/>
<use f='linux-5.3.1/fs/locks.c' l='2339' c='vfs_lock_file'/>
<use f='linux-5.3.1/fs/locks.c' l='2339' u='a'/>
<use f='linux-5.3.1/fs/locks.c' l='2351' u='c' c='do_lock_file_wait'/>
<use f='linux-5.3.1/fs/locks.c' l='2629' u='c' c='locks_remove_posix'/>
<doc f='linux-5.3.1/fs/locks.c' l='2299'>/**
 * vfs_lock_file - file byte range lock
 * @filp: The file to apply the lock to
 * @cmd: type of locking operation (F_SETLK, F_GETLK, etc.)
 * @fl: The lock to be applied
 * @conf: Place to return a copy of the conflicting lock, if found.
 *
 * A caller that doesn&apos;t care about the conflicting lock may pass NULL
 * as the final argument.
 *
 * If the filesystem defines a private -&gt;lock() method, then @conf will
 * be left unchanged; so a caller that cares should initialize it to
 * some acceptable default.
 *
 * To avoid blocking kernel daemons, such as lockd, that need to acquire POSIX
 * locks, the -&gt;lock() interface may return asynchronously, before the lock has
 * been granted or denied by the underlying filesystem, if (and only if)
 * lm_grant is set. Callers expecting -&gt;lock() to return asynchronously
 * will only use F_SETLK, not F_SETLKW; they will set FL_SLEEP if (and only if)
 * the request is for a blocking lock. When -&gt;lock() does return asynchronously,
 * it must return FILE_LOCK_DEFERRED, and call -&gt;lm_grant() when the lock
 * request completes.
 * If the request is for non-blocking lock the file system should return
 * FILE_LOCK_DEFERRED then try to get the lock and call the callback routine
 * with the result. If the request timed out the callback routine will return a
 * nonzero return code and the file system should release the lock. The file
 * system is also responsible to keep a corresponding posix lock when it
 * grants a lock so the VFS can find out which locks are locally held and do
 * the correct lock cleanup when required.
 * The underlying filesystem must not drop the kernel lock or call
 * -&gt;lm_grant() before returning to the caller with a FILE_LOCK_DEFERRED
 * return code.
 */</doc>
