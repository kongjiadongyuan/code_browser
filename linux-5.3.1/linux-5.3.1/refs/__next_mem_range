<dec f='linux-5.3.1/include/linux/memblock.h' l='134' type='void __next_mem_range(u64 * idx, int nid, enum memblock_flags flags, struct memblock_type * type_a, struct memblock_type * type_b, phys_addr_t * out_start, phys_addr_t * out_end, int * out_nid)'/>
<use f='linux-5.3.1/arch/x86/kernel/check.c' l='115' macro='1' u='c' c='setup_bios_corruption_check'/>
<use f='linux-5.3.1/arch/x86/kernel/check.c' l='115' macro='1' u='c' c='setup_bios_corruption_check'/>
<use f='linux-5.3.1/arch/x86/mm/init.c' l='922' macro='1' u='c' c='memblock_find_dma_reserve'/>
<use f='linux-5.3.1/arch/x86/mm/init.c' l='922' macro='1' u='c' c='memblock_find_dma_reserve'/>
<use f='linux-5.3.1/mm/memblock.c' l='197' macro='1' u='c' c='__memblock_find_range_bottom_up'/>
<use f='linux-5.3.1/mm/memblock.c' l='197' macro='1' u='c' c='__memblock_find_range_bottom_up'/>
<def f='linux-5.3.1/mm/memblock.c' l='1014' ll='1092' type='void __next_mem_range(u64 * idx, int nid, enum memblock_flags flags, struct memblock_type * type_a, struct memblock_type * type_b, phys_addr_t * out_start, phys_addr_t * out_end, int * out_nid)'/>
<use f='linux-5.3.1/mm/memblock.c' l='1939' macro='1' u='c' c='free_low_memory_core_early'/>
<use f='linux-5.3.1/mm/memblock.c' l='1939' macro='1' u='c' c='free_low_memory_core_early'/>
<doc f='linux-5.3.1/mm/memblock.c' l='988'>/**
 * __next_mem_range - next function for for_each_free_mem_range() etc.
 * @idx: pointer to u64 loop variable
 * @nid: node selector, %NUMA_NO_NODE for all nodes
 * @flags: pick from blocks based on memory attributes
 * @type_a: pointer to memblock_type from where the range is taken
 * @type_b: pointer to memblock_type which excludes memory from being taken
 * @out_start: ptr to phys_addr_t for start address of the range, can be %NULL
 * @out_end: ptr to phys_addr_t for end address of the range, can be %NULL
 * @out_nid: ptr to int for nid of the range, can be %NULL
 *
 * Find the first area from *@idx which matches @nid, fill the out
 * parameters, and update *@idx for the next iteration.  The lower 32bit of
 * *@idx contains index into type_a and the upper 32bit indexes the
 * areas before each region in type_b.	For example, if type_b regions
 * look like the following,
 *
 *	0:[0-16), 1:[32-48), 2:[128-130)
 *
 * The upper 32bit indexes the following regions.
 *
 *	0:[0-0), 1:[16-32), 2:[48-128), 3:[130-MAX)
 *
 * As both region arrays are sorted, the function advances the two indices
 * in lockstep and returns each intersection.
 */</doc>
<use f='linux-5.3.1/mm/page_alloc.c' l='6915' macro='1' u='c' c='zero_resv_unavail'/>
<use f='linux-5.3.1/mm/page_alloc.c' l='6915' macro='1' u='c' c='zero_resv_unavail'/>
