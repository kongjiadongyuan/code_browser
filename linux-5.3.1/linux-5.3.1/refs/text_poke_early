<dec f='linux-5.3.1/arch/x86/include/asm/text-patching.h' l='35' type='void text_poke_early(void * addr, const void * opcode, size_t len)'/>
<dec f='linux-5.3.1/arch/x86/kernel/alternative.c' l='270' type='void text_poke_early(void * addr, const void * opcode, size_t len)'/>
<use f='linux-5.3.1/arch/x86/kernel/alternative.c' l='435' u='c' c='apply_alternatives'/>
<def f='linux-5.3.1/arch/x86/kernel/alternative.c' l='759' ll='783' type='void text_poke_early(void * addr, const void * opcode, size_t len)'/>
<doc f='linux-5.3.1/arch/x86/kernel/alternative.c' l='747'>/**
 * text_poke_early - Update instructions on a live kernel at boot time
 * @addr: address to modify
 * @opcode: source of the copy
 * @len: length to copy
 *
 * When you use this code to patch more than one byte of an instruction
 * you need to make sure that other CPUs cannot execute this code in parallel.
 * Also no thread must be currently preempted in the middle of these
 * instructions. And on the local CPU you need to be protected again NMI or MCE
 * handlers seeing an inconsistent instruction while you patch.
 */</doc>
<use f='linux-5.3.1/arch/x86/kernel/jump_label.c' l='87' u='c' c='__jump_label_transform'/>
