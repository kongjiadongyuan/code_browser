<dec f='linux-5.3.1/include/linux/task_work.h' l='16' type='int task_work_add(struct task_struct * task, struct callback_head * twork, bool )'/>
<use f='linux-5.3.1/fs/file_table.c' l='340' u='c' c='fput_many'/>
<use f='linux-5.3.1/fs/namespace.c' l='1178' u='c' c='mntput_no_expire'/>
<use f='linux-5.3.1/kernel/events/uprobes.c' l='1775' u='c' c='uprobe_copy_process'/>
<use f='linux-5.3.1/kernel/irq/manage.c' l='1089' u='c' c='irq_thread'/>
<def f='linux-5.3.1/kernel/task_work.c' l='27' ll='42' type='int task_work_add(struct task_struct * task, struct callback_head * work, bool notify)'/>
<doc f='linux-5.3.1/kernel/task_work.c' l='8'>/**
 * task_work_add - ask the @task to execute @work-&gt;func()
 * @task: the task which should run the callback
 * @work: the callback to run
 * @notify: send the notification if true
 *
 * Queue @work for task_work_run() below and notify the @task if @notify.
 * Fails if the @task is exiting/exited and thus it can&apos;t process this @work.
 * Otherwise @work-&gt;func() will be called when the @task returns from kernel
 * mode or exits.
 *
 * This is like the signal handler which runs in kernel mode, but it doesn&apos;t
 * try to wake up the @task.
 *
 * Note: there is no ordering guarantee on works queued here.
 *
 * RETURNS:
 * 0 if succeeds or -ESRCH.
 */</doc>
<use f='linux-5.3.1/security/keys/keyctl.c' l='1625' u='c' c='keyctl_session_to_parent'/>
