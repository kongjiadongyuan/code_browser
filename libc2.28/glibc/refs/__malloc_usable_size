<dec f='glibc/malloc/malloc.c' l='676' type='size_t __malloc_usable_size(void * )'/>
<def f='glibc/malloc/malloc.c' l='4858' ll='4865' type='size_t __malloc_usable_size(void * m)'/>
<use f='glibc/malloc/malloc.c' l='5576' c='malloc_usable_size'/>
<doc f='glibc/malloc/malloc.c' l='661'>/*
  malloc_usable_size(void* p);

  Returns the number of bytes you can actually use in
  an allocated chunk, which may be more than you requested (although
  often not) due to alignment and minimum size constraints.
  You can use this many bytes without worrying about
  overwriting other allocated objects. This is not a particularly great
  programming practice. malloc_usable_size can be more useful in
  debugging and assertions, for example:

  p = malloc(n);
  assert(malloc_usable_size(p) &gt;= 256);

*/</doc>
